/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/hop/hop.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Thu Jun 26 08:21:30 2014                          */
/*    Last change :  Wed Aug 28 08:42:37 2024 (serrano)                */
/*    Copyright   :  2014-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    HOP module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as _hop from "./_hop.hop";
import { init as configInit } from "./config.mjs";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';

export { Hop,
	 HTTPResponseFile, HTTPResponseString,
	 HTTPResponseAuthentication, HTTPResponseHTML };

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
// @sealed
class Hop {
   ports = { http: 0, https: 0 };
   config;
   #httpServer;
   #httpsServer;
   
   constructor(config) {
      this.config = configInit(config);
      this.config.users.forEach(_hop.addUser);
   }

   listen() {
      const { ports, listenAddress, soMaxConn, maxThread } = this.config;

      return new Promise((res, rej) => {
	 if (ports.http && ports.http >= 0) {
	    const srv = _hop.createServer(ports.http, listenAddress, soMaxConn);
	    if (_hop.isSocketServer(srv)) {
	       const sched = _hop.createScheduler(maxThread);
	       this.#httpServer= srv;
	       this.ports.http = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	       
	    } else {
	       rej(new Error(`Cannot open server ${ports.http}`));
	    }
	 }
	 
	 if (ports.https && ports.https >= 0) {
	    const sched = _hop.createScheduler(maxThread);
	    const cert = readFileSync(this.config.credentials.cert);
	    const key = readFileSync(this.config.credentials.key);
	    const srv = _hop.createServerSSL(ports.https, listenAddress, soMaxConn, cert, key);

	    if (_hop.isSocketServer(srv)) {
	       this.backend.httpsServer= srv;
	       this.ports.https = _hop.socketPortNumber(srv);
	       sched.accept(srv);
	    } else {
	       rej(new Error(`Cannot open server ${ports.https}`));
	    }
	 }

	 if (this.config.verbose >= 1 && this.config.motd) {
	    console.log(this.config.motd, this.ports.http, this.ports.https);
	 }
	 
	 res(this);
      });
   }

   schema() {
      if (this.ports.https > 0) {
	 return `https://${this.config.hostname}:${thisports.https}`;
      } else {
	 return `http://${this.config.hostname}:${this.ports.http}`;
      }
   }
   
   Resolver(root = undefined) {
      if (!root) {
	 root = dirname(__dirname);
      }
      return new Resolver(this, root);
   }
   
   Service(fun, optOrUrl) {
      if (!(this instanceof Hop)) {
	 throw new TypeError(`${impl.path()}, illegal "this" -- ${this}`);
      } else {
	 return _hop.Service.call(this, fun, optOrUrl || ("/" + fun.name));
      }
   }

   broadcast(evt, val) {
      return ;
   }
   
   passwordEncrypt(name, pass, realm = "hop") {
      return _hop.digestPasswordEncrypt(name, pass, realm);
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
// @sealed
class Resolver {
   #hop;
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   static getRootDir(url) {
      if (!url) {
	 return process.cwd();
      } else {
	 const urlpath = url instanceof URL
	    ? fileURLToPath(url)
	    : url.replace(/^file:\/\//, "");
	 const normpath = normalize(urlpath);
	 
	 if (!existsSync(urlpath)) {
	    throw new Error(`resolver path does not exist ${url}`);
	 } else {
	    if (statSync(urlpath).isDirectory()) {
	       return normpath;
	    } else {
	       return dirname(normpath);
	    }
	 }
      }
   }

   constructor(hop, root) {
      this.#hop = hop;
      this.#root = Resolver.getRootDir(root);
      this.#num = Resolver.num++;

      _hop.static.call(this.#hop, this.#num, this.#root);
   }

   url(file) {
      const relfile = isAbsolute(file) ? relative(this.#root, file) : file;
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (old) {
	 return old.url;
      } else if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`file not in resolver root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`file does not exist in resolver directory "${this.#root}/${relfile}"`);
      } else {
	 const url = `/hop/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   path(url) {
      return this.#pathTable.get(url);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(file, req) {
   return _hop.HTTPResponseFile(file, req);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(string, req) {
   return _hop.HTTPResponseString(string, req);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponsAuthentication ...                                    */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(auth, req) {
   return _hop.HTTPResponseAuthentication(auth, req);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponsHTML ...                                              */
/*---------------------------------------------------------------------*/
function HTTPResponseHTML(xml, req) {
   return _hop.HTTPResponseHTML(xml, req);
}

/*---------------------------------------------------------------------*/
/*    HTML tags                                                        */
/*---------------------------------------------------------------------*/
export const A = globalThis.A;
export const ABBR = globalThis.ABBR;
export const ACRONYM = globalThis.ACRONYM;
export const ADDRESS = globalThis.ADDRESS;
export const APPLET = globalThis.APPLET;
export const AREA = globalThis.AREA;
export const ARTICLE = globalThis.ARTICLE;
export const AUDIO = globalThis.AUDIO;
export const B = globalThis.B;
export const BASE = globalThis.BASE;
export const BASEFONT = globalThis.BASEFONT;
export const BDI = globalThis.BDI;
export const BDO = globalThis.BDO;
export const BIG = globalThis.BIG;
export const BLOCKQUOTE = globalThis.BLOCKQUOTE;
export const BODY = globalThis.BODY;
export const BR = globalThis.BR;
export const BUTTON = globalThis.BUTTON;
export const CANVAS = globalThis.CANVAS;
export const CAPTION = globalThis.CAPTION;
export const CENTER = globalThis.CENTER;
export const CITE = globalThis.CITE;
export const CODE = globalThis.CODE;
export const COL = globalThis.COL;
export const COLGROUP = globalThis.COLGROUP;
export const DATALIST = globalThis.DATALIST;
export const DD = globalThis.DD;
export const DEL = globalThis.DEL;
export const DETAILS = globalThis.DETAILS;
export const DFN = globalThis.DFN;
export const DIR = globalThis.DIR;
export const DIV = globalThis.DIV;
export const DL = globalThis.DL;
export const DT = globalThis.DT;
export const EM = globalThis.EM;
export const EMBED = globalThis.EMBED;
export const FIELDSET = globalThis.FIELDSET;
export const FIGURE = globalThis.FIGURE;
export const FIGCAPTION = globalThis.FIGCAPTION;
export const FONT = globalThis.FONT;
export const FOOTER = globalThis.FOOTER;
export const FORM = globalThis.FORM;
export const FRAME = globalThis.FRAME;
export const FRAMESET = globalThis.FRAMESET;
export const H1 = globalThis.H1;
export const H2 = globalThis.H2;
export const H3 = globalThis.H3;
export const H4 = globalThis.H4;
export const H5 = globalThis.H5;
export const H6 = globalThis.H6;
export const HR = globalThis.HR;
export const HEAD = globalThis.HEAD;
export const HEADER = globalThis.HEADER;
export const HGROUP = globalThis.HGROUP;
export const I = globalThis.I;
export const IFRAME = globalThis.IFRAME;
export const INPUT = globalThis.INPUT;
export const INS = globalThis.INS;
export const ISINDEX = globalThis.ISINDEX;
export const KBD = globalThis.KBD;
export const LABEL = globalThis.LABEL;
export const LEGEND = globalThis.LEGEND;
export const LI = globalThis.LI;
export const MAIN = globalThis.MAIN;
export const MAP = globalThis.MAP;
export const MARQUEE = globalThis.MARQUEE;
export const MENU = globalThis.MENU;
export const MENUITEM = globalThis.MENUITEM;
export const META = globalThis.META;
export const METER = globalThis.METER;
export const NAV = globalThis.NAV;
export const NOFRAMES = globalThis.NOFRAMES;
export const NOSCRIPT = globalThis.NOSCRIPT;
export const OBJECT = globalThis.OBJECT;
export const OL = globalThis.OL;
export const OPTGROUP = globalThis.OPTGROUP;
export const OPTION = globalThis.OPTION;
export const P = globalThis.P;
export const PARAM = globalThis.PARAM;
export const PRE = globalThis.PRE;
export const PROGRESS = globalThis.PROGRESS;
export const Q = globalThis.Q;
export const S = globalThis.S;
export const SAMP = globalThis.SAMP;
export const SECTION = globalThis.SECTION;
export const SELECT = globalThis.SELECT;
export const SCRIPT = globalThis.SCRIPT;
export const SMALL = globalThis.SMALL;
export const SOURCE = globalThis.SOURCE;
export const SPAN = globalThis.SPAN;
export const STRIKE = globalThis.STRIKE;
export const STRONG = globalThis.STRONG;
export const SUB = globalThis.SUB;
export const SUMMARY = globalThis.SUMMARY;
export const SUP = globalThis.SUP;
export const TABLE = globalThis.TABLE;
export const TBODY = globalThis.TBODY;
export const TD = globalThis.TD;
export const TEXTAREA = globalThis.TEXTAREA;
export const TFOOT = globalThis.TFOOT;
export const TH = globalThis.TH;
export const THEAD = globalThis.THEAD;
export const TILDE = (_, body) => globalThis.Tilde(body);
export const TIME = globalThis.TIME;
export const TITLE = globalThis.TITLE;
export const TR = globalThis.TR;
export const TRACK = globalThis.TRACK;
export const TT = globalThis.TT;
export const U = globalThis.U;
export const UL = globalThis.UL;
export const VAR = globalThis.VAR;
export const VIDEO = globalThis.VIDEO;
export const REACT = globalThis.REACT;
export const LINK = globalThis.LINK;
export const STYLE = globalThis.STYLE;
export const IMG = globalThis.IMG;
export const HTML = globalThis.HTML;

/*---------------------------------------------------------------------*/
/*    DOLLAR ...                                                       */
/*---------------------------------------------------------------------*/
export function DOLLAR(expr, loc) {
   
   function error(expr, loc) {
      const l = loc ? `${loc.filename}:${loc.offset}: DOLLAR,` : "DOLLAR:";
      throw `${l} don't know how to compile "${expr}"`;
   }
   
   switch (typeof expr) {
      case "string": return "'" + expr + "'";
      case "number": return expr;
      case "boolean": return expr;
      case "undefined": return expr;
      case "null": return expr;
      case "function": {
	 if ("dollar" in expr) {
	    return expr.dollar();
	 } else {
	    error(expr, loc);
	 }
      }
      case "object": {
	 if ("dollar" in expr) {
	    return expr.dollar();
	 } else if (Array.isArray(expr)) {
	    return `[${expr.map(n => DOLLAR(n, loc)).toString()}]`;
	 } else if (expr instanceof Date) {
	    return `new Date(${expr.getTime()})`;
	 } else {
	    let str = "{"
	    for (let k in expr) {
	       str += `['${k}']: ${DOLLAR(expr[k], loc)},`;
	    }
	    return str + "}";
	 }
      }
      default: error(expr, loc);
   }
}
		 
/*---------------------------------------------------------------------*/
/*    SVG ...                                                          */
/*---------------------------------------------------------------------*/
export const SVG = (attrs, ...nodes) => new XmlElement("svg", attrs, nodes);
SVG.IMG = (attrs, ...nodes) => HtmlElement("svg:img", attrs, nodes);

