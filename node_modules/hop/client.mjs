/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/client.mjs         */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Wed Jan 31 08:34:57 2024                          */
/*    Last change :  Sat Apr  5 07:44:01 2025 (serrano)                */
/*    Copyright   :  2024-25 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    Hop client-side part.                                            */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Module declaration                                               */
/*---------------------------------------------------------------------*/
export { server };

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
class Frame {
   #svc;
   #path;
   #args;
   #options;
   #header;
   
   constructor(svc, path, args, options, header) {
      this.#svc = svc;
      this.#path = path;
      this.#args = Array.from(args);
      this.#options = options ?? {};
      this.#header = header;
   }

   toString() {
      if (this.#args) {
	 let json = JSON.stringify(this.#args);
	 return String.prototype.concat.apply(
	    `${this.#path}?hop-encoding=hopjs&vals=${this.#args.length}.`,
	    this.#args.map(encode));
      } else {
	 return this.#path;
      }
   }

   post(opts) {
      return new Promise((res, rej) => {
	 const req = Frame.XMLHttpRequest(res, rej);
	 if (this.#args.length === 0) {
	    req.open("PUT", this.#path, this.#options?.async ?? true);
	    req.setRequestHeader("Hop-Serialize", "json");
	 } else {
	    req.open("POST", this.#path, this.#options?.async ?? true);

	    if (this.#options?.enc === "json") {
	       req.setRequestHeader("Hop-Arguments", JSON.stringify(this.#args));
	       req.setRequestHeader("Hop-Serialize", "json");
	    } else {
	       const args =
		  String.prototype.concat.apply(
		     `hop-encoding=hopjs&vals=${this.#args.length}.`,
		     this.#args.map(encode));
	       req.setRequestHeader("Hopjs-Arguments", args);
	    }
	 }
	 
	 try {
	    req.send();
	 } catch (e) {
	    rej(e);
	 }
      });
   }

   static XMLHttpRequest(res, rej) {
      const req = new XMLHttpRequest();

      req.onreadystatechange = req.onload = function() {
	 if (this.readyState === 4) {
	    switch (this.status) {
	       case 200:
		  res(decode(this.response, req.getResponseHeader("Hop-Serialize")));
		  break;
		  
	       case 400:
	       case 407:
	       case 500:
		  rej(this.response);
		  break;
		  
	       default: {
		  if (this.status > 200 && this.status < 300) {
		     res(this.response);
		  } else {
		     rej(this.response);
		  }
		  break;
	       }
	    }
	 }
      };

      return req;
   }
}

/*---------------------------------------------------------------------*/
/*    encode ...                                                       */
/*    -------------------------------------------------------------    */
/*    See hop/_hop.hop and node/hop.mjs                                */
/*---------------------------------------------------------------------*/
function encode(val) {
   if (typeof val === "string") {
      const e = encodeURIComponent(val);

      if (val === e) {
	 return `S${e.length}.${e}`;
      } else {
	 return `s${e.length}.${e}`;
      }
   } else if (typeof val === "number") {
      const s = val + "";
      if (Number.isInteger(val)) {
	 return `I${s.length}.${s}`;
      } else {
	 return `N${s.length}.${s}`;
      }
   } else if (val === undefined) {
      return "U";
   } else if (val === null) {
      return "Z";
   } else if (val === true) {
      return "T";
   } else if (val === false) {
      return "F";
   } else if (val instanceof Date) {
      const s = val.valueOf();
      return `D${s.elgnth}.${s}`;
   } else {
      const s = JSON.stringify(val);
      const e = encodeURIComponent(s);

      if (s === e) {
	 return `J${e.length}.${e}`;
      } else {
	 return `j${e.length}.${e}`;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    decode ...                                                       */
/*---------------------------------------------------------------------*/
function decode(resp, format) {
   switch (format) {
      case "string": return resp;
      case "buffer": return resp;
      case "number": return Number(resp);
      case "json": return JSON.parse(resp);
      case "html": return HTMLparse(resp);
      case "null": return null;
      case "undefined": return undefined;
      case "true": return true;
      case "false": return false;
      case "date": return new Date(parseInt(resp));
      default: return resp;
   }
}

/*---------------------------------------------------------------------*/
/*    tagParent ...                                                    */
/*---------------------------------------------------------------------*/
const tagParent = {
   'tr' : 'tbody',
   'td' : 'tr',
   'th' : 'tr',
   'li' : 'ul',
   'body': 'html'
};

/*---------------------------------------------------------------------*/
/*    HTMLparse ...                                                    */
/*---------------------------------------------------------------------*/
function HTMLparse(html) {
   
   function cloneScriptNode(node) {
      if (node.nodeType != 1) {
	 return node;
      }
      if ((node.tagName !== "SCRIPT") && (node.tagName !== "script")) {
	 node.childNodes.forEach(o => {
	    var n = cloneScriptNode(o);
	    if (n !== o) {
	       node.replaceChild(n,o);
	    }
	 });
	 return node;
      } else {
	 const t = document.createTextNode(node.innerHTML);
	 const s = document.createElement("SCRIPT");
	 s.id = node.id;
	 if (node?.src !== "") {
	    s.src = node.src;
	 }
	 if (node?.onload !== "") {
	    s.onload = node.onload;
	 }
	 if (node?.onerror !== "") {
	    s.onerror = node.onerror;
	 }
	 if (s.text) {
	    s.text = node.innerHTML;
	 } else {
	    s.appendChild( t );
	 }
	 return s;
      }
   }

   const parser = new DOMParser();
   const el = parser.parseFromString(html, 'text/html').body.firstChild;

   if (html.search(/<script[ >]/i) >= 0) {
      return cloneScriptNode(el);
   } else {
      return el;
   }
}

/*---------------------------------------------------------------------*/
/*    Service ...                                                      */
/*---------------------------------------------------------------------*/
function Service(base) {
   var svc = function() { return new Frame(this, base, arguments) };
   svc.base = base;
   svc.__proto__ = Service.prototype;
   return svc;
}

Service.prototype = {
   __proto__: Function.prototype
};

/*---------------------------------------------------------------------*/
/*    Server ...                                                       */
/*---------------------------------------------------------------------*/
class Server {
   #handlers = {};
   #ws = false;
   #host = "";
   #key = -1;
   pingTime = 30 * 1000;
   #minReconnectFreq = 0.5;
   #maxReconnectFreq = 120;
   #reconnectFreq = 0.5;
   #pingIntv = false;
   host;
   protocol;
   
   constructor() {
      const m = window.location.href.match(/^([a-zA-Z]+):\/\/([^/]+)/);
      if (m) {
	 this.protocol = m[1];
	 this.hostname = m[2];
      }
   }
   
   import(base) {
      // used for imported services
      return new Service(base);
   }

   addEventListener(event, proc, capture) {
      const hdl = {event, proc, capture};

      console.log("client.mjs: addEventListener", event);
      
      switch (event) {
	 case "ready":
	 case "open":
	 case "close":
	    this.addHandler(event,hdl);
	    break;
	 default: {
	    if (this.#ws) {
	       this.addHandler(event, hdl);
	    } else {
	       this.connect()
		  .then(_ => this.register(event))
		  .then(_ => this.trigger("open", true))
		  .then(_ => this.addHandler(event, hdl));
	    }
	 }
      }
   }

   addHandler(event, hdl) {
      console.log("client.mjs: addHandler", event);
      if (this.#handlers[event]) {
	 this.#handlers[event].push(hdl);
      } else {
	 this.#handlers[event] = [hdl] ;
      }
   }
   
   connect() {
      console.log("client.mjs: connect");
      this.#ws = "inconnect";
      return new Promise((res, rej) => {
	 new Frame(undefined, "/hop/server/event/init", [this.pingTime], [])
	    .post()
	    .then(val => {
	       if (this.#ws == "inconnect") {
		  const url = `${val.ssl ? "wss" : "ws"}://${val.host}/hop/server/event/ws?key=${val.key}`;
		  this.#key = val.key;
		  this.#host = val.host;
		  this.pingTime = val.pingTime;

		  this.#ws = new WebSocket(url);
		  console.log("client.mjs: creating websocket", this.#ws);
		  
		  this.#ws.addEventListener("open", e => {
		     console.log("client.mjs: onopen", e);
		     this.#pingIntv = setInterval(() => this.ping(), this.pingTime);
		     this.#reconnectFreq = this.#minReconnectFreq;
		     res(this.#ws);
		  });
		  this.#ws.addEventListener("close", e => {
		     console.log("client.mjs: onclose", e);
		     
		     this.close();
		     this.trigger("close", true);
		     this.reconnect("close");
		  });
		  this.#ws.addEventListener("message", e => {
		     console.log("client.mjs: onmessage", e);
		     this.rcvMessage(e);
		  })
	       } else {
		  if (this.#ws.readyState === 1) {
		     res(this.#ws);
		  } else {
		     this.#ws.addEventListener("open", e => res(this.#ws));
		  }
	       }
	    })
	    .catch(e => {
	       console.log("client.mjs: connect error", e);
	       rej(e);
	    })
      });
   }

   close() {
      if (this.#pingIntv) {
	 clearInterval(this.#pingIntv);
	 this.#pingIntv = false;
      }
      if (this.#ws && this.#ws.readyState !== 3) {
	 if (this.#ws.close) {
	    this.#ws.close();
	 }
      }
      this.#ws = false;
   }
   
   reconnect(msg) {
      this.close();
      setTimeout(() => {
	 this.connect()
	    .then(_ => {
	       for (event in this.#handlers) {
		  this.#ws.send(`${this.#key} register ${encodeURIComponent(event)}`);
	       };
	    })
	    .then(_ => this.trigger("open", false))
	    .catch(e => {
	       this.#reconnectFreq *= 2;
	       if (this.#reconnectFreq > this.#maxReconnectFreq) {
		  this.#reconnectFreq = this.#maxReconnectFreq;
	       }
	       setTimeout(() => this.reconnect("reconnect"), this.#reconnectFreq * 1000);
	    });
      }, this.#reconnectFreq * 1000);
   }

   register(event) {
      console.log("client.mjs: register", this.#ws.readyState);
      switch (this.#ws.readyState) {
	 case 0: {
	    // connecting
	    return new Promise((res, rej) => {
	       this.#ws.addEventListener("open", e => register(event));
	    });
	 }
	    
	 case 1: {
	    // open
	    this.#ws.send(`${this.#key} register ${encodeURIComponent(event)}`);
	    break;
	 }

	 default: {
	    return this.connect()
	       .then(_ => this.register(event));
	 }
      }
   }

   rcvMessage(msg) {
      console.log("client.mjs: rcvMessage", msg);

      if (msg !== "pong") {
	 const m = msg.data.match(/^([a-z]+) ([a-zA-Z0-9%_]+) (.*)$/m);
	 if (m) {
	    const val = decode(m[3], m[1]);
	    const event = decodeURIComponent(m[2]);
	    this.trigger(event, val);
	 }
      }
   }

   trigger(event, val) {
      const hdls = this.#handlers[event];
      console.log("client.mjs: trigger", event, val, hdls);
      if (hdls) {
	 const evt = new HopServerEvent(event, val);
	 for (let h of hdls) {
	    h.proc(evt);
	    if (evt.isStopped) break;
	 }
      }
   }
   
   ping() {
      console.log("client.mjs: ping", this.#ws.readyState);
      if (this.#ws.readyState === 1) {
	 this.#ws.send(this.#key + " ping");
      } else {
	 this.reconnect("ping");
      }
   }
}

/*---------------------------------------------------------------------*/
/*    HopServerEvent ...                                               */
/*---------------------------------------------------------------------*/
function HopServerEvent(n, v) {
   this.isStopped = false;
   this.preventDefault = function() { ; };
   this.stopPropagation = this.preventDefault;
   this.name = n;
   this.value = v;
   return this;
}

HopServerEvent.prototype = new Event("server");

/*---------------------------------------------------------------------*/
/*    server ...                                                       */
/*---------------------------------------------------------------------*/
const server = new Server();
globalThis.hop = { server };

/*---------------------------------------------------------------------*/
/*    HTMLTag ...                                                      */
/*---------------------------------------------------------------------*/
function HTMLTag(tag) {
   
   function toNode(n) {
      if (n instanceof Node) {
	 return n;
      } else if (typeof(n) === "string") {
	 return document.createTextNode(n);
      } else if (typeof(n) === "number") {
	 return document.createTextNode(n.toString());
      } else {
	 return document.createTextNode("wrong node: " + typeof n);
      }
   }
   
   // node children
   function addChild(el, n) {
      if (Array.isArray(n)) {
	 n.forEach(n => addChild(el, n));
      } else {
	 el.appendChild(toNode(n));
      }
   }

   return (attrs, ...nodes) => {
      const el = document.createElement(tag);

      // node attributes
      for (let k in attrs) {
	 if (k === "class") {
	    el.className = attrs.class;
	 } else {
	    const v = attrs[k];

	    if (v instanceof TILDE) {
	       const evt = k.replace(/^on/, "");
	       const hdl = eval(`(() => function (event) { ${v.nodes} })()`);

	       el.addEventListener(evt, hdl);
	    } else {
	       el.setAttribute(k, attrs[k]);
	    }
	 }
      }

      // node children
      nodes.forEach(n => addChild(el, n));

      return el;
   }
}

/*---------------------------------------------------------------------*/
/*    HTML tags ...                                                    */
/*---------------------------------------------------------------------*/
export const A = HTMLTag("A");
export const ABBR = HTMLTag("ABBR");
export const ACRONYM = HTMLTag("ACRONYM");
export const ADDRESS = HTMLTag("ADDRESS");
export const APPLET = HTMLTag("APPLET");
export const AREA = HTMLTag("AREA");
export const ARTICLE = HTMLTag("ARTICLE");
export const B = HTMLTag("B");
export const BASE = HTMLTag("BASE");
export const BASEFONT = HTMLTag("BASEFONT");
export const BDI = HTMLTag("BDI");
export const BDO = HTMLTag("BDO");
export const BIG = HTMLTag("BIG");
export const BLOCKQUOTE = HTMLTag("BLOCKQUOTE");
export const BODY = HTMLTag("BODY");
export const BR = HTMLTag("BR");
export const BUTTON = HTMLTag("BUTTON");
export const CANVAS = HTMLTag("CANVAS");
export const CAPTION = HTMLTag("CAPTION");
export const CENTER = HTMLTag("CENTER");
export const CITE = HTMLTag("CITE");
export const CODE = HTMLTag("CODE");
export const COL = HTMLTag("COL");
export const COLGROUP = HTMLTag("COLGROUP");
export const DATALIST = HTMLTag("DATALIST");
export const DD = HTMLTag("DD");
export const DEL = HTMLTag("DEL");
export const DETAILS = HTMLTag("DETAILS");
export const DFN = HTMLTag("DFN");
export const DIR = HTMLTag("DIR");
export const DIV = HTMLTag("DIV");
export const DL = HTMLTag("DL");
export const DT = HTMLTag("DT");
export const EM = HTMLTag("EM");
export const EMBED = HTMLTag("EMBED");
export const FIELDSET = HTMLTag("FIELDSET");
export const FIGURE = HTMLTag("FIGURE");
export const FIGCAPTION = HTMLTag("FIGCAPTION");
export const FONT = HTMLTag("FONT");
export const FOOTER = HTMLTag("FOOTER");
export const FORM = HTMLTag("FORM");
export const FRAME = HTMLTag("FRAME");
export const FRAMESET = HTMLTag("FRAMESET");
export const H1 = HTMLTag("H1");
export const H2 = HTMLTag("H2");
export const H3 = HTMLTag("H3");
export const H4 = HTMLTag("H4");
export const H5 = HTMLTag("H5");
export const H6 = HTMLTag("H6");
export const HEAD = HTMLTag("HEAD");
export const HEADER = HTMLTag("HEADER");
export const HGROUP = HTMLTag("HGROUP");
export const HR = HTMLTag("HR");
export const I = HTMLTag("I");
export const IFRAME = HTMLTag("IFRAME");
export const IMG = HTMLTag("IMG");
export const INPUT = HTMLTag("INPUT");
export const INS = HTMLTag("INS");
export const ISINDEX = HTMLTag("ISINDEX");
export const KBD = HTMLTag("KBD");
export const LABEL = HTMLTag("LABEL");
export const LEGEND = HTMLTag("LEGEND");
export const LI = HTMLTag("LI");
export const LINK = HTMLTag("LINK");
export const MAIN = HTMLTag("MAIN");
export const MAP = HTMLTag("MAP");
export const MARQUEE = HTMLTag("MARQUEE");
export const MENU = HTMLTag("MENU");
export const MENUITEM = HTMLTag("MENUITEM");
export const META = HTMLTag("META");
export const METER = HTMLTag("METER");
export const NAV = HTMLTag("NAV");
export const NOFRAMES = HTMLTag("NOFRAMES");
export const NOSCRIPT = HTMLTag("NOSCRIPT");
export const OBJECT = HTMLTag("OBJECT");
export const OL = HTMLTag("OL");
export const OPTGROUP = HTMLTag("OPTGROUP");
export const OPTION = HTMLTag("OPTION");
export const P = HTMLTag("P");
export const PARAM = HTMLTag("PARAM");
export const PRE = HTMLTag("PRE");
export const PROGRESS = HTMLTag("PROGRESS");
export const Q = HTMLTag("Q");
export const S = HTMLTag("S");
export const SAMP = HTMLTag("SAMP");
export const SCRIPT = HTMLTag("SCRIPT");
export const SECTION = HTMLTag("SECTION");
export const SELECT = HTMLTag("SELECT");
export const SMALL = HTMLTag("SMALL");
export const SOURCE = HTMLTag("SOURCE");
export const SPAN = HTMLTag("SPAN");
export const STRIKE = HTMLTag("STRIKE");
export const STRONG = HTMLTag("STRONG");
export const STYLE = HTMLTag("STYLE");
export const SUB = HTMLTag("SUB");
export const SUMMARY = HTMLTag("SUMMARY");
export const SUP = HTMLTag("SUP");
export const TABLE = HTMLTag("TABLE");
export const TBODY = HTMLTag("TBODY");
export const TD = HTMLTag("TD");
export const TEXTAREA = HTMLTag("TEXTAREA");
export const TFOOT = HTMLTag("TFOOT");
export const TH = HTMLTag("TH");
export const THEAD = HTMLTag("THEAD");
export const TIME = HTMLTag("TIME");
export const TITLE = HTMLTag("TITLE");
export const TR = HTMLTag("TR");
export const TRACK = HTMLTag("TRACK");
export const TT = HTMLTag("TT");
export const U = HTMLTag("U");
export const UL = HTMLTag("UL");
export const VAR = HTMLTag("VAR");

export function HTML(val) {
   /* not implemented */
   throw "client.mjs: HTML not implemented" + val;
}

export function TILDE(attrs, ...nodes) {
   if (!new.target) {
      return new TILDE(attrs, ...nodes);
   } else {
      this.nodes = nodes;
   }
}

export function DOLLAR(val) {
   /* not implemented */
   throw "client.mjs: DOLLAR not implemented" + val;
}
