// -*- Mode: typescript -*-
/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/config.mjs.in      */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Wed Jan 31 13:57:37 2024                          */
/*    Last change :  Fri May 16 10:32:57 2025 (serrano)                */
/*    Copyright   :  2024-25 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    Default configuration                                            */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    import                                                           */
/*---------------------------------------------------------------------*/
import { createRequire } from "node:module";
import { existsSync, readFileSync } from "node:fs";
import * as path from  "node:path";
import * as os from "node:os";

export { init };

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    defaultConfig ...                                                */
/*---------------------------------------------------------------------*/
const defaultConfig = {
   version: "@VERSION@",
   buildid: "@BUILDTAG@",
   motd: false,
   hostname: os.hostname(),
   engine: process.features?.hop ? "hop" : "node",
   ports: { http: 0, https: -1 },
   listenAddress: false,
   soMaxConn: 16,
   maxThread: 20,
   //server: { http: -1, https: -1 },
   configDirectory: path.join(process.env.HOME, ".config", "hop"),
   cacheDirectory: path.join(process.env.HOME, ".config", "hop", "cache"),
   usersdb: undefined,
   verbose: 1,
   debug: 0,
   charset: "utf8",
   security: {
      "realm": "hop",
      "serviceAuthentication": true,
      "staticRandomization": true
   },
   credentials: {
      "key": path.join(process.cwd(), "key.pem"),
      "cert": path.join(process.cwd(), "key.pem")
   }
}

/*---------------------------------------------------------------------*/
/*    expandShellEnvVar ...                                            */
/*---------------------------------------------------------------------*/
function expandShellEnvVar(v) {
   if (typeof v === "string") {
      const m = v.match(/[$]([_a-zA-Z][_a-zA-Z0-9]*)/g);

      if (m) {
	 m.forEach(s => v = v.replace(s, process.env[s.substring(1)] || ""));
      }

      if (v.match(/^(~)\//g)) {
	 v = process.env.HOME + v.substring(1);
      }
      
      return v;
   } else {
      return v;
   }
}

/*---------------------------------------------------------------------*/
/*    loadConfig ...                                                   */
/*    -------------------------------------------------------------    */
/*    The performance of this function is not critical.                */
/*---------------------------------------------------------------------*/
function loadConfig(config, file) {
   
   
   function warning(k, cfg) {
      console.error(`warning: ignoring unknown configuration property "${k}=${cfg[k]}"`);
   }

   if (existsSync(file)) {
      try {
	 const cfg = JSON.parse(readFileSync(file, "utf8"));

	 // don't use Object.assign because loadConfig is only
	 // allowed to set properties, not to create new ones
	 for (let k in cfg) {
	    switch (k) {
	       case "//":
	       case "__":
	       case "":
		  break;

	       case "include":
		  cfg.include.forEach(f => {
		     loadConfig(config, path.join(path.dirname(file), expandShellEnvVar(f)));
		  });
		  break;

	       case "security":
		  for (let k in cfg.security) {
		     if (k in config.security) {
			config.security[k] = expandShellEnvVar(cfg.security[k]);
		     } else {
			warning(k, cfg);
		     }
		  }
		  break;

	       case "ports":
		  for (let k in cfg.ports) {
		     if (k in config.ports) {
			config.ports[k] = expandShellEnvVar(cfg.ports[k]);
		     } else {
			warning(k, cfg);
		     }
		  }
		  break;

	       case "motd":
		  config.motd = cfg.motd;
		  break;

	       case "usersdb":
		  config.usersdb = cfg.usersdb;
		  break;

	       default:
		  if (k in config) {
		     config[k] = expandShellEnvVar(cfg[k]);
		  } else {
		     warning(k, cfg);
		  }
	    }
	 }
      } catch (e) {
	 throw e;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    loadConfigDir ...                                                */
/*---------------------------------------------------------------------*/
function loadConfigDir(config, dir) {
   const port = config.ports.http;
   const engine = config.engine;

   // base config file
   loadConfig(config, path.join(dir, "config.json"));

   // engine-base config file
   loadConfig(config, path.join(dir, `config.${engine}.json`));

   // per-engine config file 
   loadConfig(config, path.join(dir, `config.${port}.json`));
}

/*---------------------------------------------------------------------*/
/*    loadUsersDB ...                                                  */
/*---------------------------------------------------------------------*/
function loadUsersDB(config, descr) {
   if (descr.match(/\.json$/)) {
      config.users = JSON.parse(readFileSync(expandShellEnvVar(descr), "utf8"));
   } else if (descr.match(/^data:text\/json,/)) {
      config.users = JSON.parse(descr.substring("data:text/json,".length));
   }
}

/*---------------------------------------------------------------------*/
/*    resolveDirectories ...                                           */
/*---------------------------------------------------------------------*/
function resolveDirectories(directories) {
   if (directories === "*") {
      return "*";
   } else if (Array.isArray(directories)) {
      return directories.map(dir => require.resolve(dir));
   } else {
      return [];
   }
}

/*---------------------------------------------------------------------*/
/*    init ...                                                         */
/*---------------------------------------------------------------------*/
function init(cfg) {
   const config = {};
   
   // default configuration
   Object.assign(config, defaultConfig);
   Object.assign(config, cfg);
   
   // config file
   if (config.configDirectory) {
      loadConfigDir(config, config.configDirectory);
      loadConfigDir(config, path.join(config.configDirectory, config.hostname));
   }

   // reassign the user configuration
   Object.assign(config, cfg);
   
   // users
   if (config.users) {
      // deep copy of the users db if pre-configured
      config.users = config.users.map(u => Object.assign({}, u))
   } else {
      if (config.usersdb) {
	 loadUsersDB(config, config.usersdb);
      } else if (config.configDirectory) {
	 // load default users
	 const file = (config.configDirectory + "/users.json");
	 if (existsSync(file)) {
	    loadUsersDB(config, file);
	 } else {
	    config.users = [];
	 }
      } else {
	 config.users = [];
      }
   }
   if (config.users.length === 0 && config.verbose >= 1) {
      console.error("warning, no users registered!");
   }
   
   // freeze the configuration
   Object.freeze(config.ports);
   Object.freeze(config.security);
   Object.freeze(config.users);
   config.users.forEach(u => {
      Object.freeze(u.services);
      Object.freeze(resolveDirectories(u.directories));
      Object.freeze(u)
   });
   
   Object.freeze(config);
   
   return config;
}
