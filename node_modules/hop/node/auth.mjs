/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/auth.mjs      */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Mon Feb  5 18:06:12 2024                          */
/*    Last change :  Wed Aug 28 08:52:46 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    authentication and users                                         */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { existsSync, readFileSync } from "node:fs";
import * as path from  "node:path";
import { createHash } from "node:crypto";

export { UserAuth, digestPasswordEncrypt, WWWAuthenticate };

/*---------------------------------------------------------------------*/
/*    digestPasswordEncrypt ...                                        */
/*---------------------------------------------------------------------*/
function digestPasswordEncrypt(name, pass, realm) {
   const str = `${name}:${realm}:${pass}`;
   return createHash("md5").update(str).digest("hex").toString();
}

/*---------------------------------------------------------------------*/
/*    digestPrivateKey ...                                             */
/*---------------------------------------------------------------------*/
const digestSession = Date.now() >> 2;
const digestPrivateKey = (Math.random() * 10000000 | Date.now()) + "";
let digestOpaque = false;

/*---------------------------------------------------------------------*/
/*    getDigestOpaque ...                                              */
/*---------------------------------------------------------------------*/
function getDigestOpaque(hostname, port) {
   if (!digestOpaque) {
      digestOpaque = `${hostname}:${port}:${digestSession}`;
   }
   return digestOpaque;
}

/*---------------------------------------------------------------------*/
/*    WWWAuthenticate ...                                              */
/*---------------------------------------------------------------------*/
function WWWAuthenticate(realm, hostname, port) {
   const nonce = Buffer.from(Date.now() + digestPrivateKey).toString('base64');
   const auth = `Digest realm="${realm}", qop="auth", nonce="${nonce}", opaque="${getDigestOpaque(hostname, port)}"`;
   return { "WWW-Authenticate": auth, "hop-session": digestSession }
}

/*---------------------------------------------------------------------*/
/*    parseDigest ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function parses strings such as:                            */
/*      'Digest username="foo", realm="hop", nonce="MTc" ...'          */
/*---------------------------------------------------------------------*/
function parseDigest(s) {
   const rxName = /([a-zA-Z]+)=/y;
   const rxString = /"([^"]*)"/y;
   const rxValue = /[^", ][^, ]*/y;
   const rxSep = /,?[ ]+/y;
   const obj = {};
   let n;
   let v;
   
   rxName.lastIndex = 7;   
   while (n = s.match(rxName)) {
      rxString.lastIndex = rxName.lastIndex;
      if (v = s.match(rxString)) {
	 obj[n[1]] = v[1];
	 rxSep.lastIndex = rxString.lastIndex;
      } else {
	 rxValue.lastIndex = rxName.lastIndex;
	 if (v = s.match(rxValue)) {
	    obj[n[1]] = v[0];
	    rxSep.lastIndex = rxValue.lastIndex;
	 } else {
	    return false;
	 }
      }
      if (!s.match(rxSep)) {
	 return obj;
      } else {
	 rxName.lastIndex = rxSep.lastIndex;
      }
   }

   return obj;
}

/*---------------------------------------------------------------------*/
/*    authenticationDigest ...                                         */
/*---------------------------------------------------------------------*/
function authenticationDigest(hop, req, digest, user) {

   function H(str) {
      return createHash("md5").update(str).digest("hex").toString();
   }

   function KD(secret, data) {
      return H(secret + ":" + data);
   }
   
   function responseDigest(A1, digest) {
      const { nc, nonce, qop, uri } = digest;

      if (typeof nonce === "string"
	 && typeof nc === "string"
	 && typeof uri === "string") {
	 // Hop does not support auth-int so A2 is only defined as follows
	 const A2 = req.method + ":" + uri;

	 if (qop === "auth") {
	    const cnonce = digest.cnonce;
	    
	    if (typeof cnonce === "string") {
	       return KD(A1, `${nonce}:${nc}:${cnonce}:${qop}:${H(A2)}`);
	    } else {
	       if (hop.config.verbose >= 2) {
		  console.log(`Cannot authentify user "${digest.name}"`);
	       }
	       return false;
	    }
	 } else {
	    return KD(H(A1, `${nonce}:${H(A2)}`));
	 }
      } else {
	 if (hop.config.verbose >= 2) {
	    console.log(`Cannot authentify user "${digest.name}"`);
	 }
	 return false;
      }
   }
      
   if (digest.opaque === getDigestOpaque(hop.config.hostname, req.port)
      && digest.realm === hop.config.security.realm) {
      const rep = responseDigest(user.password, digest);

      if (rep === digest.response) {
	 return true;
      } else {
	 if (hop.config.verbose >= 2) {
	    console.log(`Cannot authentify user "${digest.name}"`);
	 }
	 return false;
      }
   }
   return false;
}

/*---------------------------------------------------------------------*/
/*    UserAuth ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class UserAuth {
   #hop;
   #serviceAuthentication = true;
   #usersMap = new Map();
   #userAnonymous = { name: "anonymous", services: [], directories: [], events: [] };
   
   constructor(hop) {
      this.#serviceAuthentication = hop.config.security.serviceAuthentication;
      this.#hop = hop;
      if (hop.config.users) {
	 hop.config.users.forEach(u => {
	    if (this.checkUser(u)) {

	       this.#usersMap.set(u.name, u);
	       if (u.name === "anonymous") {
		  Object.assign(this.#userAnonymous, u);
	       }	       
	    }
	 });
      } else {
	 if (hop.config.verbose >= 1) {
	    console.error("warning, no users registered!");
	 }
      }
   }
   
   checkUser(u) {  
      function starOrStringArray(v) {
	 return (v === "*" || (Array.isArray(v) && v.every(s => typeof s === "string")));
      }
      for (let k in u) {
	 switch (k) {
	    case "name":
	       if (typeof u[k] !== "string") {
		  console.error(`warning: wrong user ${k} "${u.name}"`);
		  return false;
	       } else if (this.#usersMap.has(u.name)) {
		  console.error(`warning: user redefinition "${u.name}"`);
		  return false;
	       }
	       break;
	       
	    case "password":
	       if (typeof u[k] !== "string") {
		  console.error(`warning: wrong user ${k} "${u.name}"`);
		  return false;
	       }
	       break;
	       
	    case "services":
	    case "directories":
	    case "events":
	       if (!starOrStringArray(u[k])) {
		  console.error(`warning: user "${u.name}", wrong ${k} "${u[k]}"`);
		  return false;
	       }
	       break;

	    default:
	       console.error(`warning: user "${u.name}", unknown user propperty "${k}"`);
	       return false;
	 }
      }
      return true;
   }

   #getUser(req) {
      const auth = req.get("authorization");

      if (auth) {
	 let match;
	 
	 if (match = auth.match(/^Digest /)) {
	    const digest = parseDigest(auth);
	    const u = this.#usersMap.get(digest.username);
	    if (authenticationDigest(this.#hop, req, digest, u)) {
	       return u;
	    }
	 } else if (match = auth.match(/^Basic ([^ :\t\r\n]*)/)) {
	    if (this.#hop.config.verbose >= 2) {
	       console.log(`Wrong "basic" authentication "${match[1]}"`);
	    }
	 } else {
	    if (this.#hop.config.verbose >= 2) {
	       console.log(`Unknown authentication method "${match[1]}"`);
	    }
	 }
      }

      return this.#userAnonymous;
   }
      
      
   #authorizedRequest(req, url, prop) {
      // Is service at URL authorized for this request?
      if (!this.#serviceAuthentication) {
	 return true;
      } else {
	 const user = this.#getUser(req);
	 const val = user[prop];
	 
	 if (val === "*") {
	    return true;
	 } else if (!val) {
	    return false;
	 } else if (val.indexOf(url) >= 0) {
	    return true;
	 } else {
	    return val.find(s => {
	       if (url[s.length] === "/") {
		  return s === url.substring(0, s.length);
	       }
	    });
	 }
      }
      
      return false;
   }
   
   
   authorizedService(req, url) {
      return this.#authorizedRequest(req, url, "services");
   }
   
   authorizedPath(req, url) {
      return this.#authorizedRequest(req, url, "directories");
   }
   
   authorizedEvent(req, url) {
      return this.#authorizedRequest(req, url, "events");
   }
}

