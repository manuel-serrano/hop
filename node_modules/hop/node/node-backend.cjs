/*=====================================================================*/
/*    .../project/hop/hop/node_modules/hop/node/node-backend.js        */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Tue Feb 27 12:04:16 2024                          */
/*    Last change :  Thu May 16 16:26:30 2024 (serrano)                */
/*    Copyright   :  2024 Manuel Serrano                               */
/*    -------------------------------------------------------------    */
/*    Nodejs Hop backend (lives in the CommonJS land).                 */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
const http = require("node:http");
const https = require("node:https");
const parseQueryString = require('node:querystring').parse;
const extname = require("node:path").extname;
const { existsSync, statSync, readFileSync, createReadStream } = require("node:fs");
const ws = require("ws");
const mime = require("mime-types");

/*---------------------------------------------------------------------*/
/*    app ...                                                          */
/*---------------------------------------------------------------------*/
/* @sealed */
class app {
   #hop;
   #registerWebsocket;
   #handlerTable = new Map();
   #statics = [];
   
   constructor(hop, registerWebsocket) {
      this.#hop = hop;
      this.#registerWebsocket = registerWebsocket;

      this.#handlerTable.add = (url, handler, method) => {
	 const old = this.#handlerTable.get(url);
	 if (old) {
	    old[method] = handler;
	 } else {
	    const h = {
	       GET: method === "GET" && handler,
	       PUT: method === "PUT" && handler,
	       POST: method === "POST" && handler
	    }
	    this.#handlerTable.set(url, h);
	 }
      }
   }
   
   listen() {
      
      const listenCallback = (res, rej) => {
	 if (this.#hop.ports.http !== 0 && this.#hop.ports.https !== 0) {
	    Object.freeze(this.#hop.ports);
	    if (this.#hop.ports.http !== -1 || this.#hop.ports.https !== -1) {
	       res(this.#hop);
	    } else {
	       rej(new Error("Hop: need either an http or https port number"));
	    }
	 }
      }

      const getHeader = function(k) {
	 return this.headers[k];
      }

      const setStatus = function(code) {
	 this.statusCode = code;
      }

      const sendFile = function(filename) {
	 this.setHeader("Content-Type", mime.lookup(extname(filename)))
	 const s = createReadStream(filename);
	 s.pipe(this);
      }

      const handler = (req, res) => {
	 const i = req.url.indexOf("?");
	 const url = (i < 0) ? req.url : req.url.substring(0, i);
	 const hdls = this.#handlerTable.get(url);

	 if (!hdls) {
	    const s = this.#statics.find(s => req.url.startsWith(s.path));

	    if (s) {
	       const file = s.root + url.substring(s.path.length - 1);

	       if (existsSync(file)) {
		  res.status = 200;
		  sendFile.call(res, file);
		  return;
	       }
	    }
	    res.status = 404;
	    res.end("File not found!");
	    return;
	 } else {
	    const hdl = hdls[req.method];

	    if (!hdl) {
	       throw new Error(`no ${req.method} handler for URL "${req.url}"`);
	    } else {
	       const query = i < 0 ? {} : parseQueryString(req.url.substring(i + 1));
	       // expression API compatibility
	       req.query = query;
	       req.get = getHeader;
	       res.set = res.setHeader;
	       res.append = res.setHeader;
	       res.send = res.end;
	       res.sendFile = sendFile;
	       res.status = setStatus;
	       
	       hdl(req, res);
	       return;
	    }
	 }
      }
      
      return new Promise((res, rej) => {
	 let bcastServer = null;
	 
	 if (this.#hop.config.ports.http >= 0) {
	    let httpServer = bcastServer = http.createServer(handler)
	       .listen(this.#hop.config.ports.http, e => {
		  if (e) rej(e);
		  this.#hop.ports.http = httpServer.address().port;
		  listenCallback(res, rej);
	       });
	 } else {
	    this.#hop.ports.http = -1;
	 }
	 if (this.#hop.config.ports.https >= 0) {
	    const credentials = {};
	    for (let k in config.credentials) {
	       credentials[k] = readFileSync(config.credentials[k]);
	    }
	    let httpsServer = bcastServer = https.createServer(credentials, handler)
	       .listen(this.#hop.config.ports.https, e => {
		  if (e) rej(e);
		  this.#hop.ports.https = e ? -1 : httpsServer.address().port;
		  listenCallback(res, rej);
	       });
	 } else {
	    this.#hop.ports.https = -1;
	    listenCallback(res, rej);
	 }

	 // websocket for event broadcast
	 const wsServer = new ws.Server({ noServer: true });
	 bcastServer.on('upgrade', (req, socket, head) => {
	    const i = req.rawHeaders.findIndex(n => n.toLowerCase() === "host");
	    if (i < 0) {
	       throw "Cannot register websocket, because cannot find host";
	    } else {
	       const host = req.rawHeaders[i + 1];
	       wsServer.handleUpgrade(req, socket, head, socket => {
		  this.#registerWebsocket(host, socket);
	       });
	    }
	 });
      });
   }

   static(id, root) {
      const path = `/hop/${id}/`;
      const s = { root, path }
      this.#statics.push(s);
   }
   
   get(url, fun) { this.#handlerTable.add(url, fun, "GET"); }
   put(url, fun) { this.#handlerTable.add(url, fun, "PUT"); }
   post(url, fun) { this.#handlerTable.add(url, fun, "POST"); }
}
   
/*---------------------------------------------------------------------*/
/*    init ...                                                         */
/*---------------------------------------------------------------------*/
function init(hop, registerWebsocket) {
   return new app(hop, registerWebsocket);
}

/*---------------------------------------------------------------------*/
/*    exports                                                          */
/*---------------------------------------------------------------------*/
module.exports = { init };
