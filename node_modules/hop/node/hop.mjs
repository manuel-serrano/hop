/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/hop.mjs       */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Wed Jan  1 17:47:44 2025 (serrano)                */
/*    Copyright   :  2023-25 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as http from "node:http";
import * as https from "node:https";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import { UserAuth, WWWAuthenticate, digestPasswordEncrypt } from "./auth.mjs";
import { ServerEvent } from "./event.mjs";
import { init as configInit } from "./config.mjs";
import { format } from "node:util";

export * from "./html.mjs";
export { Hop,
	 Response, HTTPResponseFile, HTTPResponseString,
	 HTTPResponseAuthentication, HTTPResponseHTML };

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
// @sealed
class Hop {
   #broadcast;
   #hop;
   #serverEvent;

   auth;
   ports = { http: 0, https: 0 };
   config;
   backend;
   base = "/hop";
   
   static cnt = 0;
   
   constructor(config) {
      this.config = configInit(config);

      // serve event initialization
      const se = this.#serverEvent = new ServerEvent(this, hopResponse);
      
      // backend initialization
      let mod;
      switch (this.config.engine) {
	 case "hop": mod = "./hop-backend.hop"; break;
	 case "express": mod = "./express-backend.cjs"; break;
	 case "node": mod = "./node-backend.cjs"; break;
	 default: throw new TypeError(`Illlegal engine "${this.config.engine}"`);
      }
      this.backend = require(mod).init(this, se.registerWebsocket.bind(se));

      // user authentication initialization
      this.auth = new UserAuth(this);

      // server-event registration service
      new ServiceImpl(this, function (pt) { return se.init(this, pt) }, "server/event/init");
      
   }

   listen() {
      return this.backend.listen();
   }

   schema() {
      if (this.ports.https > 0) {
	 return `https://${this.config.hostname}:${this.ports.https}`;
      } else {
	 return `http://${this.config.hostname}:${this.ports.http}`;
      }
   }
   
   Resolver(root = undefined) {
      if (!root) {
	 root = dirname(dirname(import.meta.url));
      }
      return new Resolver(this, root);
   }
   
   Service(fun, optOrUrl) {
      if (this instanceof Hop) {
	 const impl = new ServiceImpl(this, fun, optOrUrl || ("/" + fun.name));
	 const f = (...args) => new Frame(impl, args);
	 f.dollar = () => impl.dollar();
	 return f;
      } else {
	 throw new TypeError(`${impl.path()}, illegal "this" -- ${this}`);
      }
   }

   broadcast(evt, val) {
      return this.#serverEvent.broadcast(evt, val)
   }

   passwordEncrypt(name, pass, realm = "hop") {
      return digestPasswordEncrypt(name, pass, realm);
   }
}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
// @sealed
class Resolver {
   #hop;
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   static getRootDir(url) {
      if (!url) {
	 return process.cwd();
      } else {
	 const urlpath = url instanceof URL
	    ? fileURLToPath(url)
	    : url.replace(/^file:\/\//, "");
	 const normpath = normalize(urlpath);
	 
	 if (!existsSync(urlpath)) {
	    throw new Error(`resolver path does not exist ${url}`);
	 } else {
	    if (statSync(urlpath).isDirectory()) {
	       return normpath;
	    } else {
	       return dirname(normpath);
	    }
	 }
      }
   }

   constructor(hop, root) {
      this.#hop = hop;
      this.#root = Resolver.getRootDir(root);
      this.#num = Resolver.num++;

      hop.backend.static(this.#num, this.#root);
   }

   url(file) {
      const relfile = isAbsolute(file) ? relative(this.#root, file) : file;
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (old) {
	 return old.url;
      } else if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`file not in resolver root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`file does not exist in resolver directory "${this.#root}/${relfile}"`);
      } else {
	 const url = `${this.#hop.base}/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   path(url) {
      return this.#pathTable.get(url);
   }
}

/*---------------------------------------------------------------------*/
/*    getFile ...                                                      */
/*    -------------------------------------------------------------    */
/*    Deliver static files                                             */
/*---------------------------------------------------------------------*/
function getFile(req, res) {
   const filename = this.path(req.url);

   if (!filename) {
      console.error(`file "${req.url}" not found.`);
      res,status(404);
      res.send("File not found!");
   } else if (this.auth.authorizedPath(req, filename)) {
      res.status(200);
      res.sendFile(filename);
   } else {
      req.hop = this;
      return hopResponse(req, res, HTTPResponseAuthentication());
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(hop, file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hop.base + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    ServiceImpl ...                                                  */
/*---------------------------------------------------------------------*/
// @sealed
class ServiceImpl {
   #hop;
   #fun;
   #path;
   #key = Math.round(Math.random() * 100000);

   static #cnt = Date.now();
   
   constructor(hop, fun, optOrUrl) {
      this.#hop = hop;
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#path = serviceUrl(this.#hop, optOrUrl);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 }
      } else {
	 this.#path = serviceUrl(hop.#hop, "svc" + ServiceImpl.#cnt++);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      }
   }

   dollar() {
      return `hop.server.import('${this.#path}')`;
   }

   path(args) {
      if (args.length === 0) {
	 return this.#path;
      } else {
	 let json = JSON.stringify(args);
	 return this.#path + "?hop-serialize=json-url&hop-arguments="
	    + encodeURIComponent(json);
      }
   }

   schema() {
      return this.#hop.schema();
   }
   
   static postResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = undefined;
	 let jsargs = req.get("hopjs-arguments");

	 if (jsargs && jsargs.startsWith("hop-encoding=hopjs&vals=")) {
	    rep = this.#fun.apply(req, decode(req, jsargs.substring(24)));
	 } else {
	    switch (req.get("hop-serialize")) {
	       case "json": {
		  const args = req.get("hop-arguments");
		  rep = this.#fun.apply(req, JSON.parse(args));
		  break;
	       }
	       default:
		  rep = this.#fun.call(req, req.query);
	    }
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep;

	 if (req.query["hop-encoding"] === "hopjs") {
	    // Cannot use req.query.vals because it's already URI decoded.
	    // Use plain URL instead
	    const args = req.url.replace(/.*\?hop-encoding=hopjs&vals=/, "");
	    rep = this.#fun.apply(req, decode(req, args));
	 } else if (req.query["hop-serialize"] === "json-url") {
	    const args = decodeURIComponent(req.query["hop-arguments"]);
	    rep = this.#fun.apply(req, JSON.parse(args));
	 } else {
	    rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    decode ...                                                       */
/*---------------------------------------------------------------------*/
function decode(req, query) {
   
   const lenrx = /([0-9]+)[.]/y;
   
   function err(req) {
      throw new SyntaxError(`${req?.path}: Invalid query -- ${query}`);
   }

   function decodeArg(req, query, arr, c, j, len) {
      const s = query.substring(j, j + len);

      switch (c) {
	 case "I":
	    return parseInt(s);
	 case "N":
	    return parseFloat(s);
	 case "S":
	    return s;
	 case "s":
	    return decodeURIComponent(s);
	 case "D":
	    return new Date(parseInt(s));
	 case "J":
	    return JSON.parse(s);
	 case "j":
	    return JSON.parse(decodeURIComponent(s));
	 default:
	    err(req);
      }
   }

   function decodeArgs(req, query, arr, len, i) {
      for (let n = 0; n < len; n++) {
	 const c = query[i];

	 switch (c) {
	    case "U":
	       i++;
	       arr[n] = undefined;
	       break;
	    case "Z":
	       i++;
	       arr[n] = null;
	       break;
	    case "T":
	       i++;
	       arr[n] = true;
	       break;
	    case "F":
	       i++;
	       arr[n] = false;
	       break;
	    default: {
	       lenrx.lastIndex = i + 1;
	       const m = query.match(lenrx);

	       if (!m) {
		  err(req);
	       } else {
		  const l = parseInt(m[1]);
		  i = m.index + m[0].length;
		  arr[n] = decodeArg(req, query, arr, c, i, l);
		  i += l;
	       }
	    }
	 }
      }

      return arr;
   }

   const m = query.match(lenrx);

   if (m) {
      const len = parseInt(m[1]);
      return decodeArgs(req, query, new Array(len), len, lenrx.lastIndex);
   } else {
      err(req);
   }
}

/*---------------------------------------------------------------------*/
/*    decode tests                                                     */
/*---------------------------------------------------------------------*/
/* import assert from "node:assert";                                   */
/* function test(x, res) {                                             */
/*    const d = decode(undefined, "hop-encoding=hopjs&vals=" + x);     */
/*    assert.deepEqual(d, res, `${x} -> ${d} / ${res}`);               */
/* }                                                                   */
/*                                                                     */
/* test("1.U", [undefined]);                                           */
/* test("1.Z", [null]);                                                */
/* test("1.T", [true]);                                                */
/* test("1.F", [false]);                                               */
/* test("4.UZTF", [undefined, null, true, false]);                     */
/* test("1.I1.5", [5]);                                                */
/* test("1.N1.5", [5]);                                                */
/* test("3.N1.0I2.10N3.3.1", [0, 10, 3.1]);                            */
/* test("1.S3.foo", ["foo"]);                                          */
/* test("2.S3.foos3.bar", ["foo", "bar"]);                             */
/* test("1.s5.fo%6F", ["foo"]);                                        */
/* test("1.D13.949359600000", [new Date(2000,1)]);                     */
/* test("1.j27.%7B%22x%22:10,%22y%22:20%7D", [{x:10,y:20}]);           */
/* test("2.j27.%7B%22x%22:10,%22y%22:20%7DI4.1970", [{x:10,y:20}, 1970]); */

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
// @sealed
class Frame {
   #svc;
   #args;
   
   constructor(svc,args) {
      this.#svc = svc;
      this.#args = args;
   }

   dollar() {
      return "'" + this.toString() + "'";
   }
   
   toString() {
      return `${this.#svc.schema()}${this.#svc.path(this.#args)}`;
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function is used to encode value returned by services       */
/*    and by event broadcast (see event.mjs).                          */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   if (val instanceof Response) {
      return val.hopResponse(req, res);
   } else if (val instanceof Promise) {
      return val.then(val => hopResponse(req, res, val));
   } else {
      // keep-alive
      const conn = req.get("connection");
      if (conn) {
	 res.set("Connection", conn);
      }

      if (typeof(val) === "number") {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("hop-serialize", "number");
	 res.send(str);
      } else if (val === undefined) {
	 res.append("Content-Length", "0");
	 res.append("hop-serialize", "undefined");
	 res.send("");
      } else if (val === null) {
	 res.append("Content-Length", "0")
	 res.append("hop-serialize", "null");
	 res.send("");
      } else if (val === true) {
	 res.append("Content-Length", "0")
	 res.append("hop-serialize", "true");
	 res.send("");
      } else if (val === false) {
	 res.append("Content-Length", "0");
	 res.append("hop-serialize", "false");
	 res.send("");
      } else if (typeof(val) === "string") {
	 res.append("Content-Length", val.length);
	 res.append("hop-serialize", "string");
	 res.send(val);
      } else if (val instanceof Buffer) {
	 res.append("hop-serialize", "buffer");
	 res.send(val);
      } else if (val instanceof Date) {
	 res.append("hop-serialize", "date");
	 res.send(val.getTime().toString());
      } else if (!(val instanceof Object)) {
	 // native objects will follow that path
	 return val;
      } else if ("toResponse" in val) {
	 const { string, serialize } = val.toResponse();
	 res.append("Content-Length", string.length);
	 res.append("hop-serialize", serialize);
	 res.send(string);
      } else if (!req.get("hop-serialize") || req.get("hop-serialize") === "json") {
	 const str = JSON.stringify(val);
	 res.append("Content-Length", str.length);
	 res.append("hop-serialize", "json");
	 res.send(str);
      } else {
	 throw new Error("hop.mjs: serialization not implemented " +
	    reg.get("hop-serialize"));
      }
      return res;
   }
}
   
/*---------------------------------------------------------------------*/
/*    Response                                                         */
/*---------------------------------------------------------------------*/
// @sealed
class Response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw `Response not implemented (${this.constructor.name})`;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseString ...                                               */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseString extends Response {
   hopResponse(req, res) {
      // status
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseFile ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseFile extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(path, opt = undefined) {
   const headers = opt || {
      "Content-Disposition": `inline; filename="${basename(path)}"`,
      "connection": "keep-alive"
   };
   return new ResponseFile(path, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(str, opt) {
   const headers = opt || { "connection": "keep-alive" };
   return new ResponseString(str, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    ResponseAuthentication ...                                       */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseAuthentication extends ResponseString {
   hopResponse(req, res) {
      // authentication
      const headers = WWWAuthenticate(
	 req.hop.config.real, req.hop.config.hostname, req.port);
      for (let k in headers) {
	 res.append(k, headers[k]);
      }
      return super.hopResponse(req, res);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(opt = undefined) {
   return new ResponseAuthentication("Unauthorized", 401);
}

/*---------------------------------------------------------------------*/
/*    ResponseHTML ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseHTML extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      hopResponse(req, res, this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseHTML ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseHTML(html, opt = undefined) {
   return new ResponseHTML(html, 200);
}
