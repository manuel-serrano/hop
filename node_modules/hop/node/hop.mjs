/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hop/node/hop.mjs       */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Tue Oct 24 09:50:25 2023                          */
/*    Last change :  Fri May 24 10:04:07 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    ESM module                                                       */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { createRequire } from 'node:module';
import { basename, dirname, normalize, relative, join, isAbsolute } from "node:path";
import { existsSync, statSync, readFileSync } from "node:fs";
import * as http from "node:http";
import * as https from "node:https";
import { URL, pathToFileURL, fileURLToPath } from 'node:url';
import { cwd } from "node:process";
import { UserAuth, WWWAuthenticate } from "./auth.mjs";
import { ServerEvent } from "./event.mjs";
import { init as configInit } from "./config.mjs";
import { format } from "node:util";

export * from "./html.mjs";
export { Hop,
	 Response, HTTPResponseFile, HTTPResponseString,
	 HTTPResponseAuthentication, HTTPResponseHTML };

/*---------------------------------------------------------------------*/
/*    Dynamique require                                                */
/*---------------------------------------------------------------------*/
const require = createRequire(import.meta.url);

/*---------------------------------------------------------------------*/
/*    Hop ...                                                          */
/*---------------------------------------------------------------------*/
// @sealed
class Hop {
   #broadcast;
   #hop;
   #serverEvent;

   auth;
   ports = { http: 0, https: 0 };
   config;
   backend;
   base = "/hop";
   
   static cnt = 0;
   
   constructor(config) {
      this.config = configInit(config);

      // serve event initialization
      const se = this.#serverEvent = new ServerEvent(this, hopResponse);
      
      // backend initialization
      let mod;
      switch (this.config.engine) {
	 case "hop": mod = "./hop-backend.hop"; break;
	 case "express": mod = "./express-backend.js"; break;
	 case "node": mod = "./node-backend.js"; break;
	 default: throw new TypeError(`Illlegal engine "${this.config.engine}"`);
      }
      this.backend = require(mod).init(this, se.registerWebsocket.bind(se));

      // user authentication initialization
      this.auth = new UserAuth(this);

      // server-event registration service
      new ServiceImpl(this, function (pt) { return se.init(this, pt) }, "server/event/init");
      
   }

   listen() {
      return this.backend.listen();
   }

   schema() {
      if (this.ports.https > 0) {
	 return `https://${this.config.hostname}:${this.ports.https}`;
      } else {
	 return `http://${this.config.hostname}:${this.ports.http}`;
      }
   }
   
   Resolver(root = undefined) {
      if (!root) {
	 root = dirname(require.resolve("@hop/hop/client.mjs"));
      }
      return new Resolver(this, root);
   }
   
   Service(fun, optOrUrl) {
      if (this instanceof Hop) {
	 const impl = new ServiceImpl(this, fun, optOrUrl);
	 const f = (...args) => new Frame(impl, args);
	 f.dollar = () => impl.dollar();
	 return f;
      } else {
	 throw new TypeError(`${impl.path()}, illegal "this" -- ${this}`);
      }
   }

   broadcast(evt, val) {
      return this.#serverEvent.broadcast(evt, val)
   }

}

/*---------------------------------------------------------------------*/
/*    Resolver ...                                                     */
/*---------------------------------------------------------------------*/
// @sealed
class Resolver {
   #hop;
   #root;
   #hooks = []
   #resolveTable = new Map();
   #pathTable = new Map();
   #num;

   static num = 1;

   static getRootDir(url) {
      if (!url) {
	 return process.cwd();
      } else {
	 const urlpath = url instanceof URL
	    ? fileURLToPath(url)
	    : url.replace(/^file:\/\//, "");
	 const normpath = normalize(urlpath);
	 
	 if (!existsSync(urlpath)) {
	    throw new Error(`resolver path does not exist ${url}`);
	 } else {
	    if (statSync(urlpath).isDirectory()) {
	       return normpath;
	    } else {
	       return dirname(normpath);
	    }
	 }
      }
   }

   constructor(hop, root) {
      this.#hop = hop;
      this.#root = Resolver.getRootDir(root);
      this.#num = Resolver.num++;

      hop.backend.static(this.#num, this.#root);
   }

   url(file) {
      const relfile = isAbsolute(file) ? relative(this.#root, file) : file;
      const filename = normalize(join(this.#root, relfile));
      const old = this.#resolveTable.get(filename);

      if (old) {
	 return old.url;
      } else if (filename.substring(0, this.#root.length) !== this.#root) {
	 throw new Error(`file not in resolver root directory ${relfile}`);
      } else if (!existsSync(filename)) {
	 throw new Error(`file does not exist in resolver directory "${this.#root}/${relfile}"`);
      } else {
	 const url = `${this.#hop.base}/${this.#num}/${relfile}`;

	 this.#resolveTable.set(filename, { url });
	 this.#pathTable.set(url, filename);
	 return url;
      }
   }
   
   path(url) {
      return this.#pathTable.get(url);
   }
}

/*---------------------------------------------------------------------*/
/*    getFile ...                                                      */
/*    -------------------------------------------------------------    */
/*    Deliver static files                                             */
/*---------------------------------------------------------------------*/
function getFile(req, res) {
   const filename = this.path(req.url);

   if (!filename) {
      console.error(`file "${req.url}" not found.`);
      res,status(404);
      res.send("File not found!");
   } else if (this.auth.authorizedPath(req, filename)) {
      res.status(200);
      res.sendFile(filename);
   } else {
      req.hop = this;
      return hopResponse(req, res, HTTPResponseAuthentication());
   }
}

/*---------------------------------------------------------------------*/
/*    serviceUrl ...                                                   */
/*---------------------------------------------------------------------*/
function serviceUrl(hop, file) {
   if (file[0] === "/") {
      return file;
   } else {
      return hop.base + "/" + file;
   }
}

/*---------------------------------------------------------------------*/
/*    ServiceImpl ...                                                  */
/*---------------------------------------------------------------------*/
// @sealed
class ServiceImpl {
   #hop;
   #fun;
   #path;
   #key = Math.round(Math.random() * 100000);

   static #cnt = Date.now();
   
   constructor(hop, fun, optOrUrl) {
      this.#hop = hop;
      this.#fun = fun;
      if (typeof optOrUrl === "string") {
	 this.#path = serviceUrl(this.#hop, optOrUrl);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      } else if (typeof optOrUrl === "object") {
	 if ("url" in optOrUrl) {
	    hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 }
      } else {
	 this.#path = serviceUrl(hop.#hop, "svc" + ServiceImpl.#cnt++);
	 hop.backend.get(this.#path, ServiceImpl.getResponse.bind(this));
	 hop.backend.post(this.#path, ServiceImpl.postResponse.bind(this));
	 hop.backend.put(this.#path, ServiceImpl.putResponse.bind(this));
      }
   }

   dollar() {
      return `hop.server.import('${this.#path}')`;
   }

   path(args) {
      if (args.length === 0) {
	 return this.#path;
      } else {
	 let json = JSON.stringify(args);
	 return this.#path + "?hop-serialize=json-url&hop-arguments="
	    + encodeURIComponent(json);
      }
   }

   schema() {
      return this.#hop.schema();
   }
   
   static postResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = undefined;

	 switch (req.get("hop-serialize")) {
	    case "json": {
	       const args = req.get("hop-arguments");
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default:
	       rep = this.#fun.call(req, req.query);
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static putResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep = this.#fun.call(req, req.query);
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
   
   static getResponse(req, res) {
      req.hop = this.#hop;
      if (this.#hop.auth.authorizedService(req, this.#path)) {
	 let rep;
	 switch (req.query["hop-serialize"]) {
	    case "json-url": {
	       const args = decodeURIComponent(req.query["hop-arguments"]);
	       rep = this.#fun.apply(req, JSON.parse(args));
	       break;
	    }
	    default: {
	       rep = this.#fun.call(req, req.query);
	    }
	 }
	 return hopResponse(req, res, rep);
      } else {
	 return hopResponse(req, res, HTTPResponseAuthentication());
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Frame ...                                                        */
/*---------------------------------------------------------------------*/
// @sealed
class Frame {
   #svc;
   #args;
   
   constructor(svc,args) {
      this.#svc = svc;
      this.#args = args;
   }

   dollar() {
      return "'" + this.toString() + "'";
   }
   
   toString() {
      return `${this.#svc.schema()}${this.#svc.path(this.#args)}`;
   }
}

/*---------------------------------------------------------------------*/
/*    hopResponse ...                                                  */
/*    -------------------------------------------------------------    */
/*    This function is used to encode value returned by services       */
/*    and by event broadcast (see event.mjs).                          */
/*---------------------------------------------------------------------*/
function hopResponse(req, res, val) {
   if (val instanceof Response) {
      return val.hopResponse(req, res);
   } else if (val instanceof Promise) {
      return val.then(val => hopResponse(req, res, val));
   } else {
      // keep-alive
      const conn = req.get("connection");
      if (conn) {
	 res.set("Connection", conn);
      }

      if (typeof(val) === "number") {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("hop-serialize", "number");
	 res.send(str);
      } else if (val === undefined) {
	 res.append("Content-Length", "0");
	 res.append("hop-serialize", "undefined");
	 res.send("");
      } else if (val === null) {
	 res.append("Content-Length", "0")
	 res.append("hop-serialize", "null");
	 res.send("");
      } else if (val === true) {
	 res.append("Content-Length", "0")
	 res.append("hop-serialize", "true");
	 res.send("");
      } else if (val === false) {
	 res.append("Content-Length", "0");
	 res.append("hop-serialize", "false");
	 res.send("");
      } else if (typeof(val) === "string") {
	 res.append("Content-Length", val.length);
	 res.append("hop-serialize", "string");
	 res.send(val);
      } else if (val instanceof Buffer) {
	 res.append("hop-serialize", "buffer");
	 res.send(val);
      } else if (val instanceof Date) {
	 res.append("hop-serialize", "date");
	 res.send(val.getTime().toString());
      } else if (!(val instanceof Object)) {
	 // native objects will follow that path
	 return val;
      } else if ("toResponse" in val) {
	 const { string, serialize } = val.toResponse();
	 res.append("Content-Length", string.length);
	 res.append("hop-serialize", serialize);
	 res.send(string);
      } else if (!req.get("hop-serialize")) {
	 const str = val.toString();
	 res.append("Content-Length", str.length);
	 res.append("Content-Type", val?.mimetype ?? "application/text");
	 res.append("hop-serialize", "string");
	 res.send(str);
      } else {
	 const str = JSON.stringify(val);
	 res.append("Content-Length", str.length);
	 res.append("hop-serialize", "json");
	 res.send(str);
      }
      return res;
   }
}
   
/*---------------------------------------------------------------------*/
/*    Response                                                         */
/*---------------------------------------------------------------------*/
// @sealed
class Response {
   val;
   status;
   headers;
   
   constructor(val, status = 200, headers = undefined) {
      this.val = val;
      this.status = status;
      this.headers = headers;
   }
   
   hopResponse(req, res) {
      throw `Response not implemented (${this.constructor.name})`;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseString ...                                               */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseString extends Response {
   hopResponse(req, res) {
      // status
      res.status(this.status);

      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      // content
      res.send(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    ResponseFile ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseFile extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      res.sendFile(this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseFile ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseFile(path, opt = undefined) {
   const headers = opt || {
      "Content-Disposition": `inline; filename="${basename(path)}"`,
      "connection": "keep-alive"
   };
   return new ResponseFile(path, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseString ...                                           */
/*---------------------------------------------------------------------*/
function HTTPResponseString(str, opt) {
   const headers = opt || { "connection": "keep-alive" };
   return new ResponseString(str, 200, headers);
}

/*---------------------------------------------------------------------*/
/*    ResponseAuthentication ...                                       */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseAuthentication extends ResponseString {
   hopResponse(req, res) {
      // authentication
      const headers = WWWAuthenticate(
	 req.hop.config.real, req.hop.config.hostname, req.port);
      for (let k in headers) {
	 res.append(k, headers[k]);
      }
      return super.hopResponse(req, res);
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseAuthentication ...                                   */
/*---------------------------------------------------------------------*/
function HTTPResponseAuthentication(opt = undefined) {
   return new ResponseAuthentication("Unauthorized", 401);
}

/*---------------------------------------------------------------------*/
/*    ResponseHTML ...                                                 */
/*---------------------------------------------------------------------*/
// @sealed
class ResponseHTML extends Response {
   hopResponse(req, res) {
      // header
      if (this.headers) {
	 for (let k in this.headers) {
	    res.append(k, this.headers[k]);
	 }
      }

      hopResponse(req, res, this.val);
      return res;
   }
}

/*---------------------------------------------------------------------*/
/*    HTTPResponseHTML ...                                             */
/*---------------------------------------------------------------------*/
function HTTPResponseHTML(html, opt = undefined) {
   return new ResponseHTML(html, 200);
}
