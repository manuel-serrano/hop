;*=====================================================================*/
;*    .../project/hop/hop/node_modules/texinfo/lib/_texinfo.hop        */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun Jul  6 06:15:53 2014                          */
;*    Last change :  Mon May 18 10:46:47 2020 (serrano)                */
;*    Copyright   :  2014-20 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    TEXINFO hop parser                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _texinfo

   (library hopscript hop hopwidget nodejs)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)
	   
	   <TEXINFO:PARSE-ERROR>
	   <TEXINFO:TITLE>
	   <TEXINFO:SUBTITLE>
	   <TEXINFO:AUTHOR>
	   <TEXINFO:DISPLAY>
	   <TEXINFO:H1>
	   <TEXINFO:H2>
	   <TEXINFO:H3>
	   <TEXINFO:H4>
	   <TEXINFO:H5>
	   <TEXINFO:CODE>
	   <TEXINFO:PRE>
	   <TEXINFO:BLOCKQUOTE>
	   <TEXINFO:LI>
	   <TEXINFO:UL>
	   <TEXINFO:OL>
	   <TEXINFO:HR>
	   <TEXINFO:EM>
	   <TEXINFO:STRONG>
	   <TEXINFO:P>
	   <TEXINFO:A>
	   <TEXINFO:IMG>))

;*---------------------------------------------------------------------*/
;*    config ...                                                       */
;*---------------------------------------------------------------------*/
(define-struct config ifkwds auto-deffn-index sui base)

;*---------------------------------------------------------------------*/
;*    js-bind-tag! ...                                                 */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tag! %this obj tag)
   `(begin
       (js-bind! ,%this ,obj (& ,(symbol->string tag))
	  :value (js-make-function ,%this
		    (lambda (this attrs . nodes)
		       (if (isa? attrs JsObject)
			   (if (null? nodes)
			       (apply ,(symbol-append '< tag '>)
				  (js-jsobject->keyword-plist attrs ,%this))
			       (apply ,(symbol-append '< tag '>)
				  (append
				     (js-jsobject->keyword-plist attrs ,%this)
				     nodes)))
			   (apply ,(symbol-append '< tag '>)
			      nodes)))
		    2 (& ,(symbol->string tag)))
	  :writable #f
	  :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    js-bind-tags! ...                                                */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tags! %this obj . tags)
   `(begin
       ,@(map (lambda (tag)
		 `(js-bind-tag! ,%this ,obj ,tag))
	    tags)))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (&with!
      
      (define js-texinfo-prototype
	 (instantiateJsObject
	    (__proto__ (js-object-proto %this))
	    (elements ($create-vector 3))))
      
      (define exports (js-get module (& "exports") %this))

      (define (list->array val)
	 (js-vector->jsarray (list->vector (flatten val %this)) %this))
      
      ;; bind the module in the texinfo scope
      (js-put! scope (& "module") module #f %this)
      
      ;; __proto__
      (js-bind! %this exports (& "Texinfo")
	 :value js-texinfo-prototype
	 :writable #f
	 :enumerable #f)
      
      ;; XML tags
      (js-bind-tags! %this exports
	 TEXINFO:TITLE TEXINFO:SUBTITLE TEXINFO:AUTHOR TEXINFO:DISPLAY
	 TEXINFO:H1 TEXINFO:H2 TEXINFO:H3 TEXINFO:H4 TEXINFO:H5
	 TEXINFO:PRE TEXINFO:CODE TEXINFO:BLOCKQUOTE TEXINFO:LI
	 TEXINFO:UL TEXINFO:OL TEXINFO:HR TEXINFO:EM TEXINFO:STRONG
	 TEXINFO:P TEXINFO:A TEXINFO:IMG)

      ;; loadDocument
      (js-bind! %this exports (& "loadDocument")
	 :value (js-make-function %this
		   (lambda (this file charset fontifier)
		      (let* ((scope (nodejs-new-scope-object %this))
			     (worker (js-current-worker))
			     (path (js-tostring file %this))
			     (module (nodejs-new-module path path worker %this))
			     (charset (if (eq? charset (js-undefined))
					  (hop-locale)
					  (js-tostring charset %this)))
			     (cfg (config '(@ifhtml @ifnottex) #t '()
				     (dirname path))))
			 ;; bind global properties in the document scope
			 (js-put! scope (& "module") module #f %this)
			 (js-put! module (& "filename") file #f %this)
			 ;; parse the texinfo file
			 (let ((xml (texinfo-parse-file
				       path charset
				       %this scope
				       fontifier
				       cfg)))
			    (instantiate::xml-document
			       (tag 'document)
			       (id (xml-make-id #unspecified 'DOCUMENT))
			       (body xml)))))
		   3 (& "loadDocument"))
	 :writable #f
	 :enumerable #f)
      
      ;; load
      (js-bind! %this exports (& "load")
	 :value (js-make-function %this
		   (lambda (this file charset fontifier)
		      (let* ((scope (nodejs-new-scope-object %this))
			     (worker (js-current-worker))
			     (path (js-tostring file %this))
			     (module (nodejs-new-module path path worker %this))
			     (charset (if (eq? charset (js-undefined))
					  (hop-locale)
					  (js-tostring charset %this)))
			     (cfg (config
				     '(@ifhtml @ifnottex)
				     #t
				     '()
				     (dirname path))))
			 ;; bind global properties in the document scope
			 (js-put! scope (& "module") module #f %this)
			 (js-put! module (& "filename") file #f %this)
			 ;; parse the texinfo file
			 (let* ((xml (texinfo-parse-file
					path charset
					%this scope
					fontifier
					cfg))
				(res (instantiateJsObject
					(__proto__ js-texinfo-prototype))))
			    (js-put! res (& "filename") file #f %this)
			    (js-put! res (& "charset") charset #f %this)
			    (js-put! res (& "XML") (list->array xml) #f %this)
			    res)))
		   3 (& "load"))
	 :writable #f
	 :enumerable #f)
      
      ;; eval
      (js-bind! %this exports (& "eval")
	 :value (js-make-function %this
		   (lambda (this obj charset fontifier)
		      (let ((scope (nodejs-new-scope-object %this)))
			 ;; bind global properties in the document scope
			 (js-put! scope (& "module") module #f %this)
			 ;; parse the texinfo file
			 (let* ((xml (texinfo-parse-obj obj
					(if (eq? charset (js-undefined))
					    (hop-locale)
					    (js-tostring charset %this))
					%this scope
					fontifier
					(config '(@ifhtml @ifnottex) #t '()
					   (pwd))))
				(res (instantiateJsObject
					(__proto__ js-texinfo-prototype))))
			    (js-put! res (& "obj") obj #f %this)
			    (js-put! res (& "charset") charset #f %this)
			    (js-put! res (& "XML") (list->array xml) #f %this)
			    res)))
		   3 (& "eval"))
	 :writable #f
	 :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    eval-texinfo ...                                                 */
;*---------------------------------------------------------------------*/
(define (eval-texinfo exp ctx)
   (if (pair? ctx)
       (eval `(let (,ctx) ,exp))
       (eval exp)))

;*---------------------------------------------------------------------*/
;*    flatten ...                                                      */
;*---------------------------------------------------------------------*/
(define (flatten l ctx)
   (cond
      ((null? l) l)
      ((pair? l) (append (flatten (car l) ctx) (flatten (cdr l) ctx)))
      ((isa? l JsArray) (flatten (jsarray->list l ctx) ctx))
      (else (list l))))

;*---------------------------------------------------------------------*/
;*    texinfo-debug ...                                                */
;*---------------------------------------------------------------------*/
(define texinfo-debug
   (let ((env (getenv "NODE_DEBUG")))
      (and (string? env) (string-contains env "texinfo"))))

;*---------------------------------------------------------------------*/
;*    <TEXINFO:PARSE-ERROR> ...                                        */
;*---------------------------------------------------------------------*/
(define (<TEXINFO:PARSE-ERROR> str)
   (<SPAN> :hssclass "hop-parse-error"
      str))

;*---------------------------------------------------------------------*/
;*    texinfo-name ...                                                 */
;*---------------------------------------------------------------------*/
(define (texinfo-name expr)
   (let* ((s (with-output-to-string
		(lambda ()
		   (let loop ((e expr))
		      (cond
			 ((pair? e)
			  (for-each loop e))
			 ((isa? e xml-markup)
			  (with-access::xml-markup e (body)
			     (loop body)))
			 ((null? e)
			  #unspecified)
			 (else
			  (display e)))))))
	  (s2 (pregexp-replace* "  |\n" s " ")))
      (pregexp-replace* "^ +| +$" s2 "")))

;*---------------------------------------------------------------------*/
;*    texinfo-read-error ...                                           */
;*---------------------------------------------------------------------*/
(define (texinfo-read-error msg obj port)
   (raise
      (instantiate::&io-read-error
	 (fname (input-port-name port))
	 (location (input-port-position port))
	 (proc "texinfo-parser")
	 (msg msg)
	 (obj obj))))

;*---------------------------------------------------------------------*/
;*    texinfo-parse-error ...                                          */
;*---------------------------------------------------------------------*/
(define (texinfo-parse-error msg obj ctx)
   (match-case ctx
      ((at ?fname ?loc)
       (raise
	  (instantiate::&io-parse-error
	     (fname fname)
	     (location loc)
	     (proc "texinfo-parser")
	     (msg msg)
	     (obj obj))))
      ((? input-port?)
       (raise
	  (instantiate::&io-parse-error
	     (fname (input-port-name ctx))
	     (location (input-port-position ctx))
	     (proc "texinfo-parser")
	     (msg msg)
	     (obj obj))))
      (else
       (raise
	  (instantiate::&io-parse-error
	     (proc "texinfo-parser")
	     (msg msg)
	     (obj obj))))))

;*---------------------------------------------------------------------*/
;*    Texinfo tags                                                     */
;*---------------------------------------------------------------------*/
(define-macro (define-texinfo-tag tag id . clazz)
   (let ((cla (if (pair? clazz)
		  (string-append (car clazz) " texinfo ")
		  "texinfo ")))
      `(define-tag ,(symbol-append '|<TEXINFO:| tag '>)
	  ((%context #f)
	   (class #f)
	   (attrs)
	   body)
	  (apply ,(symbol-append '< id '>)
	     :class (cond
		       ((string? class)
			(string-append ,cla class))
		       ((isa? class JsStringLiteral)
			(string-append ,cla (js-jsstring->string class)))
		       (else
			,cla))
	     attrs body))))

(define-texinfo-tag TITLE H1 "title")
(define-texinfo-tag SUBTITLE H2 "subtitle")
(define-texinfo-tag AUTHOR DIV "author")
(define-texinfo-tag DISPLAY PRE "display")
(define-texinfo-tag CHAPTER H1 "chapter toc anchor")
(define-texinfo-tag SECTION H2 "section toc anchor")
(define-texinfo-tag SUBSECTION H3 "subsection toc anchor")
(define-texinfo-tag SUBSUBSECTION H4 "subsubsection anchor")
(define-texinfo-tag EXAMPLE PRE "example")
(define-texinfo-tag SMALLEXAMPLE PRE "smallexample")
(define-texinfo-tag LISP PRE "lisp scheme fontifier-prog")
(define-texinfo-tag SMALLLISP PRE "smalllisp scheme fontifier-prog")
(define-texinfo-tag FILE SPAN "file")
(define-texinfo-tag OL OL)
(define-texinfo-tag UL UL "itemize")
(define-texinfo-tag LI LI "item")
(define-texinfo-tag H1 H1 "toc")
(define-texinfo-tag H2 H2 "toc")
(define-texinfo-tag H3 H3 "toc")
(define-texinfo-tag H4 H4 "toc")
(define-texinfo-tag H5 H5 "toc")
(define-texinfo-tag CODE CODE)
(define-texinfo-tag PRE PRE)
(define-texinfo-tag R SPAN "r")
(define-texinfo-tag I SPAN "i")
(define-texinfo-tag B STRONG "b")
(define-texinfo-tag W STRONG "w")
(define-texinfo-tag TT TT "tt")
(define-texinfo-tag BLOCKQUOTE BLOCKQUOTE)
(define-texinfo-tag HR HR)
(define-texinfo-tag EM EM)
(define-texinfo-tag STRONG STRONG)
(define-texinfo-tag P P)
(define-texinfo-tag A A)
(define-texinfo-tag IMG IMG)
(define-texinfo-tag Q Q)

(define-tag <TEXINFO:DEFFN> ((class "deffn")
			     (kind "function")
			     (name "")
			     (args "")
			     (rest "")
			     (attrs)
			     body)
   (cons
      (<H4> :class (string-append "texinfo glyphicon glyphicon-tag " class " " kind)
	 (<SPAN> :class "deffn-name" name)
	 (<SPAN> :class "deffn-args" args)
	 (<SPAN> :class "deffn-rest" rest)
	 (<SPAN> :class "deffn-kind" kind))
      (append body
	 (<DIV> :class "deffn-end" ".keep"))))

;*---------------------------------------------------------------------*/
;*    *reserved-keywords* ...                                          */
;*---------------------------------------------------------------------*/
(define *reserved-keywords*
   '("AA" "aa" "AE" "ae"))

(define *argument-commands*
   '("dots"
     "equiv"
     "error"
     "TeX"
     "bullet"
     "email"
     "url"
     "b"
     "strong"
     "i"
     "sc"
     "w"
     "r"
     "t"
     "value"
     "copyright"
     "minus"
     "point"
     "code"
     "var"
     "kbd"
     "key"
     "emph"
     "dfn"
     "samp"
     "ref"
     "xref"
     "pxref"
     "inforef"
     "expansion"
     "result"
     "equiv"
     "print"
     "file"
     "footnote"
     "math"
     "cite"
     "anchor"))

(define *dual-argument-commands*
   '("title"
     "subtitle"
     "author"))

(define *line-commands*
   '("center"
     "cindex" "vindex" "kindex" "findex" "tindex" "pindex" "printindex"
     "node"
     "setfilename" "settitle"
     "syncodeindex" "synindex" "footnotestyle"
     "paragraphindent"
     "finalout"
     "table" "table @code" "table @samp" "table @bullet"
     "table @emph" "table @asis" "table @var" "table @dfn"
     "table @t" "table @kbd" "end table" "table @r" "table @b" "table @minus"
     "itemize" "itemize @bullet" "itemize @minus"
     "end itemize"
     "enumerate" "end enumerate"
     "item" "itemx"
     "menu" "end menu"
     "finalout"
     "paragraphindent"
     "set"
     "include"
     "dircategory"
     "direntry" "end direntry"
     "setchapternewpage"
     "shorttitlepage"
     "titlepage" "end titlepage"
     "title"
     "subtitle"
     "author"
     "page"
     "vskip"
     "macro" "rmacro" "end macro"
     "defn" "end defn"
     "deffn" "end deffn"
     "deffnx"
     "deftp" "end deftp"
     "defun" "defunx" "end defun"
     "defmac" "defmacx" "end defmac"
     "defvar" "defvarx" "end defvar"
     "defvr" "defvrx" "end defvr"
     "defopt" "defoptx" "end defopt"
     "defspec" "defspecx" "end defspec"
     "defmethod" "end defmethod"
     "smalllisp" "end smalllisp"
     "lisp" "end lisp"
     "smallexample" "end smallexample"
     "example" "end example"
     "group" "end group"
     "format" "end format"
     "display" "end display"
     "quotation" "end quotation"
     "chapter" "section" "subsection" "subsubsection"
     "unnumbered" "unnumberedsec" "unnumberedsubsubsec"
     "contents" "summarycontents"
     "flushleft" "end flushleft"
     "flushright" "end flushright"
     "bye"
     "refill"
     "noindent" "exdent"
     "sp" "need"
     "smallbook"))

(define *ignore-start-commands*
   '("ignore"
     "ifinfo"
     "tex"
     "iftex"
     "ifnottex"
     "ifhtml"))

(define *ignore-stop-commands*
   '("end ignore"
     "end ifinfo"
     "end tex"
     "end iftex"
     "end ifnottex"
     "end ifhtml"))
     
;*---------------------------------------------------------------------*/
;*    Mark                                                             */
;*---------------------------------------------------------------------*/
(define *argument-mark* (cons 1 1))
(define *line-mark* (cons 1 2))
(define *ignore-start-mark* (cons 1 3))
(define *ignore-stop-mark* (cons 1 4))

;*---------------------------------------------------------------------*/
;*    string-strip ...                                                 */
;*    -------------------------------------------------------------    */
;*    Remove all occurences of CHAR in STR.                            */
;*---------------------------------------------------------------------*/
(define (string-strip str char)
   (let ((len (string-length str)))
      (let loop ((i 0)
		 (pos 0))
	 (cond
	    ((=fx i len)
	     (if (null? pos)
		 str
		 (let* ((nlen (-fx len pos))
			(res (make-string nlen)))
		    (let loop ((r 0)
			       (w 0))
		       (cond
			  ((=fx r len)
			   res)
			  ((char=? (string-ref str r) char)
			   (loop (+fx r 1) w))
			  (else
			   (string-set! res w (string-ref str r))
			   (loop (+fx r 1) (+fx w 1))))))))
	    ((char=? (string-ref str i) char)
	     (loop (+fx i 1) (+fx pos 1)))
	    (else
	     (loop (+fx i 1) pos))))))
		 
;*---------------------------------------------------------------------*/
;*    strip@ ...                                                       */
;*---------------------------------------------------------------------*/
(define (strip@ str)
   (string-strip str #\@))

;*---------------------------------------------------------------------*/
;*    Initialize the keywords                                          */
;*---------------------------------------------------------------------*/
(for-each (lambda (k)
	     (let ((sym (string->symbol (string-append "@" k "{")))
		   (val (string->symbol (string-upcase k))))
		(putprop! sym 'info *argument-mark*)
		(putprop! sym 'info-value val)))
	  *argument-commands*)
;; we have to take special care to title because it is a polymorphic
;; command. It may be used with arguments in brackets or with arguments
;; found on the command line!
(for-each (lambda (k)
	     (let ((sym (string->symbol (string-append "@" k "{")))
		   (val (string->symbol (string-append "A" (string-upcase k)))))
		(putprop! sym 'info *argument-mark*)
		(putprop! sym 'info-value val)))
	  *dual-argument-commands*)
   
(for-each (lambda (k)
	     (let ((sym (string->symbol (string-append "@" k)))
		   (val (string->symbol (strip@ (string-upcase k)))))
		(putprop! sym 'info *line-mark*)
		(putprop! sym 'info-value val)))
	  *line-commands*)
(for-each (lambda (k)
	     (let ((sym (string->symbol (string-append "@" k))))
		(putprop! sym 'info *ignore-start-mark*)))
	  *ignore-start-commands*)
(for-each (lambda (k)
	     (let ((sym (string->symbol (string-append "@" k))))
		(putprop! sym 'info *ignore-stop-mark*)))
	  *ignore-stop-commands*)

;*---------------------------------------------------------------------*/
;*    lexer ...                                                        */
;*---------------------------------------------------------------------*/
(define texinfo-lexer
   (regular-grammar (charset %this scope fontifier config)

      ;; texinfo identification
      ((bol (: "\\input" (* all)))
       (ignore))
      
      ;; comment
      ((: "@" (or "c\n" (: (or "c " "comment ") (* all) (? #\Newline))))
       (ignore))

      ;; brackets
      (#\{
       (list 'BRAOPEN (the-coord (the-port))))
      (#\}
       (list 'BRACLO (the-coord (the-port))))
      
      ;; special commands
      ("@ "
       (list 'STRING (the-coord (the-port)) " "))
      ("@!"
       (list 'STRING (the-coord (the-port)) "!"))
      ("@\""
       (list 'STRING (the-coord (the-port)) "\""))
      ("@'"
       (list 'STRING (the-coord (the-port)) "'"))
      ("@*"
       (list 'LINEBREAK (the-coord (the-port)) 1))
      ("@,{C}"
       (list 'STRING (the-coord (the-port)) "รง"))
      ("@-"
       (ignore))
      ("@."
       (list 'STRING (the-coord (the-port)) "."))
      ("@:"
       (list 'STRING (the-coord (the-port)) ":"))
      ("@="
       (list 'STRING (the-coord (the-port)) "="))
      ("@?"
       (list 'STRING (the-coord (the-port)) "?"))
      ("@@"
       (list 'STRING (the-coord (the-port)) "@"))
      ("@^"
       (list 'STRING (the-coord (the-port)) "^"))
      ("@`"
       (list 'STRING (the-coord (the-port)) "`"))
      ("@{"
       (list 'STRING (the-coord (the-port)) "{"))
      ("@}"
       (list 'STRING (the-coord (the-port)) "}"))
      ("@~"
       (list 'STRING (the-coord (the-port)) "~"))
      ("@L{}"
       (list '/L (the-coord (the-port)))) 
      ("@l{}"
       (list '/l (the-coord (the-port))))
      ("@O{}"
       (list '/O (the-coord (the-port))))
      ("@o{}"
       (list '/o (the-coord (the-port))))
      ("@OE{}"
       (list '@OE (the-coord (the-port))))
      ("@oe{}"
       (list '@oe (the-coord (the-port))))
      
      ;; commands with arguments
      ((: #\@ (+ (in ("azAZ"))) #\{)
       (let ((sym (the-symbol)))
	  (cond
	     ((not (eq? (getprop sym 'info) *argument-mark*))
	      (error/location "lexer(info)"
			      "Unknown argument command"
			      (the-string)
 			      (input-port-name (the-port))
			      (input-port-position (the-port))))
	     (else
	      (list (getprop sym 'info-value) (the-coord (the-port)))))))

      ;; commands without arguments
      ((: #\@ (+ (in ("azAZ"))) #\Newline)
       (let ((sym (string->symbol (the-substring 0 (-fx (the-length) 1)))))
	  (cond
	     ((eq? (getprop sym 'info) *ignore-start-mark*)
	      (if (memq sym (config-ifkwds config))
		  (ignore)
		  (let* ((what (the-substring 1 (-fx (the-length) 1)))
			 (stop (string-append "@end " what)))
		     (let loop ((line (read-line (the-port))))
			(cond
			   ((eof-object? line)
			    (error "lexer(info)"
				   (string-append "Unclosed `" stop "'")
				   line))
			   ((string=? line stop)
			    (ignore))
			   (else
			    (loop (read-line (the-port)))))))))
	     ((not (eq? (getprop sym 'info) *line-mark*))
	      (error/location "lexer(info)"
			      "Unknown plain command"
			      (the-string)
			      (input-port-name (the-port))
			      (input-port-position (the-port))))
	     (else
	      (list (getprop sym 'info-value)
		    (the-coord (the-port))
		    (the-substring 0 (-fx (the-length) 1)))))))

      ;; commands without arguments at the end of input
      ((: #\@ (+ (in ("azAZ"))))
       (let ((sym (the-symbol)))
	  (cond
	     ((not (eq? (getprop sym 'info) *line-mark*))
	      (error/location "lexer(info)"
			      "Unknown plain command"
			      (the-string)
			      (input-port-name (the-port))
			      (input-port-position (the-port))))
	     (else
	      (list (getprop sym 'info-value)
		    (the-coord (the-port))
		    (the-string))))))

      ;; commands without arguments but with a text
      ((: #\@ (+ (in ("azAZ"))) (in " \t") (* all) #\Newline)
       (let ((sym (string->symbol (the-substring 0 (-fx (the-length) 1)))))
	  (cond
	     ((eq? (getprop sym 'info) *ignore-stop-mark*)
	      (ignore))
	     ((eq? (getprop sym 'info) *line-mark*)
	      (list (getprop sym 'info-value)))
	     (else
	      (let* ((str (the-string))
		     (word (string-until str #\space 0))
		     (k (string->symbol word)))
		 (cond
		    ((eq? (getprop k 'info) *ignore-start-mark*)
		     (if (memq k (config-ifkwds config))
			 (ignore)
			 (let* ((what (substring word 1 (string-length word)))
				(stop (string-append "@end " what))
				(lstop (string-length stop)))
			    (let loop ((line (read-line (the-port))))
			       (cond
				  ((eof-object? line)
				   (error "lexer(info)"
					  (string-append "Unclosed `" stop "'")
					  line))
				  ((substring=? line stop lstop)
				   (ignore))
				  (else
				   (loop (read-line (the-port)))))))))
		    ((eq? (getprop k 'info) *ignore-stop-mark*)
		     (ignore))
		    ((not (eq? (getprop k 'info) *line-mark*))
		     (error/location "lexer(info)"
				     "Unknown line command"
				     (the-string)
				     (input-port-name (the-port))
				     (input-port-position (the-port))))
		    (else
		     (let* ((rest (the-substring (+fx (string-length word) 1)
						 (-fx (the-length) 1)))
			    (coord (cons (input-port-name (the-port))
					 (-fx (input-port-position (the-port))
					      (+fx 1 (string-length rest))))))
			;; we have to parse the rest of the line with the
			;; regular texinfo parser...
			(list (getprop k 'info-value)
			      coord
			      (texinfo-parse-string rest
				 charset %this scope fontifier config))))))))))

      ;; text
      ((+ (out "@{}<>\n"))
       (list 'STRING (the-coord (the-port))
	  (the-string)))
      ((+ (out "@{}\n"))
       (list 'STRING (the-coord (the-port))
	  (xml-string-encode (the-string))))

      ;; Newlines
      ((+ #\Newline)
       (if (=fx (the-length) 1)
	   (list 'STRING (the-coord (the-port)) "\n")
	   (list 'LINEBREAK (the-coord (the-port)) (the-string))))
      
      (else
       (let ((c (the-failure)))
	  (if (eof-object? c)
	      c
	      (error/location "lexer(info)"
			      "Illegal character"
			      c
			      (input-port-name (the-port))
			      (input-port-position (the-port))))))))

;*---------------------------------------------------------------------*/
;*    string-from ...                                                  */
;*    -------------------------------------------------------------    */
;*    Skip all characters until MARK, returns the rest of the          */
;*    string. Delta is how many characters to skip from the marker.    */
;*---------------------------------------------------------------------*/
(define (string-from string mark delta)
   (let ((len (string-length string)))
      (let loop ((i 0))
	 (cond
	    ((=fx i len)
	     "")
	    ((char=? (string-ref string i) mark)
	     (substring string (+fx i delta) len))
	    (else
	     (loop (+fx i 1)))))))

;*---------------------------------------------------------------------*/
;*    string-from-at ...                                               */
;*    -------------------------------------------------------------    */
;*    Skip all characters until MARK, returns the rest of the          */
;*    string. Delta is how many characters to skip from the marker.    */
;*---------------------------------------------------------------------*/
(define (string-from-at string start mark delta)
   (let ((len (string-length string)))
      (let loop ((i start))
	 (cond
	    ((=fx i len)
	     "")
	    ((char=? (string-ref string i) mark)
	     (substring string (+fx i delta) len))
	    (else
	     (loop (+fx i 1)))))))

;*---------------------------------------------------------------------*/
;*    string-until ...                                                 */
;*    -------------------------------------------------------------    */
;*    Skip all characters after MARK, returns the rest of the          */
;*    string. Delta is how many characters to skip from the marker.    */
;*---------------------------------------------------------------------*/
(define (string-until string mark delta)
   (string-until-at string 0 mark delta))

;*---------------------------------------------------------------------*/
;*    string-until-at ...                                              */
;*    -------------------------------------------------------------    */
;*    Skip all characters after MARK, returns the rest of the          */
;*    string. Delta is how many characters to skip from the marker.    */
;*---------------------------------------------------------------------*/
(define (string-until-at string start mark delta)
   (let ((len (string-length string)))
      (let loop ((i start))
	 (cond
	    ((>=fx i len)
	     "")
	    ((char=? (string-ref string i) mark)
	     (substring string start (+fx i delta)))
	    (else
	     (loop (+fx i 1)))))))

;*---------------------------------------------------------------------*/
;*    string-char-after ...                                            */
;*    -------------------------------------------------------------    */
;*    Return the char following the first occurrence of CHAR in        */
;*    STRING.                                                          */
;*---------------------------------------------------------------------*/
(define (string-char-after string char)
   (let ((len (-fx (string-length string) 1)))
      (let loop ((i 0))
	 (cond
	    ((>=fx i len)
	     (error "string-char-after:Can't find char" string char))
	    ((char=? (string-ref string i) char)
	     (string-ref string (+fx i 1)))
	    (else
	     (loop (+fx i 1)))))))

;*---------------------------------------------------------------------*/
;*    nthword ...                                                      */
;*    -------------------------------------------------------------    */
;*    Returns the NTH word of the STR.                                 */
;*---------------------------------------------------------------------*/
(define (nthword str nth . delims)
   (let ((delims (if (null? delims)
		     '(#\tab #\Newline #\space)
		     delims))
	 (len (string-length str)))
      (define (find-end-word start)
	 (cond
	    ((=fx start len)
	     len)
	    ((memq (string-ref str start) delims)
	     start)
	    (else
	     (find-end-word (+fx 1 start)))))
      (define (skip-blank start delims)
	 (cond
	    ((=fx start len)
	     #f)
	    ((memq (string-ref str start) delims)
	     (skip-blank (+fx 1 start) delims))
	    (else
	     start)))
      (let loop ((num 0)
		 (start (skip-blank 0 '(#\tab #\Newline #\space))))
	 (cond
	    ((not start)
	     #f)
	    ((=fx num nth)
	     (substring str start (find-end-word start)))
	    (else
	     (loop (+fx num 1) (skip-blank (find-end-word start) delims)))))))

;*---------------------------------------------------------------------*/
;*    nthword2 ...                                                     */
;*    -------------------------------------------------------------    */
;*    Returns the NTH word of the STR.                                 */
;*    -------------------------------------------------------------    */
;*    nthword2 consider that there is only one separator between       */
;*    words.                                                           */
;*---------------------------------------------------------------------*/
(define (nthword2 str nth . delims)
   (let ((delims (if (null? delims)
		     '(#\tab #\Newline #\space)
		     delims))
	 (len (string-length str)))
      (define (find-end-word start)
	 (cond
	    ((=fx start len)
	     len)
	    ((memq (string-ref str start) delims)
	     start)
	    (else
	     (find-end-word (+fx 1 start)))))
      (define (skip-blank start delims)
	 (cond
	    ((=fx start len)
	     #f)
	    ((memq (string-ref str start) delims)
	     (+fx 1 start))
	    (else
	     start)))
      (let loop ((num 0)
		 (start (skip-blank 0 '(#\tab #\Newline #\space))))
	 (cond
	    ((not start)
	     #f)
	    ((=fx num nth)
	     (substring str start (find-end-word start)))
	    (else
	     (loop (+fx num 1) (skip-blank (find-end-word start) delims)))))))

;*---------------------------------------------------------------------*/
;*    the-coord ...                                                    */
;*---------------------------------------------------------------------*/
(define (the-coord port)
   (cons (input-port-name port) (input-port-position port)))

;*---------------------------------------------------------------------*/
;*    string-trim ...                                                  */
;*    -------------------------------------------------------------    */
;*    Skip all chars in CHARS.                                         */
;*---------------------------------------------------------------------*/
(define (string-trim str . delims)
   (let ((len (string-length str)))
      (let loop ((i 0))
	 (cond
	    ((=fx i len)
	     "")
	    ((memq (string-ref str i) delims)
	     (loop (+fx i 1)))
	    (else
	     (substring str i len))))))
   
;*---------------------------------------------------------------------*/
;*    texinfo-parse-file ...                                           */
;*---------------------------------------------------------------------*/
(define (texinfo-parse-file path charset %this scope fontifier config)
   (call-with-input-file path
      (lambda (p)
	 (texinfo-parse-port p charset %this scope fontifier config))))
 
;*---------------------------------------------------------------------*/
;*    texinfo-parse-obj ...                                            */
;*---------------------------------------------------------------------*/
(define (texinfo-parse-obj obj charset this scope fontifier config)
   (if (eq? obj (js-undefined))
       ""
       (let ((str (cond
		     ((isa? obj JsStringLiteral)
		      (js-jsstring->string obj))
		     ((isa? obj JsFastBuffer)
		      (js-jsfastbuffer->string obj))
		     ((isa? obj JsSlowBuffer)
		      (js-jsslowbuffer->string obj))
		     (else
		      (js-tostring obj this)))))
	  (texinfo-parse-string str charset this scope fontifier config))))

;*---------------------------------------------------------------------*/
;*    texinfo-parse-string ...                                         */
;*---------------------------------------------------------------------*/
(define (texinfo-parse-string string charset %this scope fontifier config)
   (call-with-input-string string
      (lambda (p)
	 (texinfo-parse-port p charset %this scope fontifier config))))
   
;*---------------------------------------------------------------------*/
;*    texinfo-parse-port ...                                           */
;*---------------------------------------------------------------------*/
(define (texinfo-parse-port port charset %this scope fontifier config)

   (define node-mark #f)
   
   (define parser
      (lalr-grammar
	 
	 ;; tokens
	 (STRING
	    LINEBREAK
	    BRACLO
	    BRAOPEN
	    NODE
	    B I R W T EMPH DFN SAMP SC STRONG
	    KBD KEY
	    CODE VAR
	    REF XREF PXREF INFOREF
	    COPYRIGHT EXPANSION EQUIV ERROR RESULT PRINT DOTS FILE FOOTNOTE MATH TEX
	    POINT MINUS
	    EMAIL URL CITE ANCHOR NEED
	    IGNORE |END IGNORE|
	    TABLE |TABLE CODE| |TABLE BULLET| |TABLE EMPH| |TABLE SAMP|
	    |TABLE ASIS| |TABLE T| |TABLE R| |TABLE MINUS| |TABLE VAR| |TABLE DFN|
	    |TABLE KBD| |TABLE B| |END TABLE|
	    ITEMIZE |ITEMIZE BULLET| |ITEMIZE MINUS| |END ITEMIZE|
	    ENUMERATE |END ENUMERATE|
	    ITEM
	    ITEMX
	    IFSET |END IFSET|
	    MENU |END MENU|
	    SETFILENAME SETTITLE
	    PARAGRAPHINDENT
	    FOOTNOTESTYLE
	    FINALOUT
	    SET VALUE
	    INCLUDE
	    SETCHAPTERNEWPAGE
	    SHORTTITLEPAGE
	    TITLEPAGE |END TITLEPAGE|
	    TITLE SUBTITLE
	    ATITLE ASUBTITLE
	    AUTHOR AAUTHOR
	    PAGE
	    VSKIP
	    DIRCATEGORY
	    DIRENTRY |END DIRENTRY|
	    SMALLLISP |END SMALLLISP|
	    LISP |END LISP|
	    FLUSHLEFT |END FLUSHLEFT|
	    FLUSHRIGHT |END FLUSHRIGHT|
	    SMALLEXAMPLE |END SMALLEXAMPLE|
	    EXAMPLE |END EXAMPLE|
	    GROUP |END GROUP|
	    FORMAT |END FORMAT|
	    DISPLAY |END DISPLAY|
	    QUOTATION |END QUOTATION|
	    CHAPTER SECTION SUBSECTION SUBSUBSECTION
	    UNNUMBERED UNNUMBEREDSEC UNNUMBEREDSUBSEC UNNUMBEREDSUBSUBSEC
	    CINDEX VINDEX KINDEX FINDEX TINDEX PINDEX
	    PRINTINDEX SYNCODEINDEX SYNINDEX
	    REFILL NOINDENT EXDENT
	    CONTENTS SUMMARYCONTENTS
	    BYE
	    DEFN |END DEFN|
	    DEFFN |END DEFFN|
	    DEFFNX
	    DEFTP |END DEFTP|
	    DEFMETHOD |END DEFMETHOD|
	    DEFUN DEFUNX |END DEFUN|
	    DEFMAC DEFMACX |END DEFMAC|
	    DEFVAR DEFVARX |END DEFVAR|
	    DEFVR DEFVRX |END DEFVR|
	    DEFOPT DEFOPTX |END DEFOPT|
	    DEFSPEC DEFSPECX |END DEFSPEC|
	    SP
	    CENTER
	    SMALLBOOK)
	 
	 ;; commands
	 (commands
	    (() '())
	    ((command commands) (cons command commands)))
	 
	 ;; command
	 (command
	    ((ignore) '())
	    ((text) text)
	    ((argument-command) argument-command)
	    ((line-command) line-command)
	    ((BRAOPEN commands BRACLO) `(list ,@commands)))
	 
	 ;; ignore
	 (ignore
	    ((MENU commands |END MENU|) '())
	    ((SETFILENAME) '())
	    ((FOOTNOTESTYLE) '())
	    ((PARAGRAPHINDENT) '())
	    ((FINALOUT) '())
	    ((SETCHAPTERNEWPAGE) '())
	    ((SHORTTITLEPAGE) '())
	    ((PAGE) '())
	    ((DIRCATEGORY) '())
	    ((DIRENTRY commands |END DIRENTRY|) '())
	    ((VSKIP) '())
	    ((REFILL) '())
	    ((CONTENTS) '())
	    ((BYE) '())
	    ((SMALLBOOK) '())
	    ((NEED) '()))
	 
	 ;; text
	 (text
	    ((STRING)
	     (cadr STRING))
	    ((LINEBREAK)
	     (list (cadr LINEBREAK) (<P>))))
	 
	 ;; argument-command
	 (argument-command
	    ((acommand BRACLO)
	     acommand))
	 
	 (acommand
	    ((VALUE STRING)
	     (variable-value (cadr STRING)))
	    ((COPYRIGHT)
	     "&copy;")
	    ((MINUS)
	     "-")
	    ((POINT)
	     "-!-")
	    ((TEX)
	     "TeX")
	    ((DOTS)
	     "...")
	    ((B commands)
	     (if (pair? commands)
		 (<TEXINFO:B> :%context %this commands)
		 ""))
	    ((ATITLE commands)
	     (if (pair? commands)
		 `(title ,@commands)
		 ""))
	    ((ASUBTITLE commands)
	     (if (pair? commands)
		 `(subtitle ,@commands)
		 ""))
	    ((AAUTHOR commands)
	     `(author ,@commands))
	    ((I commands)
	     (if (pair? commands)
		 (<TEXINFO:I> :%context %this commands)
		 ""))
	    ((R commands)
	     (<TEXINFO:R> :%context %this commands))
	    ((EMAIL commands)
	     (mailto commands))
	    ((URL commands)
	     (<A> :class "texinfo url" :href commands commands))
	    ((W commands)
	     (if (pair? commands)
		 (<TEXINFO:W> :%context %this commands)
		 ""))
	    ((T commands)
	     (if (pair? commands)
		 (<TEXINFO:TT> :%context %this commands)
		 ""))
	    ((CODE commands)
	     (if (pair? commands)
		 (<CODE> commands)
		 ""))
	    ((VAR commands)
	     (if (pair? commands)
		 (<VAR> commands)
		 ""))
	    ((EMPH commands)
	     (if (pair? commands)
		 (<EM> commands)
		 ""))
	    ((DFN commands)
	     (string-append "\"" (stringify commands) "\""))
	    ((SAMP commands)
	     (if (pair? commands)
		 `(samp ,@commands)
		 ""))
	    ((SC commands)
	     (if (pair? commands)
		 `(sc ,@commands)
		 ""))
	    ((STRONG commands)
	     (if (pair? commands)
		 (<S> commands)
		 ""))
	    ((KBD commands)
	     (if (pair? commands)
		 `(kbd ,@commands)
		 ""))
	    ((KEY commands)
	     (if (pair? commands)
		 `(kbd ,@commands)
		 ""))
	    ((REF commands)
	     (ref '@ref REF commands config))
	    ((XREF commands)
	     (xref commands config))
	    ((INFOREF commands)
	     (inforef commands))
	    ((PXREF commands)
	     `(list PXREF "see " ,(ref '@pxref PXREF commands config)))
	    ((EXPANSION)
	     (<SYM> "==>"))
	    ((EQUIV)
	     (<SYM> '<=>))
	    ((ERROR)
	     "error-->")
	    ((FOOTNOTE commands)
	     `(footnote ,@commands))
	    ((MATH commands)
	     (math commands))
	    ((CITE commands)
	     `(it (list CITE ,@commands)))
	    ((ANCHOR text)
	     `(mark ,text))
	    ((RESULT)
	     (<SYM> '=>))
	    ((RESULT command)
	     (cons* (<SYM> '=>) " " command))
	    ((PRINT)
	     (<SYM> "->|"))
	    ((FILE commands)
	     (<TEXINFO:FILE> :%context %this "`" commands "'")))
	 
	 ;; line-command
	 (line-command
	    ((NODE)
	     (set! node-mark
		(string-trim (nthword (car (cadr NODE)) 0 #\,)
		   #\space #\tab)))
	    ((INCLUDE)
	     `(list INCLUDE ,@(texinfo-parse-file
			 (make-file-path (config-base config)
			    (car (cadr INCLUDE)))
			 charset %this scope fontifier config)))
	    ((itemize)
	     itemize)
	    ((table)
	     table)
	    ((ITEM)
	     (if (pair? (cadr ITEM))
		 (<TEXINFO:LI> :%context %this (cadr ITEM))
		 ""))
	    ((ITEMX)
	     `(itemx ,@(cadr ITEMX) "\n"))
	    ((SET)
	     (parse-set (cadr SET)))
	    ((CHAPTER)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    (<TEXINFO:CHAPTER> :%context %this
		       :id (to-ident lbl) (cadr CHAPTER)))
		 (<TEXINFO:CHAPTER> :%context %this (cadr CHAPTER))))
	    ((SECTION)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    (<TEXINFO:SECTION> :%context %this
		       :id (to-ident lbl) (cadr SECTION)))
		 (<TEXINFO:SECTION> :%context %this (cadr SECTION))))
	    ((SUBSECTION)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    (<TEXINFO:SUBSECTION> :%context %this
		       :id (to-ident lbl) (cadr SUBSECTION)))
		 (<TEXINFO:SUBSECTION> :%context %this (cadr SUBSECTION))))
	    ((SUBSUBSECTION)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    (<TEXINFO:SUBSUBSECTION> :%context %this
		       :id  (to-ident lbl) (cadr SUBSUBSECTION)))
		 (<TEXINFO:SUBSUBSECTION> :%context %this (cadr SUBSUBSECTION))))
	    ((UNNUMBERED)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    `(chapter :number #f :toc #t :file #f :title ,@(cadr UNNUMBERED) ,lbl))
		 `(chapter :number #f :toc #t :file #f :title ,@(cadr UNNUMBERED))))
	    ((UNNUMBEREDSEC)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    `(section :number #f :title ,@(cadr UNNUMBEREDSEC) ,lbl))
		 `(section :number #f :title ,@(cadr UNNUMBEREDSEC))))
	    ((UNNUMBEREDSUBSEC)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    `(subsection :number #f :title ,@(cadr UNNUMBEREDSUBSEC) ,lbl))
		 `(subsection :number #f :title ,@(cadr UNNUMBEREDSUBSEC))))
	    ((UNNUMBEREDSUBSUBSEC)
	     (if node-mark
		 (let ((lbl node-mark))
		    (set! node-mark #f)
		    `(subsubsection :number #f :title ,@(cadr UNNUMBEREDSUBSUBSEC) ,lbl))
		 `(subsubsection :number #f :title ,@(cadr UNNUMBEREDSUBSUBSEC))))
	    ((SETTITLE)
	     `(header ,@(cadr SETTITLE)))
	    ((TITLEPAGE commands |END TITLEPAGE|)
	     (<TEXINFO:TITLE> :%context %this commands))
	    ((TITLE)
	     (<TEXINFO:TITLE> :%context %this (cadr TITLE)))
	    ((SUBTITLE) 
	     (<TEXINFO:SUBTITLE> :%context %this (cadr SUBTITLE)))
	    ((AUTHOR)
	     (<TEXINFO:AUTHOR> :%context %this (cadr AUTHOR)))
	    ((IGNORE commands |END IGNORE|)
	     (marks-only commands))
	    ((IFSET commands |END IFSET|)
	     (if (variable-bound? (car (cadr IFSET)))
		 `(list IFSET ,@commands)
		 (marks-only commands)))
	    ((SMALLLISP commands |END SMALLLISP|)
	     (<TEXINFO:SMALLLISP> :%context %this
		(fontify-code commands "scheme"
		   %this scope fontifier #f)))
	    ((LISP commands |END LISP|)
	     (<TEXINFO:LISP> :%context %this
		(fontify-code commands "scheme"
		   %this scope fontifier #f)))
	    ((SMALLEXAMPLE commands |END SMALLEXAMPLE|)
	     (<TEXINFO:SMALLEXAMPLE> :%context %this commands))
	    ((EXAMPLE commands |END EXAMPLE|)
	     (<TEXINFO:EXAMPLE> :%context %this commands))
	    ((GROUP commands |END GROUP|)
	     `(list GROUP ,@commands))
	    ((FORMAT commands |END FORMAT|)
	     (prgm #f '*skribeinfo-example-color* commands))
	    ((DISPLAY commands |END DISPLAY|)
	     (<TEXINFO:DISPLAY> :%context %this commands))
	    ((QUOTATION commands |END QUOTATION|)
	     (<TEXINFO:Q> :%context %this commands))
	    ((DEFN commands |END DEFN|)
	     (deffn (cadr DEFN) commands %this config))
	    ((DEFFN commands |END DEFFN|)
	     (deffn (cadr DEFFN) commands %this config))
	    ((DEFFNX)
	     `(deffnx ,(cadr DEFFNX)))
	    ((DEFTP commands |END DEFTP|)
	     (deffn (cadr DEFTP) commands %this config))
	    ((DEFUN commands |END DEFUN|)
	     (defun (cadr DEFUN) commands))
	    ((DEFUNX)
	     `(generic-defx ,@(cadr DEFUNX)))
	    ((DEFMAC commands |END DEFMAC|)
	     (defmac (cadr DEFMAC) commands))
	    ((DEFMACX)
	     `(generic-defx ,@(cadr DEFMACX)))
	    ((DEFVAR commands |END DEFVAR|)
	     (defvar (cadr DEFVAR) commands))
	    ((DEFVARX)
	     `(generic-defx ,@(cadr DEFVARX)))
	    ((DEFVR commands |END DEFVR|)
	     (defvar (cadr DEFVR) commands))
	    ((DEFVRX)
	     `(generic-defx ,@(cadr DEFVRX)))
	    ((DEFOPT commands |END DEFOPT|)
	     (defopt (cadr DEFOPT) commands))
	    ((DEFOPTX)
	     `(generic-defx ,@(cadr DEFOPTX)))
	    ((DEFSPEC commands |END DEFSPEC|)
	     (defspec (cadr DEFSPEC) commands))
	    ((DEFSPECX)
	     `(generic-defx ,@(cadr DEFSPECX)))
	    ((DEFMETHOD commands |END DEFMETHOD|)
	     (defmethod (cadr DEFMETHOD) commands))
	    ((SYNCODEINDEX)
	     (let ((w1 (nthword (car (cadr SYNCODEINDEX)) 0))
		   (w2 (nthword (car (cadr SYNCODEINDEX)) 1)))
		(syncodeindex w1 w2)))
	    ((SYNINDEX)
	     (let ((w1 (nthword (car (cadr SYNINDEX)) 0))
		   (w2 (nthword (car (cadr SYNINDEX)) 1)))
		(synindex w1 w2)))
	    ((FLUSHLEFT commands |END FLUSHLEFT|)
	     `(flush :side 'left ,@commands))
	    ((FLUSHRIGHT commands |END FLUSHRIGHT|)
	     `(flush :side 'left ,@commands))
	    ((CINDEX)
	     (index-entry "cp" (cadr CINDEX)))
	    ((PINDEX)
	     (index-entry "pg" (cadr PINDEX)))
	    ((VINDEX)
	     (index-entry "vr" (cadr VINDEX)))
	    ((KINDEX)
	     (index-entry "ky" (cadr KINDEX)))
	    ((FINDEX)
	     (index-entry "fn" (cadr FINDEX)))
	    ((TINDEX)
	     (index-entry "tp*" (cadr TINDEX)))
	    ((PRINTINDEX)
	     (printindex (car (cadr PRINTINDEX))))
	    ((SUMMARYCONTENTS)
	     `(toc))
	    ((NOINDENT)
	     (if (pair? (cadr NOINDENT))
		 `(list NOINDENT ,@(cadr NOINDENT))
		 '()))
	    ((EXDENT)
	     (if (pair? (cadr EXDENT))
		 `(list EXDENT ,@(cadr EXDENT))
		 '()))
	    ((SP)
	     (if (and (pair? (cdr SP)) (pair? (cadr SP)))
		 (let ((n (string->integer (car (cadr SP)))))
		    `(linebreak ,n))
		 '(linebreak 1)))
	    ((CENTER)
	     (if (pair? (cadr CENTER))
		 `(center ,@(cadr CENTER))
		 '())))
	 
	 ;; itemize
	 (itemize
	    ((ITEMIZE commands |END ITEMIZE|)
	     (<TEXINFO:UL> :%context %this commands))
	    ((|ITEMIZE BULLET| commands |END ITEMIZE|)
	     (<TEXINFO:UL> :%context %this commands))
	    ((|ITEMIZE MINUS| commands |END ITEMIZE|)
	     (itemize 'itemize commands))
	    ((ENUMERATE commands |END ENUMERATE|)
	     (itemize 'enumerate commands)))
	 
	 ;; table
	 (table
	    ((TABLE commands |END TABLE|)
	     (table commands (lambda (x) x)))
	    ((|TABLE CODE| commands |END TABLE|)
	     (table commands (lambda (x) `(code ,x))))
	    ((|TABLE BULLET| commands |END TABLE|)
	     (table commands (lambda (x) x)))
	    ((|TABLE EMPH| commands |END TABLE|) 
	     (table commands (lambda (x) `(emph ,x))))
	    ((|TABLE SAMP| commands |END TABLE|) 
	     (table commands (lambda (x) `(samp ,x))))
	    ((|TABLE ASIS| commands |END TABLE|) 
	     (table commands (lambda (x) x)))
	    ((|TABLE T| commands |END TABLE|) 
	     (table commands (lambda (x) `(tt ,x))))
	    ((|TABLE VAR| commands |END TABLE|) 
	     (table commands (lambda (x) `(code ,x))))
	    ((|TABLE DFN| commands |END TABLE|) 
	     (table commands (lambda (x) `(code ,x))))
	    ((|TABLE KBD| commands |END TABLE|) 
	     (table commands (lambda (x) `(kbd ,x))))
	    ((|TABLE B| commands |END TABLE|) 
	     (table commands (lambda (x) `(bold ,x))))
	    ((|TABLE R| commands |END TABLE|) 
	     (table commands (lambda (x) x)))
	    ((|TABLE MINUS| commands |END TABLE|) 
	     (table commands (lambda (x) x))))))

   (define (lexer port)
      (read/rp texinfo-lexer port charset %this scope fontifier config))
   
   (with-handler
      (lambda (e)
	 (exception-notify e))
      (read/lalrp parser lexer port)))

;*---------------------------------------------------------------------*/
;*    stringify ...                                                    */
;*---------------------------------------------------------------------*/
(define (stringify o)
   (cond
      ((string? o)
       o)
      ((pair? o)
       (match-case o
	  ((value . ?-)
	   o)
	  (else
	   (if (null? (cdr o))
	       (stringify (car o))
	       (apply string-append (map stringify o))))))
      ((symbol? o)
       "")
      (else
       (error "stringify" "Illegal value" o))))

;*---------------------------------------------------------------------*/
;*    marks-only ...                                                   */
;*---------------------------------------------------------------------*/
(define (marks-only lst)
   (define (find-marks expr res)
      (if (not (pair? expr))
	  res
	  (match-case expr
	     ((mark . ?-)
	      (cons expr res))
	     (else
	      (find-marks (car expr) (find-marks (cdr expr) res))))))
   (let loop ((lst lst)
	      (res '()))
      (if (null? lst)
	  (if (pair? res)
	      `(list marks ,@res)
	      '())
	  (loop (cdr lst)
		(find-marks (car lst) res)))))

;*---------------------------------------------------------------------*/
;*    texinfo-mutex ...                                                */
;*---------------------------------------------------------------------*/
(define texinfo-mutex
   (make-mutex))

;*---------------------------------------------------------------------*/
;*    parse-set ...                                                    */
;*---------------------------------------------------------------------*/
(define (parse-set token)
   (let* ((str (car token))
	  (var (nthword str 0))
	  (val (if (<fx (string-length var) (-fx (string-length str) 1))
		   (let ((val0 (substring str
					  (+fx (string-length var) 1)
					  (string-length str))))
		      (cons val0 (cdr token)))
		   (cdr token))))
      (bind-variable var val)
      '()))

;*---------------------------------------------------------------------*/
;*    *variables* ...                                                  */
;*---------------------------------------------------------------------*/
(define *variables* (make-hashtable))

;*---------------------------------------------------------------------*/
;*    bind-variable ...                                                */
;*---------------------------------------------------------------------*/
(define (bind-variable var val)
   (synchronize texinfo-mutex
      (hashtable-put! *variables* var val)
      ""))

;*---------------------------------------------------------------------*/
;*    variable-bound? ...                                              */
;*---------------------------------------------------------------------*/
(define (variable-bound? var)
   (synchronize texinfo-mutex
      (hashtable-get *variables* var)))

;*---------------------------------------------------------------------*/
;*    variable-value ...                                               */
;*---------------------------------------------------------------------*/
(define (variable-value var)
   (synchronize texinfo-mutex
      (or (hashtable-get *variables* var) var)))

;*---------------------------------------------------------------------*/
;*    mailto ...                                                       */
;*---------------------------------------------------------------------*/
(define (mailto commands)
   (let ((email (apply string-append (map (lambda (x)
					     (if (string? x)
						 x
						 ""))
					  commands))))
      (if (>fx (string-length email) 0)
	  `(mailto :text ,email ,@commands)
	  `(mailto ,@commands))))

;*---------------------------------------------------------------------*/
;*    table ...                                                        */
;*---------------------------------------------------------------------*/
(define (table commands deco)
   (define (table-lignes commands)
      (define (table-first-column commands lines)
	 (let loop ((commands commands)
		    (items '()))
	    (if (null? commands)
		(reverse! lines)
		(match-case (car commands)
		   ((item . ?item)
		    (if (not (null? items))
			;; this should be an error but it turns out that
			;; texinfo is laxist
			(loop (cdr commands)
			      (append (reverse! (map deco item)) items))
			(loop (cdr commands)
			      (reverse! (map deco item)))))
		   ((itemx . ?item)
		    (if (null? items)
			(error "table" "Illegal itemx" (car commands))
			(loop (cdr commands)
			      (append (reverse! (map deco item))
				      items))))
		   (else
		    (cond
		       ((null? items)
			(loop (cdr commands) items))
		       (else
			(table-second-column commands
					     (reverse! items)
					     lines))))))))
      (define (table-second-column commands dd lines)
	 (let loop ((commands commands)
		    (vals '()))
	    (if (null? commands)
		(table-first-column '()
				    (cons `(item :key (list ,@dd)
						 ,@(reverse! vals))
					  lines))
		(match-case (car commands)
		   ((item . ?item)
		    (table-first-column commands
					(cons `(item :key (list ,@dd)
						     ,@(reverse! vals))
					      lines)))
		   (else
		    (loop (cdr commands) (cons (car commands) vals)))))))
      (table-first-column commands '()))
   `(description ,@(table-lignes commands)))
     
;*---------------------------------------------------------------------*/
;*    itemize ...                                                      */
;*---------------------------------------------------------------------*/
(define (itemize markup commands)
   (define (itemize-lignes commands)
      (define (itemize-item commands lines)
	 (let loop ((commands commands)
		    (items '()))
	    (if (null? commands)
		(reverse! lines)
		(match-case (car commands)
		   ((item . ?item)
		    (itemize-entry (cdr commands) (reverse! item) lines))
		   (else
		    (loop (cdr commands) items))))))
      (define (itemize-entry commands vals lines)
	 (let loop ((commands commands)
		    (vals vals))
	    (if (null? commands)
		(itemize-item '() (cons `(item ,@(reverse! vals)) lines))
		(match-case (car commands)
		   ((item . ?item)
		    (itemize-item commands
				  (cons `(item ,@(reverse! vals)) lines)))
		   ((itemx . ?item)
		    (error "itemize" "Illegal itemx" (car commands)))
		   (else
		    (loop (cdr commands) (cons (car commands) vals)))))))
      (itemize-item commands '()))
   `(,markup ,@(itemize-lignes commands)))

;*---------------------------------------------------------------------*/
;*    *deffn-marks* ...                                                */
;*---------------------------------------------------------------------*/
(define *deffn-marks* '())

;*---------------------------------------------------------------------*/
;*    deffn ...                                                        */
;*---------------------------------------------------------------------*/
(define (deffn def commands %this config)
   
   (define (parse-deffn def)
      (match-case def
	 (((list ?kind) (and ?def (? string?)))
	  (let* ((name (nthword def 0))
		 (rest (substring def
			  (+fx 1 (string-length name))
			  (string-length def))))
	     (values name rest "" kind)))
	 (((list ?kind) (and ?def (? string?)) . ?rests)
	  (let ((name (nthword def 0)))
	     (if (not name)
		 (values "" "" rests kind)
		 (let ((rest (substring def
				(+fx 1 (string-length name))
				(string-length def))))
		    (values name rest rests kind)))))
	 (((list ?kind) . ?rest)
	  (values "" "" rest kind))
	 (else
	  (values def "" "" ""))))
   
   (define (deffnx? command)
      (match-case command
	 ((deffnx . ?-) #t)
	 (else #f)))
   
   (define (deffnx commands)
      (cond
	 ((null? commands)
	  '())
	 ((deffnx? (car commands))
	  (multiple-value-bind (name args rest kind)
	     (parse-deffn (cadr (car commands)))
	     (if (and (pair? (cdr commands)) (deffnx? (cadr commands)))
		 (<TEXINFO:DEFFN> :%context %this
		    :class "deffn deffnx"
		    :kind kind
		    :name name
		    :args args
		    :rest rest
		    (deffnx (cdr commands)))
		 (<TEXINFO:DEFFN> :%context %this
		    :kind kind
		    :class "deffn deffnx-last"
		    :name name
		    :args args
		    :rest rest
		    (cdr commands)))))
	 (else
	  commands)))
   
   (multiple-value-bind (name args rest kind)
      (parse-deffn def)
      (<TEXINFO:DEFFN> :%context %this
	 :class (if (and (pair? commands) (deffnx? (car commands)))
		    "deffn deffnx-first"
		    "deffn")
	 :kind kind
	 :name name
	 :args args
	 :rest rest
	 (deffnx commands))))

;*---------------------------------------------------------------------*/
;*    defun ...                                                        */
;*---------------------------------------------------------------------*/
(define (defun def commands)
   (generic-def def commands "function"))

;*---------------------------------------------------------------------*/
;*    defmethod ...                                                    */
;*---------------------------------------------------------------------*/
(define (defmethod def commands)
   (generic-def def commands "method"))

;*---------------------------------------------------------------------*/
;*    defmac ...                                                       */
;*---------------------------------------------------------------------*/
(define (defmac def commands)
   (generic-def def commands "macro"))

;*---------------------------------------------------------------------*/
;*    defvar ...                                                       */
;*---------------------------------------------------------------------*/
(define (defvar def commands)
   (generic-def def commands "variable"))

;*---------------------------------------------------------------------*/
;*    defopt ...                                                       */
;*---------------------------------------------------------------------*/
(define (defopt def commands)
   (generic-def def commands "user option"))

;*---------------------------------------------------------------------*/
;*    defspec ...                                                      */
;*---------------------------------------------------------------------*/
(define (defspec def commands)
   (generic-def def commands "special form"))

;*---------------------------------------------------------------------*/
;*    generic-def ...                                                  */
;*---------------------------------------------------------------------*/
(define (generic-def def commands kind)
   (define (make-def rest)
      `(list (table :width 100.
		    (tr (td (it ,rest))
			(td :align 'right ,kind)))))
   (define (make-def-title title)
      (make-def (stringify title)))
   `(list (frame :width 100.
		 :margin 10
		 ,(make-def-title def)
		 ,@(map (lambda (x)
			   (match-case x
			      ((generic-defx . ?rest)
			       (make-def-title x))
			      (else
			       x)))
			commands))
	  (linebreak 1)))

;*---------------------------------------------------------------------*/
;*    ref ...                                                          */
;*---------------------------------------------------------------------*/
(define (ref cmd REF commands config)
   (let ((s (apply string-append commands)))
      (<A> :class "texinfo"
	 :href (format "#~a"
		  (if (string-index s "\n")
		      (pregexp-replace* "\n" s " ")
		      s))
	 commands)))

;*---------------------------------------------------------------------*/
;*    xref ...                                                         */
;*---------------------------------------------------------------------*/
(define (xref commands config)
   (let* ((s (apply string-append (filter string? commands)))
	  (i (string-index-right s #\,))
	  (s (if i (substring s (+fx i 1) (string-length s)) s)))
      (ref 'xref 'xref (list s) config)))

(define (ref-old cmd REF commands config)
   (let* ((str (apply string-append commands))
	  (unspace (lambda (s)
			  (if (string? s)
			      (string-trim s #\space)
			      s)))
	  (w0 (unspace (nthword2 str 0 #\,)))
	  (w1 (unspace (nthword2 str 1 #\,)))
	  (w2 (unspace (nthword2 str 2 #\,)))
	  (w3 (nthword2 str 3 #\,)))
      (cond
	 ((not (string? w0))
	  (error "@ref" "Illegal reference" `(,cmd ,(car REF))))
	 ((not (or w1 w2 w3))
	  ;; plain reference to a local node
	  `(ref :mark ,(string-char-replace w0 #\Newline #\Space)))
	 ((and (string? w2) (assoc w2 (config-sui config)))
	  ;; a reference to another Skribe document
	  (let ((cell (cdr (assoc w2 (config-sui config))))
		(body (cond
			 ((or (pair? w1)
			      (and (string? w1) (>fx (string-length w1) 0)))
			  w1)
			 ((and (string? w0) (>fx (string-length w0) 0))
			  (string-append (prefix w2) ", " w0))
			 ((pair? w0)
			  (cons (string-append (prefix w2) ", ") w0))
			 (else
			  (prefix w2)))))
	     (if (and (string? w0) (>fx (string-length w0) 0))
		 `(ref :skribe ,cell :mark ,w0 :text ,body)
		 `(ref :skribe ,cell :text ,body))))
	 ((string? w3)
	  ;; a pure tex reference
	  (let* ((base (string-append "info-file `" w3 "'"))
 		 (ebase (string-append base ", " (if w2 w2 w0))))
	     (string-char-replace ebase #\Newline #\Space)))
	 (else
	  ;; a reference with a customized text
	  (let* ((user-title1 (if w2 w2 w0))
		 (user-title2 (if (and (string? w1)
				       (>fx (string-length w1) 0))
				  (string-append "(" w1 "): " user-title1)
				  user-title1)))
	     `(ref :mark
		   ,(string-char-replace w0 #\Newline #\Space)
		   :text
		   ,(string-char-replace user-title2 #\Newline #\Space)))))))

;*---------------------------------------------------------------------*/
;*    inforef ...                                                      */
;*---------------------------------------------------------------------*/
(define (inforef commands)
   (let* ((str (apply string-append commands))
	  (w0 (nthword str 0 #\,))
	  (w1 (nthword str 1 #\,))
	  (w2 (nthword str 2 #\,)))
      (cond
	 ((not (string? w0))
	  (error "@ref" "Illegal reference" 'inforef))
	 ((not (or w1 w2))
	  ;; plain reference to a local node
	  `(ref :mark ,(string-char-replace w0 #\Newline #\Space)))
	 ((string? w2)
	  ;; a pure tex reference
	  (let* ((base (string-append "info-file `" w2 "'"))
		 (ebase (string-append base ", " (if w2 w2 w0))))
	     (string-char-replace ebase #\Newline #\Space)))
	 (else
	  ;; a reference with a customized text
	  (let* ((user-title1 (if w2 w2 w0))
		 (user-title2 (if (and (string? w1)
				       (>fx (string-length (string-trim w1 #\Space)) 0))
				  (string-append "(" w1 "): " user-title1)
				  user-title1)))
	     `(ref :mark
		   ,(string-char-replace w0 #\Newline #\Space)
		   :text
		   ,(string-char-replace user-title2 #\Newline #\Space)))))))

;*---------------------------------------------------------------------*/
;*    math ...                                                         */
;*    -------------------------------------------------------------    */
;*    The math handling is extremelly weak. We only take care to       */
;*    _ and ^ that are replaced with (sub ...) and (sup ...).          */
;*---------------------------------------------------------------------*/
(define (math cmds)
   (let* ((str (apply string-append cmds))
	  (len (string-length str))
	  (len-1 (-fx len 1)))
      (let loop ((s 0)
		 (r 0)
		 (acc '()))
	 (if (>=fx r len-1)
	     (let ((l (reverse!
		       (if (=fx s len) acc (cons (substring str s len) acc)))))
		(cond
		   ((null? l)
		    "")
		   ((null? (cdr l))
		    (car l))
		   (else
		    `(list math ,@l))))
	     (let ((c (string-ref str r)))
		(case c
		   ((#\_ #\^)
		    (let ((sub `(,(if (char=? c #\_) 'sub 'sup)
				 ,(string (string-ref str (+fx r 1))))))
		       (if (=fx s r)
			   (loop (+fx r 2)
				 (+fx r 2)
				 (cons sub acc))
			   (loop (+fx r 2)
				 (+fx r 2)
				 (cons* sub (substring str s r) acc)))))
		   (else
		    (loop s (+fx r 1) acc))))))))
      
;*---------------------------------------------------------------------*/
;*    prgm ...                                                         */
;*---------------------------------------------------------------------*/
(define (prgm lg bg body)
   `(center
     (color :bg ,bg :width *skribeinfo-prgm-width*
	    (prog :line #f (source :language ,lg ,@body)))))
	   
;*---------------------------------------------------------------------*/
;*    string-char-replace ...                                          */
;*---------------------------------------------------------------------*/
(define (string-char-replace str1 c1 c2)
   (let* ((len (string-length str1))
	  (str2 (make-string len)))
      (let loop ((r 0))
	 (if (=fx r len)
	     str2
	     (let ((c (string-ref str1 r)))
		(if (char=? c c1)
		    (string-set! str2 r c2)
		    (string-set! str2 r c))
		(loop (+fx r 1)))))))
		 
;*---------------------------------------------------------------------*/
;*    Indexes                                                          */
;*---------------------------------------------------------------------*/
(define *indexes* '("cp" "fn" "vr" "ky" "pg" "tp"))

(define *merged-indexes*
   (map (lambda (cell) (list cell cell)) *indexes*))

;*---------------------------------------------------------------------*/
;*    printindex ...                                                   */
;*---------------------------------------------------------------------*/
(define (printindex kind)
   (let ((indexes (assoc kind *merged-indexes*)))
      (if (pair? indexes)
	  `(the-index :column *skribeinfo-index-column* ,@(cdr indexes))
	  (error "printindex" "Illegal index" kind))))

;*---------------------------------------------------------------------*/
;*    to-ident ...                                                     */
;*---------------------------------------------------------------------*/
(define (to-ident str)
   (if (string-index str "`'")
       (pregexp-replace* "[`']" str "")
       str))

;*---------------------------------------------------------------------*/
;*    index-entry ...                                                  */
;*---------------------------------------------------------------------*/
(define (index-entry index val)
   (cond
      ((string? val)
       (<SPAN> :class (string-append "texinfo anchor index index-" index)
	  :id (to-ident val)))
      (else
       (match-case val
	  (((? string?))
	   (<SPAN> :class (string-append "texinfo anchor index index-" index)
	      :id (to-ident (car val))))
	  (((?opt (and ?str (? string?))))
	      (<SPAN> :class (string-append "texinfo anchor index index-" index)
		 :id (to-ident str)
		 val))
	  (((?opt (and ?str1 (? string?)) (and ?str2 (? string?))))
	   (<SPAN> :class (string-append "texinfo anchor index index-" index)
	      :id (to-ident (string-append str1 str2))
	      val))
	  ((?opt (and ?str1 (? string?)) (and ?str2 (? string?)))
	   (<SPAN> :class (string-append "texinfo anchor index index-" index)
	      :id (to-ident (string-append str1 str2))
	      val))
	  (((? (lambda (x) (isa? x xml-element))))
	   (with-access::xml-element (car val) (body)
	      (index-entry index (car body))))
	  (else
	   (error "index-entry"
		  "Illegal index entry (should be a string)"
		  val))))))
	   
;*---------------------------------------------------------------------*/
;*    merge-index ...                                                  */
;*---------------------------------------------------------------------*/
(define (merge-index l1 l2 fun)
   (cond
      ((not (member l2 *indexes*))
       (error fun "Illegal index" l2))
      ((not (member l1 *indexes*))
       (error fun "Illegal index" l1))
      (else
       (let ((cell (assoc l2 *merged-indexes*)))
	  (set-cdr! cell (cons l1 (cdr cell)))))))

;*---------------------------------------------------------------------*/
;*    syncodeindex ...                                                 */
;*---------------------------------------------------------------------*/
(define (syncodeindex l1 l2)
   (merge-index l1 l2 'syncodeindex))

;*---------------------------------------------------------------------*/
;*    synindex ...                                                     */
;*---------------------------------------------------------------------*/
(define (synindex l1 l2)
   (merge-index l1 l2 'synindex))

;*---------------------------------------------------------------------*/
;*    fontify-code ...                                                 */
;*---------------------------------------------------------------------*/
(define (fontify-code lines lang::bstring this scope fontifier id)
   
   (define (fontify lines lang)
      (let ((f (when (isa? fontifier JsObject)
		  (js-get fontifier lang this))))
	 (if (js-function? f)
	     (js-call1 this f (js-undefined)
		(js-stringlist->jsstring lines))
	     lines)))
   
   (define (flatten lst)
      (if (every string? lst)
	  lst
	  (let flatten ((lst lst)
			(res '()))
	     (cond
		((null? lst)
		 (reverse! res))
		((pair? (car lst))
		 (flatten (append (car lst) (cdr lst)) res))
		((string? (car lst))
		 (flatten (cdr lst) (cons (xml-string-decode (car lst)) res)))
		((isa? (car lst) xml-element)
		 (with-access::xml-element (car lst) (body)
		    (flatten (append body (cdr lst)) res)))
		((isa? (car lst) xml-verbatim)
		 (with-access::xml-verbatim (car lst) (data)
		    (flatten (cdr lst) (cons data res))))
		(else
		 (flatten (cdr lst) (cons (format "__~s__" (car lst)) res)))))))

   (fontify (flatten lines) (js-string->jsstring lang)))

;*---------------------------------------------------------------------*/
;*    The return value for dynamic-load                                */
;*---------------------------------------------------------------------*/
hopscript
