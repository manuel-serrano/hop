;*=====================================================================*/
;*    .../project/hop/3.2.x/node_modules/hopc/lib/_js2scheme.hop       */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Tue Jul 17 09:48:30 2018                          */
;*    Last change :  Fri Jul 20 18:41:12 2018 (serrano)                */
;*    Copyright   :  2018 Manuel Serrano                               */
;*    -------------------------------------------------------------    */
;*    JS2Scheme wrapper.                                               */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _js2scheme
   
   (library hopscript hop hopwidget nodejs js2scheme)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject))

   (static (class J2SParser::JsObject
	      (plugins::pair-nil (default (list (cons #f #f)))))))
	   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   
   (define exports (js-get module 'exports %this))

   (define controller #f)
      
   (define parse
      (js-make-function %this
	 (lambda (this path)
	    (if (isa? this J2SParser)
		(let ((filename (js-tostring path %this)))
		   (if (file-exists? filename)
		       (with-access::J2SParser this (plugins)
			  (call-with-input-file filename
			     (lambda (ip)
				(set! controller #f)
				(j2s-parser ip `(:debug ,(bigloo-debug))
				   plugins))))
		       (raise
			  (instantiate::&io-file-not-found-error
			     (proc "parse")
			     (msg "file not found")
			     (obj filename)))))
		(js-raise-type-error %this 
		   "js->ast: not a parser ~a" this)))
	 1 'parse))

   (define (token->js token)
      (with-access::JsGlobalObject %this (js-object)
	 (let ((tok (js-new0 %this js-object)))
	    (js-bind! %this tok 'type
	       :value (symbol->string! (car token))
	       :writable #f)
	    (js-bind! %this tok 'value
	       :value (cond
			 ((symbol? (cdr token))
			  (js-string->jsstring (symbol->string (cdr token))))
			 ((string? (cdr token))
			  (js-string->jsstring (cdr token)))
			 (else
			  (cdr token)))
	       :writable #f)
	    (js-bind! %this tok 'filename
	       :value (js-string->jsstring (cadr (cer token)))
	       :writable #f)
	    (js-bind! %this tok 'pos
	       :value (caddr (cer token))
	       :writable #f)
	    (js-bind! %this tok 'location
	       :value (cer token)
	       :writable #f
	       :enumerable #f)
	    tok)))
   
   (define parser-prototype
      (with-access::JsGlobalObject %this (js-object)
	 (let ((obj (js-new0 %this js-object)))
	    (js-bind! %this obj 'parse
	       :value parse
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'addPlugin
	       :value (js-make-function %this
			 (lambda (this key parser)
			    (with-access::J2SParser this (plugins)
			       (set-cdr! plugins
				  (cons
				     (cons (string->symbol
					      (js-tostring key %this))
					(lambda (tok ctrl)
					   (set! controller ctrl)
					   (js->ast %this
					      (js-call1 %this parser this
						 (token->js tok)))))
				     (cdr plugins)))))
			 2 'addPlugin)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'removePlugin
	       :value (js-make-function %this
			 (lambda (this key)
			    (with-access::J2SParser this (plugins)
			       (let* ((k (string->symbol
					    (js-tostring key %this)))
				      (c (assq k plugins)))
				  (set! plugins (delete! c plugins)))))
			 2 'removePlugin)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'peekToken
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js
				   ((vector-ref controller 2)))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'peekToken)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'consumeToken
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js
				   ((vector-ref controller 3)
				    (string->symbol
				       (js-tostring token %this))))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'consumeToken)
	       :writable #f
	       :enumerable #t)
	    
	    (js-bind! %this obj 'consumeAny
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				(token->js ((vector-ref controller 4)))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'consumeAny)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseExpression
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				((vector-ref controller 5) #f #f)
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'parseExpression)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseStatement
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				((vector-ref controller 6))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'parseStatement)
	       :writable #f
	       :enumerable #t)
	    (js-bind! %this obj 'parseBlock
	       :value (js-make-function %this
			 (lambda (this token)
			    (if (vector? controller)
				((vector-ref controller 7))
				(js-raise-type-error %this
				   "detached plugin parser" this)))
			 1 'parseBlock)
	       :writable #f
	       :enumerable #t)
	    (for-each (lambda (s)
			 (js-bind! %this obj s
			    :value (symbol->string! s) :writable #f))
	       '(SEMICOLON COMMA in LBRACE RBRACE LPAREN RPAREN ID DOLLAR))
	    (js-bind! %this obj 'ELSE :value "else" :writable #f)
	    obj)))

   (with-access::JsGlobalObject %this (js-function-prototype)
      (js-bind! %this exports 'Parser
	 :value (js-make-function %this (lambda (this) (js-undefined)) 0 'Parser
		   :__proto__ js-function-prototype
		   :prototype parser-prototype
		   :construct (lambda (_)
				 (instantiate::J2SParser
				    (__proto__ parser-prototype)
				    (cmap (instantiate::JsConstructMap))
				    (plugins (list (cons #f #f))))))
	 :writable #f :enumerable #t))
   
   (js-bind! %this exports 'compile
      :value (js-make-function %this
		(lambda (this ipath opath)
		   (let ((tgt (j2s-compile ipath "/tmp")))
		      (if (eq? opath (js-undefined))
			  (js-string->jsstring 
			     (call-with-output-string
				(lambda (op)
				   (pp tgt op))))
			  (call-with-output-file (js-tostring opath %this)
			     (lambda (op)
				(pp tgt op)
				opath)))))
		2 'compile)
      :writable #f
      :enumerable #t))
			 
;*---------------------------------------------------------------------*/
;*    js->ast ...                                                      */
;*---------------------------------------------------------------------*/
(define (js->ast %this n)

   (define (symbol-field? clazz f)
      (or (eq? (class-field-type f) 'symbol)
	  (and (eq? clazz J2SFun) (eq? (class-field-name f) 'idthis))))
   
   (define (jsobject->node js)
      (let* ((cname (js-tostring (js-get js '__node__ %this) %this))
	     (clazz (find-class (string->symbol cname)))
	     (ctor (class-constructor clazz))
	     (inst ((class-allocator clazz)))
	     (fields (class-all-fields clazz)))
	 ;; instance fields
	 (let loop ((i (-fx (vector-length fields) 1)))
	    (when (>=fx i 0)
	       (let* ((f (vector-ref-ur fields i))
		      (n (class-field-name f)))
;* 		  (tprint "c=" cname " n=" n                           */
;* 		     " " (typeof (js-get js n %this)) "/"              */
;* 		     (class-field-type f))                             */
		  (cond
		     ((js-has-property js n %this)
		      (let ((v (js->node (js-get js n %this))))
			 ((class-field-mutator f)
			  inst
			  (cond
			     ((eq? (class-field-type f) 'symbol)
			      (if (string? v)
				  (string->symbol v)
				  (js-raise-type-error %this 
				     (format "js->ast: bad field type ~a.~a, string expected, ~~a provided"
					cname n)
				     (typeof v))))
			     ((symbol-field? clazz f)
			      (if (string? v)
				  (string->symbol v)
				  v))
			     (else
			      v)))))
		     ((class-field-default-value? f)
		      ((class-field-mutator f)
		       inst (class-field-default-value f)))
		     ((not (member "nojson" (class-field-info f)))
		      (error "js->ast"
			 (format "Missing field \"~a\"" n) cname)))
		  (loop (-fx i 1)))))
	 ;; constructor
	 (when (procedure? ctor) ctor inst)
	 inst))

   (define (js->node n)
      (cond
	 ((isa? n J2SNode)
	  n)
	 ((isa? n JsString)
	  (js-jsstring->string n))
	 ((isa? n JsArray)
	  (map! (lambda (c) (js->node (car c))) (jsarray->list n %this)))
	 ((isa? n JsObject)
	  (jsobject->node n))
	 (else
	  n)))

   (js->node n))

;*---------------------------------------------------------------------*/
;*    ast->js ...                                                      */
;*---------------------------------------------------------------------*/
(define (ast->js ast %this)
   (if (pair? ast)
       (js-vector->jsarray (list->vector ast) %this)
       ast))
