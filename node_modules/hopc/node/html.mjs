/*=====================================================================*/
/*    serrano/prgm/project/hop/hop/node_modules/hopc/node/html.mjs     */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sun Sep 17 16:21:38 2023                          */
/*    Last change :  Sat Apr 13 08:28:39 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    HTML parser                                                      */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { configGet, configAdd } from "./config.mjs";
import { Lexer, makePortLoc, Location, read_rp, locOffset } from "./reader.mjs";
import { J2SNode, J2SExpr, J2SString, J2SUndefined, J2SCall, J2SDataPropertyInit, J2SObjInit } from "./ast.mjs";
import { tokenType, tokenValue, tokenLoc, Token } from "./token.mjs";
import { inputPortName, inputPortPosition, } from "./utils.mjs";
import { nullp, pairp, cons, car, cdr, list, length,
	 reverse$, reverse, append,
	 map, map$, find, filter, filterMap, forEach, every } from "./list.mjs";
import { j2sParser, j2sTagtoexpr } from "./parser.mjs";
import { $ioParseError } from "./error.mjs";
import { fileURLToPath, pathToFileURL } from 'node:url';
import { dirname } from 'node:path';

/*---------------------------------------------------------------------*/
/*    htmlParser ...                                                   */
/*---------------------------------------------------------------------*/
export function htmlParser(port, conf, parser, plugins, tag, sep) {
   const lang = configGet(conf, "language", "hopscript");

   if (tag) {
      const xmlGrammar = new XMLLexer(/* stack */ null,
				      /* stricttag */ lang === "hopscript",
				      /* strictattr */ false,
				      /* decoder */ x => x,
				      /* encoding */ undefined,
				      /* lang */ lang,
				      /* conf */ conf,
				      /* parser */ parser,
				      /* plugins */ plugins);
      // move at the open tag location
      port.offset = tokenLoc(tag).offset - port.shiftOffset;
      return read_rp(xmlGrammar, port);
   } else {
      while (true) {
	 const xmlGrammar = new XMLLexer(/* stack */ null,
					 /* stricttag */ lang === "hopscript",
					 /* strictattr */ false,
					 /* decoder */ x => x,
					 /* encoding */ undefined,
					 /* lang */ lang,
					 /* conf */ conf,
					 /* parser */ parser,
					 /* plugins */ plugins);
					 
	 const v = read_rp(xmlGrammar, port);

	 if (v instanceof J2SString) {
	    if (v.value.match(/[^ \n\t]/)) {
	       return v;
	    }
	 } else {
	    return v;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    XMLLexer ...                                                     */
/*---------------------------------------------------------------------*/
/* @sealed */
class XMLLexer extends Lexer {
   #stack;
   #stricttag;
   #strictattr;
   #decoder;
   #encoding;
   #lang;
   #conf;
   #parser;
   #plugins;

   static xmlRules = [
      {rx: /[ \t\n\r]+/y, type: "BLANK"},
      {rx: /[ \t]*[\n][ \t]*/y, type: "NEWLINE"},
      {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.][a-zA-Z0-9:_.-]*>/y, type: "OHTML"},
      {rx: /<\/[a-zA-Z!?][a-zA-Z0-9:_.][a-zA-Z0-9:_.-]*>/y, type: "CHTML"},
      {rx: /<[a-zA-Z!?][a-zA-Z0-9:_.][a-zA-Z0-9:_.-]*[ \n\t\r]/y, type: "OTAG"},
      {rx: /<[_0-9a-zA-Z][0-9a-zA-Z_.:]*\/>/y, type: "HTML"},
      {rx: /(?:[^<$~]|[$~][^{])+/y, type: "STRING"},
      {rx: /[$]{/y, type: "DOLLAR"},
      {rx: /~{/y, type: "TILDE"},
      {rx: /<!--(?:[^-]|-[^-]|--[^>]\n)+[-]*->/my, type: "HTMLCOMMENT"}
   ];
   
   constructor(stack, stricttag, strictattr, decoder, encoding, lang, conf, parser, plugins) {
      super(XMLLexer.xmlRules);
      this.#stack = stack;
      this.#stricttag = stricttag;
      this.#strictattr = strictattr;
      this.#decoder = decoder;
      this.#encoding = encoding;
      this.#lang = lang;
      this.#conf = conf;
      this.#parser = parser;
      this.#plugins = plugins;
   }

   eof(port) {
      return new Token("EOF", "eof", makePortLoc(port));
   }

   pushIgnore(node) {
      this.#stack = cons(node, this.#stack);
      return { res: false, ignore: true };
   }

   pushNodeIgnore(val) {
      if (this.#stack === null) {
	 return {res: val, ignore: false};
      } else {
	 return this.pushIgnore(val);
      }
   }

   openTag(type, sym, attributes, port) {
      const prop = htmlElementsProperties[sym];
      let scriptParser = false;

      if (prop && prop.empty) {
	 const tag = new Token(type, sym, makePortLoc(port));
	 const node = makeDomCreate(tag, attributes, null, this.#lang, this.#conf);
	 return this.pushNodeIgnore(node);
      } else if (prop && prop.script && (scriptParser = scriptParsers[scriptType(attributes)])) {
	 const tag = new Token(type, sym, makePortLoc(port));
	 const script = scriptParser(attributes, port, this.#conf, this.#plugins);
	 const node = makeDomCreate(tag, attributes, cons(script, null), this.#lang, this.#conf);
	 return this.pushNodeIgnore(node);
      } else {
	 const tag = new Token(type, sym, makePortLoc(port));
	 const el = new Element(tag, attributes, prop && prop.children);
	 const s = findSpecial(this.#stack);

	 if (s) {
	    const sp = s.prop;
	    const spchd = sp && sp.children;

	    if (spchd === "inline") {
	    } else if (spchd === "flow") {
	    } else if (spchd instanceof Array) {
	       if (spchd.indexOf(sym) >= 0) {
		  console.error("not implemented");
	       }
	    }
	 }

	 return this.pushIgnore(el);
      }
   }

   match(port, val, rule) {
      switch (rule.type) {
	 case "BLANK":
	 case "STRING": {
	    const props = {
	       escape: ["escape"],
	       val: val.replace(/\n/g, "\\n"),
	       loc: makePortLoc(port)
	    }
	    port.offset += val.length;
	    return this.pushIgnore(new J2SString(props));
	 }
	    
	 case "HTML": {
	    const sym = val.substring(0, val.length - 1).toUpperCase();
	    const tag  = new Token(sym, sym, makePortLoc(port));
	    port.offset += val.length;
	    return this.pushIgnore(makeDomCreate(tag, null, null, this.#lang, this.#conf));
	 }
	    
	 case "OHTML": {
	    const str = val.toUpperCase();
	    port.offset += val.length;
	    return this.openTag("OHTML", str, null, port);
	 }
	    
	 case "CHTML": {
	    const sym = "<" + val.substring(2, val.length).toUpperCase();
	    port.offset += val.length;
	    if (htmlEmptyElementp(sym)) {
	       return  { res: "", ignore: true };
	    } else {
	       this.#stack = reduceStackUpTo(this.#stack, sym, this.#lang, this.#conf, port, true);
	       if (this.#stack.cdr === null) {
		  return {res: this.#stack.car, ignore: false };
	       } else if (every(o => o instanceof J2SString && o.val.match(/[ \t\n]*/), this.#stack)) {
		  return { res: this.#stack.car, ignore: false };
	       } else {
		  return { res: "", ignore: true };
	       }
	    }
	 }
	    
	 case "OTAG": {
	    const t = val.substring(0, val.length - 1).toUpperCase();
	    const sym = t + ">";
	    let attr = null;
	    port.offset += val.length;

	    while (true) {
	       const obj = read_rp(new AttrLexer(), port);

	       if (obj instanceof J2SNode) {
		  attr = cons(obj, attr);
	       } else if (obj === ">") {
		  return this.openTag("HTML", sym, reverse$(attr), port);
	       } else if (obj === "/>") {
		  const tag = new Token("HTML", sym, makePortLoc(port));
		  return this.pushNodeIgnore(makeDomCreate(tag, reverse$(attr), null, this.#lang, this.#conf));
	       } else {
		  return xmlParseError("illegal character", obj, inputPortName(port), inputPortPosition(port));
	       }
	    }
	 }

	 case "TILDE": {
	    if (this.#lang === "html") {
	       const props = {
		  escape: ["escape"],
		  val: val,
		  loc: makePortLoc(port)
	       }
	       
	       return this.pushIgnore(new J2SString(props));
	    } else {
	       const node = htmlParseTilde(port, this.#conf, this.#plugins);
	       return this.pushNodeIgnore(node);
	    }
	 }
	    
	 case "DOLLAR": {
	    if (this.#lang === "html") {
	       const props = {
		  escape: ["escape"],
		  val: val,
		  loc: makePortLoc(port)
	       }
	       
	       return this.pushIgnore(new J2SString(props));
	    } else {
	       const node = htmlParseDollar(port, this.#conf, this.#plugins);
	       return this.pushNodeIgnore(node);
	    }
	 }

	 case "HTMLCOMMENT":
	    port.offset += val.length;
	    return { res: "", ignore: true };
	    
	 default:
	    console.error("DEFAULT...", rule.type);
      }
   }
}

/*---------------------------------------------------------------------*/
/*    AttrLexer ...                                                    */
/*---------------------------------------------------------------------*/
/* @sealed */
class AttrLexer extends Lexer {
   static attrRules = [
      {rx: /[ \t\n\r]+/y, type: "B"},
      {rx: /[a-zA-Z_][a-zA-Z_:-]*=/y, type: "J"},
      {rx: /[a-zA-Z_][a-zA-Z_:-]*/y, type: "I"},
      {rx: /\/?>/y, type: "C"},
      {rx: /[$]{/y, type: "D" },
   ];

   constructor() {
      super(AttrLexer.attrRules);
   }
   
   match(port, val, rule) {
      switch (rule.type) {
	 case "B": {
	    port.offset += val.length;
	    return { res: "", ignore: true };
	 }
	 case "J": {
	    const loc = makePortLoc(port);
	    const key = val.replace(/[ \t]*=/, "");
	    port.offset += val.length;
	    const obj = read_rp(new AttrValLexer(), port);
	    const props = {
	       escape: ["escape"],
	       val: key,
	       loc: loc
	    };
	    const name = new J2SString(props);
	    const res = new J2SDataPropertyInit({loc, name, val: obj});

	    return { res, ignore: false };
	 }
	 case "I": {
	    const loc = makePortLoc(port);
	    const key = val;
	    const name = new J2SString({
	       escape: ["escape"],
	       val: key,
	       loc: loc
	    });
	    const str = new J2SString({
	       escape: ["escape"],
	       val: "",
	       loc: makePortLoc(port)
	    });
	    port.offset += val.length;
	    const res = new J2SDataPropertyInit({loc, name, val: str});

	    return { res, ignore: false };
	 }
	 case "C": {
	    port.offset += val.length;
	    return { res: val, ignore: false };
	 }
	 case "D": {
	    const res = htmlParseDollar(port, {}, null);
	    if (res instanceof J2SObjInit) {
	       return { res: car(res.inits), ignore: false };
	    } else {
	       return { res, ignore: false };
	    }
	 }
	 default: 
	    return xmlParseError("Illegal attribute character", false, false,
				 makePortLoc(port));
      }
   }
}

/*---------------------------------------------------------------------*/
/*    AttrValLexer ...                                                 */
/*---------------------------------------------------------------------*/
/* @sealed */
class AttrValLexer extends Lexer {
   static attrValRules = [
      {rx: /[ \t\n\r]+/y, type: "B"},
      {rx: /"(?:[^"]|\\")+"/y, type: "S"},
      {rx: /'(?:[^']|\\')+'/y, type: "S"},
      {rx: /[_a-zA-Z0-9]+/y, type: "L"},
      {rx: /[^ ~$\t\n\r<>(){}[]@!\"']+/y, type: "S"},
      {rx: /[$]{/y, type: "$"},
      {rx: /~{/y, type: "~"},
   ];

   constructor() {
      super(AttrValLexer.attrValRules);
   }
   
   match(port, val, rule) {
      switch (rule.type) {
	 case "B": {
	    port.offset += val.length;
	    return { res: "", ignore: true };
	 }
	 case "S": {
	    port.offset += val.length;
	    const res = new J2SString({
	       escape: [],
	       loc: makePortLoc(port),
	       val: val.substring(1, val.length -1)});
	    return { res, ignore: false }
	 }
	 case "L": {
	    port.offset += val.length;
	    const res = new J2SString({
	       escape: [],
	       loc: makePortLoc(port),
	       val: val});
	    return { res, ignore: false }
	 }
	 case "$": {
	    const res = htmlParseDollar(port, {}, null);
	    return { res, ignore: false };
	 }
	 case "~": {
	    port.offset += val.length;
	    const res = htmlParseTilde(port, {}, null);
	    return { res, ignore: false };
	 }
	 default:
	    port.offset += val.length;
	    throw "html.mjs";
      }
   }
}

/*---------------------------------------------------------------------*/
/*    makeDomCreate ...                                                */
/*---------------------------------------------------------------------*/
function makeDomCreate(tag, attributes, body, lang, conf) {
   let attrs = null;
   const abody = null;

   forEach(x => {
      if (x instanceof J2SDataPropertyInit) {
	 attrs = cons(x, attrs);
      } else if (x instanceof J2SExpr) {
	 const loc = x.loc;
	 const val = new J2SString({loc, val: ""});
	 const xp = new J2SDataPropertyInit({loc, name: x, val});
	 attrs = cons(xp, attrs);
      } else {
	 return xmlParseError("wrong attribute", tag.value, cadr(loc), caddr(loc));
      }
   }, attributes);
   const loc = tag.loc;
   const inits = reverse$(attrs);
   let a = (inits === null)
      ? new J2SUndefined({loc, type: "undefined"})
      : new J2SObjInit({loc, inits});
   
   return new J2SCall({loc: loc,
		       fun: j2sTagtoexpr(tag, true),
		       thisargs: list(undefined),
		       args: cons(a, body)});
}

/*---------------------------------------------------------------------*/
/*    element ...                                                      */
/*---------------------------------------------------------------------*/
/* @sealed */
class Element {
   tag;
   attributes;
   prop;
   
   constructor(tag, attributes, prop) {
      this.tag = tag;
      this.attributes = attributes;
      this.prop = prop;
   }
}

/*---------------------------------------------------------------------*/
/*    htmlElementsProperties ...                                       */
/*---------------------------------------------------------------------*/
const htmlElementsProperties = {
   "<ADDRESS>": {block: true},
   "<AREA>": {empty: true},
   "<BASE>": {empty: true},
   "<BASEFONT>": {empty: true},
   "<BLOCKQUOTE>": {block: true},
   "<BR>": {empty: true},
   "<COL>": {empty: true},
   "<COLGROUP>": {chidren: ["<COL>"]},
   "<DIV>": {block: true},
   "<DL>": {block: true, children: ["<DD>", "<DT>"]},
   "<DD>": {item: true, children: "flow", "etag-optional": true},
   "<DT>": {item: true, children: "inline", "etag-optional": true},
   "<FIELDSET>": {block: true},
   "<FORM>": {block: true},
   "<FRAME>": {empty: true},
   "<HR>": {empty: true, block: true},
   "<H1>": {block: true},
   "<H2>": {block: true},
   "<H3>": {block: true},
   "<H4>": {block: true},
   "<H5>": {block: true},
   "<H6>": {block: true},
   "<IMG>": {empty: true},
   "<INPUT>": {empty: true},
   "<ISINDEX>": {empty: true},
   "<LI>": {"etag-optional": true},
   "<LINK>": {empty: true},
   "<META>": {empty: true},
   "<NOSCRIPT>": {block: true},
   "<OL>": {block: true},
   "<P>": {block: true, children: "inline", "etag-optional": true},
   "<PARAM>": {empty: true},
   "<PRE>": {block: true},
   "<SCRIPT>": {script: true},
   "<TABLE>": {block: true},
   "<UL>": {block: true}
};
   
/*---------------------------------------------------------------------*/
/*    htmlEmptyElements ...                                            */
/*---------------------------------------------------------------------*/
const htmlEmptyElements = [ "AREA", "BASE", "BASEFONT", "BR", "COL", "FRAME",
			    "HR", "IMG", "INPUT", "ISINDEX", "LINK",
			    "META", "PARAM" ];

/*---------------------------------------------------------------------*/
/*    findSpecial ...                                                  */
/*---------------------------------------------------------------------*/
function findSpecial(stack) {
   return find(e => false, stack);
}

/*---------------------------------------------------------------------*/
/*    htmlEmptyElementp ...                                            */
/*---------------------------------------------------------------------*/
function htmlEmptyElementp(tag) {
   return htmlEmptyElements.indexOf(tag) >= 0;
}

/*---------------------------------------------------------------------*/
/*    htmlPropertyEtagOptionalp ...                                    */
/*---------------------------------------------------------------------*/
function htmlPropertyEtagOptionalp(prop) {
   return prop["etag-optional"];
}
   
/*---------------------------------------------------------------------*/
/*    reduceStackUpTo ...                                              */
/*---------------------------------------------------------------------*/
function reduceStackUpTo(stack, ctag, lang, conf, port, stricttag) {
   
   function tagname(tag) {
      return tag.substring(1, tag.length - 1);
   }

   let stk = stack;
   let args = null;

   while (true) {
      if (stk === null) {
	 return xmlParseError("wrong closing tag", tagname(ctag), inputPortName(port), inputPortPosition(port));
      } else if (!(stk.car instanceof Element)) {
	 args = cons(stk.car, args);
	 stk = stk.cdr;
      } else if (stk.car.tag.value === ctag) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 const node = makeDomCreate(tag, attrs, args, lang, conf);
	 return cons(node, stk.cdr);
      } else if (htmlPropertyEtagOptionalp(stk.car.tag.value)) {
	 const tag = stk.car.tag;
	 const attrs = stk.car.attributes;
	 args = cons(makeDomCreate(tag, attrs, args, lang, conf), null);
	 stk = stk.cdr;
      } else if (stricttag) {
	 return xmlParseError(`tag mismatch: </${tagname(stk.car.tag.value)}> expected, </${tagname(ctag)}> provided`, undefined, inputPortName(port), inputPortPosition(port));
      } else {
	 return stk;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    scriptType ...                                                   */
/*---------------------------------------------------------------------*/
function scriptType(attributes, defaultType="javascript") {
   while (attributes !== null) {
      const x = attributes.car;
      
      if (x instanceof J2SDataPropertyInit) {
	 if (x.name instanceof J2SString && x.name.val === "type") {
	    if (x.val instanceof J2SString) {
	       return x.val.val;
	    }
	 } else {
	    attributes = attributes.cdr;
	 }
      } else {
	 attributes = attributes.cdr;
      }
   }
   return defaultType;
}

/*---------------------------------------------------------------------*/
/*    scriptTypeSet ...                                                */
/*---------------------------------------------------------------------*/
function scriptTypeSet(attributes, newtype) {
   while (attributes !== null) {
      const x = attributes.car;
      
      if (x instanceof J2SDataPropertyInit) {
	 if (x.name instanceof J2SString && x.name.val === "type") {
	    if (x.val instanceof J2SString) {
	       return x.val.val = newtype;
	    }
	 } else {
	    attributes = attributes.cdr;
	 }
      } else {
	 attributes = attributes.cdr;
      }
   }
}

/*---------------------------------------------------------------------*/
/*    htmlParseScript ...                                              */
/*---------------------------------------------------------------------*/
function htmlParseScript(port, conf, plugins, prefix) {
   port.buffer = prefix + port.buffer.substring(port.offset, port.buffer.length);
   port.shiftOffset += port.offset - prefix.length;
   port.offset = 0;
   const nconf = Object.assign({}, conf);
   nconf.parser = "script-expression";
   nconf.typescript = false;

   return j2sParser(port, nconf, plugins);
}
   
/*---------------------------------------------------------------------*/
/*    htmlParseScriptJS ...                                            */
/*---------------------------------------------------------------------*/
function htmlParseScriptJS(attributes, port, conf, plugins) {
   return htmlParseScript(port, conf, plugins, "~{");
}

/*---------------------------------------------------------------------*/
/*    htmlParseScriptHop ...                                           */
/*---------------------------------------------------------------------*/
function htmlParseScriptHop(attributes, port, conf, plugins) {
   const base = dirname(dirname(dirname(fileURLToPath(import.meta.url))));
   const prefix = `~{ import * as hop from '${conf?.hopBase ?? "/hop"}/0/client.mjs';`;

   scriptTypeSet(attributes, "module");
   return htmlParseScript(port, conf, plugins, prefix);
}

/*---------------------------------------------------------------------*/
/*    scriptParsers ...                                                */
/*---------------------------------------------------------------------*/
const scriptParsers = {
   javascript: htmlParseScriptJS,
   module: htmlParseScriptJS,
   hop: htmlParseScriptHop
}
/*---------------------------------------------------------------------*/
/*    htmlParseDollar ...                                              */
/*---------------------------------------------------------------------*/
function htmlParseDollar(port, conf, plugins) {
   const nconf = Object.assign({}, conf);
   nconf.parser = "dollar-expression";

   return j2sParser(port, nconf, plugins);
}

/*---------------------------------------------------------------------*/
/*    htmlParseTilde ...                                               */
/*---------------------------------------------------------------------*/
function htmlParseTilde(port, conf, plugins) {
   port.buffer = "~{" + port.buffer.substring(port.offset, port.buffer.length);
   port.shiftOffset += port.offset - 2;
   port.offset = 0;
   const nconf = Object.assign({}, conf);
   nconf.parser = "tilde-expression";

   return j2sParser(port, nconf, plugins);
}

/*---------------------------------------------------------------------*/
/*    xmlParseError ...                                                */
/*---------------------------------------------------------------------*/
function xmlParseError(msg, obj, name, pos) {
   throw new $ioParseError({proc: "xml-parse", msg: msg, obj: obj, fname: name, location: pos });
}

   

