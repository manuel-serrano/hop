/*=====================================================================*/
/*    .../prgm/project/hop/hop/node_modules/hopc/node/generate.mjs     */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Thu Nov  2 14:38:40 2023                          */
/*    Last change :  Mon Oct 14 10:31:05 2024 (serrano)                */
/*    Copyright   :  2023-24 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    Code generation from an Hop ast                                  */
/*=====================================================================*/
"use strict";

/*---------------------------------------------------------------------*/
/*    Import/Export                                                    */
/*---------------------------------------------------------------------*/
import { openSync, closeSync } from "fs";
import { encode as vlq } from "./base64-vlq.mjs";
import { readLines } from "@hop/readlines";
import { list2array, length, nullp, car, cdr, pairp } from "./list.mjs";
import { J2SNode, J2SProgram, J2SBlock, J2SLetBlock,
	 J2SImport, J2SImportName, J2SImportDynamic, J2SImportPath,
	 J2SExport, J2SExportDefault,
	 J2SRedirect, J2SRedirectNamespace,
	 J2SStmt, J2SStmtExpr, J2SNop,
	 J2SVarDecls, J2SDecl, J2SDeclInit, J2SDeclRest,
	 J2SExpr, J2SParen, J2SSequence, J2SCond,
	 J2SAccess, J2SSeq, J2SObjInit,
	 J2SFun, J2SArrow, J2SDeclFun, J2SDeclSvc, J2SReturn, J2SYield, 
	 J2SIf, J2SIfArgDefVal, J2SSwitch, J2SCase, J2SDefault, J2SCatch, J2STry, J2SThrow,
	 J2SFor, J2SForIn, J2SWhile, J2SDo, J2SBreak, J2SContinue,
	 J2SCall, J2SNew, 
	 J2SString, J2SUndefined, J2SNull, J2SBool, J2SNumber, J2SOctalNumber, J2SRegExp,
	 J2SArray, J2SArrayAbsent,
	 J2SUnresolvedRef, J2SRef, J2SHopRef,
	 J2SPropertyInit, J2SDataPropertyInit, J2SAccessorPropertyInit, J2SMethodPropertyInit,
	 J2SSpread, J2SDConsumer, J2SDProducer,
	 J2SAssig, J2SAssigOp, J2SPrefix, J2SPostfix,
	 J2SBindExit, J2SUnary, J2SBinary, J2STemplate,
	 J2SDeclClass, J2SClass, J2SClassElement,
	 J2SDollar, J2STilde,
	 TsInterface, TsInterfaceProperty, TsInterfacePropertyName,
	 TsType, TsTypeArray, TsTypeFunction, TsTypeBinary }
         from "./ast.mjs";

export { generate };

/*---------------------------------------------------------------------*/
/*    objToLocOffset ...                                               */
/*---------------------------------------------------------------------*/
function objToLocOffset(obj) {
   const loc = obj.loc;
   if (typeof obj === "number") {
      return obj;
   } else if ("offset" in loc) {
      return loc.offset;
   } else if (pairp(loc)) {
      return car(cdr(cdr(loc)));
   } else {
      return -1;
   }
}

/*---------------------------------------------------------------------*/
/*    generateLoc ...                                                  */
/*---------------------------------------------------------------------*/
function generateLoc(loc) {
   if (!loc) {
      return "undefined";
   } else if ("filename" in loc) {
      return `{filename: "${loc.filename}", offset: ${loc.offset}}`;
   } else if (pairp(loc)) {
      return `{filename: "${car(cdr(loc))}", offset: ${(car(cdr(cdr(loc))))}}`;
   } else {
      return "undefined";
   }
}

/*---------------------------------------------------------------------*/
/*    stringify ...                                                    */
/*---------------------------------------------------------------------*/
function stringify(str) {
   
   function purify(str) {
      return str.replace(/\\/g, "\\\\").replace(/'/g, "\\'").replace(/\n/g, "\\n");
   }
   
   return "'" + purify(str) + "'";
}

/*---------------------------------------------------------------------*/
/*    Fragment ...                                                     */
/*---------------------------------------------------------------------*/
class Fragment {
   #ctx;
   offset;
   val;
   
   constructor(conf, obj, ... val) {
      this.#ctx = conf.ctx;
      this.offset = objToLocOffset(obj);
      this.val = val;
      
      if (val.length === 0) {
	 throw {
	    message: "empty fragment",
	    obj: obj,
	    loc: obj.loc
	 }
      }
   }

   toString() {
      if (this.#ctx !== "client") {
	 // plain mode
	 return this.val.map(v => {
	    if (typeof v === "string") {
	       return v;
	    } else if (v instanceof Array) {
	       throw new Error("Fragment.toString - should not be here...");
	       return v.map(v => v.toString()).join("\n");
	    } else {
	       return v.toString();
	    }
	 }).join("");
      } else {
	 // client mode
	 return this.val.map(v => {
	    if (typeof v === "string") {
	       return stringify(v);
	    } else if (v instanceof Array) {
	       throw new Error("Fragment.toString - should not be here...");
	       return v.map(v => v.toString()).join("");
	    } else {
	       return v.toString();
	    }
	 }).join("+");
      }
   }

   mappings(source) {
      const fd = openSync(source, "r");
      const srclines = readLines(fd);
      const loclines = new Array(srclines.length).fill(0);
      closeSync(fd);

      // compute the starting and ending positions of each line
      for (let i = 0, offset = 0; i < srclines.length; i++) {
	 const len = srclines[i].length;
	 loclines[i] = { start: offset, end: offset + len, num: i };
	 offset += len + 1;
      }

      // accomodate the eof character
      loclines[srclines.length - 1].end++;
      
      let dstlines = [{}];
      let line = 0, col = 0;
      let f = this;

      function walk(e) {
	 // Walk recurisvely over a fragment and its children, computing
	 // the line number and column number of each fragment.
	 // Store in the DSTLINES array the mapping between line x col
	 // and fragment offset.

	 if (typeof e === "string") {
	    if (e === "\n") {
	       col = 0;
	       dstlines[++line] = {};
	    } else if (e.indexOf("\n") >= 0) {
	       const b = e.split("\n");
	       let i = 0;
	       for (; i < b.length - 1;  i++) {
		  walk(b[i]);
		  walk("\n");
	       }
	       walk(b[i]);
	    } else {
	       col += e.length;
	    }
	 } else if (typeof e === "array") {
	    for (let j = 0; j < e.length - 1; j++) {
	       walk(e[j]);
	       col = 0;
	       dstlines[++line] = {};
	    }
	    walk(e[e.length - 1]);
	 } else if (e instanceof Fragment) {
	    if (e.offset !== undefined) dstlines[line][col] = e.offset;

	    for (let f of e.val) {
	       walk(f);
	    }
	 } else if (e instanceof FragmentList) {
	    if (e.offset !== undefined) dstlines[line][col] = e.offset;
	    if (e.val.length > 0) {
	       for (let j = 0; j < e.val.length - 1; j++) {
		  walk(e.val[j]);
		  walk(e.sep);
	       }
	       walk(e.val[e.val.length - 1]);
	    }
	 } else {
	    walk(e.toString());
	 }
      }

      function findOriginalLocation(loc) {
	 // find the line info containing location loc
	 let line = loclines.find(l => loc <= l.end && loc >= l.start);

	 if (!line) {
	    console.error("SOURCEMAP ERROR, cannot find location",
			  loc, "source=", source);
	    console.error(loclines);
	    return { oline: 0, ocol: 0 };
	 }
	 
	 return { oline: line.num, ocol: loc - line.start };
      }

      let sourcemapGcol = 0, sourcemapOline = 0, sourcemapOcol = 0;
      
      function encode(line) {
	 // each fragment is:
	 //   - column in generated code
	 //   - corresponding source file
	 //   - line number in orignal code
	 //   - column in original code
	 const components = [];

	 // generated column counter is implicitly reset to 0 for each new line
	 sourcemapGcol = 0;
	 for (let k in line) {
	    if (line[k] === undefined) {
	       console.error("SOURCEMAP ERROR, wrong line", line);
	    }
	    const { oline: ol, ocol: oc } = findOriginalLocation(line[k]);
	    components.push(vlq(k - sourcemapGcol)
	       + "A"
	       + vlq(ol - sourcemapOline)
	       + vlq(oc - sourcemapOcol));
	    sourcemapGcol = k;
	    sourcemapOline = ol;
	    sourcemapOcol = oc;
	 }
	 if (components.length > 0) {
	    return components.join(",");
	 }
      }

      walk(this);

      return dstlines.map(encode).join(";");
   }
}
      
/*---------------------------------------------------------------------*/
/*    FragmentList ...                                                 */
/*---------------------------------------------------------------------*/
class FragmentList {
   #ctx;
   loc;
   val;
   sep;
   
   constructor(conf, obj, val, sep = ",") {
      this.#ctx = conf.ctx;
      this.offset = objToLocOffset(obj);
      this.val = val;
      this.sep = sep;
   }

   toString() {
      if (this.#ctx !== "client") {
	 // plain mode
	 return this.val.map(v => {
	    if (typeof v === "string") {
	       return v;
	    } else if (v instanceof Array) {
	       throw new Error("FragmentList.toString - should not be here...");
	       return v.map(v => v.toString()).join("\n");
	    } else {
	       return v.toString();
	    }
	 }).join(this.sep);
      } else {
	 // client mode
	 if (this.val.length === 0) {
	    return "''";
	 } else {
	    const str = this.val.map(v => {
	       if (typeof v === "string") {
		  return v;
	       } else if (v instanceof Array) {
		  throw new Error("FragmentList.toString - should not be here...");
		  return v.map(v => v.toString()).join("");
	       } else {
		  return v.toString();
	       }
	    }).join(`+${stringify(this.sep)}+`);

	    return str;
	 }
      }
   }
}

/*---------------------------------------------------------------------*/
/*    Conf ...                                                         */
/*---------------------------------------------------------------------*/
class Conf {
   ctx;
   parent;
   typescript;

   constructor(ctx, parent, typescript) {
      this.ctx = ctx;
      this.parent = parent;
      this.typescript = typescript;
   }
}

/*---------------------------------------------------------------------*/
/*    generate ...                                                     */
/*---------------------------------------------------------------------*/
const generate = (prog, conf = {}) => {
   return prog.generate(new Conf(conf.context || "server", null, conf.typescript));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SNode ...                                           */
/*---------------------------------------------------------------------*/
J2SNode.prototype.generate = function(conf) {
   throw("generate: "  + this.toString() + " not implemented,"
      + " $class=" + this.$class
      + " keys=" + Object.keys(this));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SNop ...                                            */
/*---------------------------------------------------------------------*/
J2SNop.prototype.generate = function(conf) {
   return ""; // MS 21jan2024
   // return ";";
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SProgram ...                                        */
/*---------------------------------------------------------------------*/
J2SProgram.prototype.generate = function(conf) {
   const nodes = list2array(this.nodes).map(n => n.generate(conf)).filter(x => x);
   const exports = list2array(this.exports).map(n => n.generate(conf)).filter(x => x);
   return new Fragment(conf, this, ...nodes.concat(exports));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SImport ...                                         */
/*---------------------------------------------------------------------*/
J2SImport.prototype.generate = function(conf) {
					   
   function importPath(self) {
      if (!(self.dollarpath instanceof J2SUndefined)) {
	 return new Fragment(conf, self, self.dollarpath.generate(conf));
      } else if (self.ipath instanceof J2SImportPath) {
	 return new Fragment(conf, self, "'", self.ipath.name, "'");
      } else if (typeof self.path === "string") {
	 return new Fragment(conf, self, "'", self.path, "'");
      } else {
	 throw `Generate J2SImport, wrong path ${self.path}`;
      }
   }

   function importModule(self, path) {
      if (nullp(self.names)) {
	 return new Fragment(conf, self, "import ", path, ";");
      } else if (car(self.names).id === "*") {
	 return new Fragment(conf, self, "import ",
			     self.types ? "type " : "",
			     car(self.names).generate(conf),
			     " from ", path, ";");
      } else {
	 return new Fragment(conf, self, "import ",
			     self.types ? "type { " : "{ ",
			     new FragmentList(conf, self, list2array(self.names).map(n => n.generate(conf)), ","), " } from ", path, ";");
      }
   }
   
   return importModule(this, importPath(this));
}

/*---------------------------------------------------------------------*/
/*    generate JJ2SImportName ...                                      */
/*---------------------------------------------------------------------*/
J2SImportName.prototype.generate = function(conf) {
   if (this.id === this.alias) {
      return new Fragment(conf, this, this.id);
   } else {
      return new Fragment(conf, this, `${this.id} as ${this.alias}`);
   }
}

/*---------------------------------------------------------------------*/
/*    generate JJ2SImportDynamic ...                                   */
/*---------------------------------------------------------------------*/
J2SImportDynamic.prototype.generate = function(conf) {
   return new Fragment(conf, this, "import(", this.path.generate(conf), ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SExport ...                                         */
/*---------------------------------------------------------------------*/
J2SExport.prototype.generate = function(conf) {
   if (this.id === this.alias) {
      return new Fragment(conf, this, `export { ${this.id} };`);
   } else {
      return new Fragment(conf, this, `export { ${this.id} as ${this.alias} };`);
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SExportDefault ...                                  */
/*---------------------------------------------------------------------*/
J2SExportDefault.prototype.generate = function(conf) {
   if (this.id === this.alias) {
      return new Fragment(conf, this, "export default ", this.expr.generate(conf), ";", "\n");
   } else {
      return new Fragment(conf, this, `export default as ${this.alias} `, this.expr.generate(conf), ";", "\n");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SRedirect ...                                       */
/*---------------------------------------------------------------------*/
J2SRedirect.prototype.generate = function(conf) {
   if (this.id === this.alias) {
      return new Fragment(conf, this, `export { ${this.id} } from \"${this.import.path}\";`, "\n");
   } else {
      return new Fragment(conf, this, `export { ${this.id} as ${this.alias} } from \"${this.import.path}\";`, "\n");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SRedirectNamespace ...                              */
/*---------------------------------------------------------------------*/
J2SRedirectNamespace.prototype.generate = function(conf) {
   if (this.alias === "*") {
      return new Fragment(conf, this, `export * from \"${this.path}\";`);
   } else {
      return new Fragment(conf, this, `export * as ${this.alias} from \"${this.path}\";`);
   }
}
/*---------------------------------------------------------------------*/
/*    generate ::J2SSeq ...                                            */
/*---------------------------------------------------------------------*/
J2SSeq.prototype.generate = function(conf) {
   return new Fragment(conf, this, ...list2array(this.nodes).map(d => d.generate(conf)));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SBlock ...                                          */
/*---------------------------------------------------------------------*/
J2SBlock.prototype.generate = function(conf) {
   return new Fragment(conf, this, "{", "\n",
		       new FragmentList(conf, this, list2array(this.nodes).map(d => d.generate(conf)), ""),
		       "}");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SLetBlock ...                                       */
/*---------------------------------------------------------------------*/
J2SLetBlock.prototype.generate = function(conf) {
   const decls = list2array(this.decls).map(d => d.generate(conf));
   const nodes = list2array(this.nodes).map(d => d.generate(conf));
   return new Fragment(conf, this, "{", "\n", new FragmentList(conf, this, decls, ""), new FragmentList(conf, this, nodes, ""), "}");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SVarDecls ...                                       */
/*---------------------------------------------------------------------*/
J2SVarDecls.prototype.generate = function(conf) {
   if (this.decls) {
      return new Fragment(conf, this, new FragmentList(conf, this, list2array(this.decls).map(d => d.generate(conf)), ""), "\n");
   } else {
      return new Fragment(conf, this, "");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDecl ...                                           */
/*---------------------------------------------------------------------*/
J2SDecl.prototype.generate = function(conf) {
   let binder = "var ";
   let sep = ";";
   let loc = objToLocOffset(this);
   let opt = this.optional ? "?" : "";
   const id = this.literal ? this.literal.generate(conf) : this.id;

   switch (this.binder) {
      case "let-opt":
      case "let": {
	 let loc = objToLocOffset(this);
	 if (this.writable) {
	    binder = "let ";
	 } else {
	    binder = "const ";
	 }
	 break;
      }
      case "param":
	 binder = "";
	 sep = "";
	 break;
      case "export":
	 binder = "export ";
	 break;
   }

   if (conf.typescript && this.utype) {
      const ty = generateType(this.utype, conf);
      if (ty !== "unknown") {
	 return new Fragment(
	    conf, this, binder, id, opt, ":", ty, sep);
      }
   }
   return new Fragment(conf, this, binder, id, sep);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDeclRest ...                                       */
/*---------------------------------------------------------------------*/
J2SDeclRest.prototype.generate = function(conf) {
   return new Fragment(conf, this, `...${this.id}`);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDeclInit ...                                       */
/*---------------------------------------------------------------------*/
J2SDeclInit.prototype.generate = function(conf) {
   let binder = "var ";
   let sep = ";";
   let loc = objToLocOffset(this);
   let opt = ""; // opt args with default value must not be marked with ?
   const id = this.literal ? this.literal.generate(conf) : this.id;

   switch (this.binder) {
      case "let-opt":
      case "let": {
	 let loc = objToLocOffset(this);
	 if (this.writable) {
	    binder = "let ";
	 } else {
	    binder = "const ";
	 }
	 break;
      }
      case "param":
	 binder = "";
	 sep = "";
	 break;
      case "export":
	 binder = "export ";
	 break;
   }

   if (conf.typescript && this.utype) {
      const ty = generateType(this.utype, conf);
      if (ty !== "unknown") {
	 return new Fragment(
	    conf, 
	    loc, binder,
	    new Fragment(
	       conf, loc, id, opt, ":", ty,
	       "=", this.val.generate(conf), sep));
      }
   }

   return new Fragment(
      conf, 
      this, binder,
      new Fragment(
	 conf, loc + binder.length, id, "=", this.val.generate(conf), sep));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDeclFun ...                                        */
/*---------------------------------------------------------------------*/
J2SDeclFun.prototype.generate = function(conf) {
   const binder = this.writable ? "let" : "const";
   return new Fragment(conf, this, `${binder} ${this.id} = `,
		       this.val.generate(conf), this.expression ? "" : ";");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDeclSvc ...                                        */
/*---------------------------------------------------------------------*/
J2SDeclSvc.prototype.generate = function(conf) {
   return new Fragment(conf, this, "const ", this.id, " = Service(",
		       this.val.generate(conf),
		       ",\"", this.id, "\")", this.expression ? "" : ";");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SCall ...                                           */
/*---------------------------------------------------------------------*/
J2SCall.prototype.generate = function(conf) {
   const f$class = this.fun.$class;
   const fun = this.fun.generate(conf);
   const args = new FragmentList(conf, this, list2array(this.args).map(n => n.generate(conf)));
   if (f$class === "J2SRef" || f$class === "J2SAccess" || f$class === "J2SUnresolvedRef") {
      return new Fragment(conf, this, fun, "(", args, ")");
   } else {
      return new Fragment(conf, this, "(", fun, ")", "(", args, ")");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SNew ...                                            */
/*---------------------------------------------------------------------*/
J2SNew.prototype.generate = function(conf) {
   const args = new FragmentList(conf, this, list2array(this.args).map(n => n.generate(conf)));
   return new Fragment(conf, this, "new ", this.clazz.generate(conf), "(", args, ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SUnresolvedRef ...                                  */
/*---------------------------------------------------------------------*/
J2SUnresolvedRef.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.id);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SRef ...                                            */
/*---------------------------------------------------------------------*/
J2SRef.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.decl.id);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SHopRef ...                                         */
/*---------------------------------------------------------------------*/
J2SHopRef.prototype.generate = function(conf) {
   switch (this.id) {
      case "%import-meta": return new Fragment(conf, this, "import.meta");
      default: return new Fragment(conf, this, this.id);
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SSequence                                           */
/*---------------------------------------------------------------------*/
J2SSequence.prototype.generate = function(conf) {
   return new Fragment(conf, this, "(", new FragmentList(conf, this, list2array(this.exprs).map(d => d.generate(conf))), ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SCond                                               */
/*---------------------------------------------------------------------*/
J2SCond.prototype.generate = function(conf) {
   return new Fragment(conf, this, "(", this.test.generate(conf), "?", this.then.generate(conf), ":", this.else.generate(conf), ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SParen                                              */
/*---------------------------------------------------------------------*/
J2SParen.prototype.generate = function(conf) {
   return new Fragment(conf, this, "(", this.expr.generate(conf), ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SAccess                                             */
/*---------------------------------------------------------------------*/
J2SAccess.prototype.generate = function(conf) {
   const field = this.field.generate(conf);
   const obj = this.obj.generate(conf);
   const m = this.field.$class === "J2SString" ? this.field.val.match(/^(#?[a-zA-Z_][a-zA-Z0-9_]*)$/) : false;

   if (m) {
      return new Fragment(conf, 
	 this, obj, new Fragment(conf, this.field, ".", m[1]));
   } else {
      return new Fragment(conf, 
	 this, obj, new Fragment(conf, this.field, "[", field, "]"));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2Sstring                                             */
/*---------------------------------------------------------------------*/
J2SString.prototype.generate = function(conf) {
   return new Fragment(conf, this, `'${this.val.replace(/'/g, "\\'")}'`);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SUndefined                                          */
/*---------------------------------------------------------------------*/
J2SUndefined.prototype.generate = function(conf) {
   return new Fragment(conf, this, "undefined");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SNull                                               */
/*---------------------------------------------------------------------*/
J2SNull.prototype.generate = function(conf) {
   return new Fragment(conf, this, "null");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SBool                                               */
/*---------------------------------------------------------------------*/
J2SBool.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.val);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SNumber ...                                         */
/*---------------------------------------------------------------------*/
J2SNumber.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.val);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SOctalNumber ...                                    */
/*---------------------------------------------------------------------*/
J2SOctalNumber.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.val === 0 ? "0" : "0" + this.val);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SRegExp ...                                         */
/*---------------------------------------------------------------------*/
J2SRegExp.prototype.generate = function(conf) {
   return new Fragment(conf, this, "/", this.val, "/", this.flags);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SStmtExpr ...                                       */
/*---------------------------------------------------------------------*/
J2SStmtExpr.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.expr.generate(conf), ";");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SObjInit ...                                        */
/*---------------------------------------------------------------------*/
J2SObjInit.prototype.generate = function(conf) {
   return new Fragment(conf, this, "{", new FragmentList(conf, this, list2array(this.inits).map(n => n.generate(conf))), "}");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SPropertyInit                                       */
/*---------------------------------------------------------------------*/
J2SPropertyInit.prototype.generate = function(conf) {
   const { name, val } = this;
   if (name instanceof J2SString || name instanceof J2SNumber) {
      return new Fragment(conf, this, name.generate(conf), ":", val.generate(conf));
   } else if (name instanceof J2SUndefined && val instanceof J2SSpread) {
      return new Fragment(conf, this, "...", val.expr.generate(conf));
   } else {
      return new Fragment(conf, this, "[", name.generate(conf), "]:", val.generate(conf));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDataPropertyInit                                   */
/*---------------------------------------------------------------------*/
J2SDataPropertyInit.prototype.generate = function(conf) {
   const name = this.name;
   if (name instanceof J2SString || name instanceof J2SNumber) {
      return new Fragment(conf, this, name.generate(conf), ":", this.val.generate(conf));
   } else {
      return new Fragment(conf, this, "[", name.generate(conf), "]:", this.val.generate(conf));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SArray ...                                          */
/*---------------------------------------------------------------------*/
J2SArray.prototype.generate = function(conf) {
   return new Fragment(conf, this, "[", new FragmentList(conf, this, list2array(this.exprs).map(e => e.generate(conf))), "]");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SArrayAbsent ...                                    */
/*---------------------------------------------------------------------*/
J2SArrayAbsent.prototype.generate = function(conf) {
   return new Fragment(conf, this, "");
}
   
/*---------------------------------------------------------------------*/
/*    generateFun ...                                                  */
/*---------------------------------------------------------------------*/
function generateFun(conf, id, keyword) {
   return new Fragment(conf, this, keyword, id ? id + " " : "", "(", new FragmentList(conf, this, list2array(this.params).map(n => n.generate(conf))), ") ", this.body.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SFun ...                                            */
/*---------------------------------------------------------------------*/
J2SFun.prototype.generate = function(conf) {
   
   function async(fun) {
      if (!fun.generator && fun.body instanceof J2SBlock) {
	 const nodes = fun.body.nodes;
	 if (nodes && nodes.cdr === null && nodes.car instanceof J2SReturn) {
	    const expr = nodes.car.expr;
	    if (expr instanceof J2SCall) {
	       const fun = expr.fun;
	       if (fun instanceof J2SHopRef) {
		  if (fun.id === "js-spawn") {
		     return expr.args.car;
		  }
	       }
	    }
	 }
      }
      return false;
   }

   const asy = async(this);

   if (asy) {
      asy.params = this.params;
      return new Fragment(conf, this, "async ", generateFun.call(asy, conf, this.decl instanceof J2SDecl ? this.decl.id : "", "function "));
   } else {
      return generateFun.call(this, conf, this.decl instanceof J2SDecl ? this.decl.id : "", "function ");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SArrow ...                                          */
/*---------------------------------------------------------------------*/
J2SArrow.prototype.generate = function(conf) {
   const args = new FragmentList(conf, this, list2array(this.params).map(n => n.generate(conf)));

   if (conf.typescript && this.rutype) {
      const ty = generateType(this.rutype, conf);
      if (ty !== "unknown") {
	 return new Fragment(conf, this, "(", args, "): ", ty, " => ", this.body.generate(conf));
      }
   }

   return new Fragment(conf, this, "(", args, ") => ", this.body.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SReturn ...                                         */
/*---------------------------------------------------------------------*/
J2SReturn.prototype.generate = function(conf) {
   return new Fragment(conf, this, "return ", this.expr.generate(conf), ";", "\n");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SYield ...                                          */
/*---------------------------------------------------------------------*/
J2SYield.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.await ? "await " : "yield ", this.expr.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SIf ...                                             */
/*---------------------------------------------------------------------*/
J2SIf.prototype.generate = function(conf) {
   if (this.else.$class === "J2SNop") {
      return new Fragment(conf, this, "if (", this.test.generate(conf), ") ",
			  this.then.$class === "J2SNop" ? ";" : this.then.generate(conf), "\n");
   } else {
      return new Fragment(conf, this, "if (", this.test.generate(conf), ") ",
			  this.then.$class === "J2SNop" ? ";" : this.then.generate(conf),
			  " else ", this.else.generate(conf), "\n");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SIfArgDefVal ...                                    */
/*---------------------------------------------------------------------*/
J2SIfArgDefVal.prototype.generate = function(conf) {
   // don't emit anything for the arg default value as it is
   // natively supported by the underlying JS engine
   return new Fragment(conf, this, "");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SSwitch ...                                         */
/*---------------------------------------------------------------------*/
J2SSwitch.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "switch (", this.key.generate(conf), ") {",
		       new FragmentList(conf, this, list2array(this.cases).map(n => n.generate(conf)), "\n"),
      "}");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SCase ...                                           */
/*---------------------------------------------------------------------*/
J2SCase.prototype.generate = function(conf) {
   return new Fragment(conf, this, "case ", this.expr.generate(conf), ": ", this.body.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDefault ...                                        */
/*---------------------------------------------------------------------*/
J2SDefault.prototype.generate = function(conf) {
   return new Fragment(conf, this, "default: ", this.body.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SCatch ...                                          */
/*---------------------------------------------------------------------*/
J2SCatch.prototype.generate = function(conf) {
   return new Fragment(conf, this, "catch (", this.param.generate(conf), ") ", this.body.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2STry                                                */
/*---------------------------------------------------------------------*/
J2STry.prototype.generate = function(conf) {
   return new Fragment(conf, this, "try ", this.body.generate(conf), this.catch.$class === "J2SNop" ? "" : this.catch.generate(conf), this.finally.$class === "J2SNop" ? "" : this.finally.generate(conf), "\n");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SThrow                                              */
/*---------------------------------------------------------------------*/
J2SThrow.prototype.generate = function(conf) {
   return new Fragment(conf, this, "throw ", this.expr.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    J2SFor ...                                                       */
/*---------------------------------------------------------------------*/
J2SFor.prototype.generate = function(conf) {
   let init = ""; 
   if (this.init instanceof J2SVarDecls) {
      const decls = list2array(this.init.decls);
      const decl0 = decls[0];
      init = new Fragment(conf, 
	 this.init,
	 (decl0.binder === "let" || decl0.binder === "let-opt") ? "let " : "var ",
			  new FragmentList(conf, this.init, decls.map(d => new Fragment(conf, d, d.id, "=", d.val.generate(conf)))));
   }
   return new Fragment(conf, 
      this, "for (",
      init, ";",
      this.test.generate(conf), ";",
      this.incr.generate(conf), ") ",
      this.body.generate(conf), "\n");
}

/*---------------------------------------------------------------------*/
/*    J2SForIn ...                                                     */
/*---------------------------------------------------------------------*/
J2SForIn.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "for (",
      this.lhs instanceof J2SVarDecls
      ? new Fragment(conf, this.lhs, "let ", this.lhs.decls.car.id)
	 : this.lhs.generate(conf),
      this.op === "in" ? " in " : " of ",
      this.obj.generate(conf),
      ") ",
      this.body.generate(conf),
      "\n");
}

/*---------------------------------------------------------------------*/
/*    J2SWhile ...                                                     */
/*---------------------------------------------------------------------*/
J2SWhile.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "while (", this.test.generate(conf), ")", this.body.generate(conf), "\n");
}
   
/*---------------------------------------------------------------------*/
/*    J2SDo ...                                                        */
/*---------------------------------------------------------------------*/
J2SDo.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "do ", this.body.generate(conf), " while (", this.test.generate(conf), ")", "\n");
}
   
/*---------------------------------------------------------------------*/
/*    J2SBreak ...                                                     */
/*---------------------------------------------------------------------*/
J2SBreak.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "break ", this.id ? this.id : "", ";", "\n");
}
   
/*---------------------------------------------------------------------*/
/*    J2SContinue ...                                                  */
/*---------------------------------------------------------------------*/
J2SContinue.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "continue ", this.id ?? "", ";", "\n");
}
   
/*---------------------------------------------------------------------*/
/*    generate ::J2SAssig ...                                          */
/*---------------------------------------------------------------------*/
J2SAssig.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.lhs.generate(conf), "=", this.rhs.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SAssigOp ...                                        */
/*---------------------------------------------------------------------*/
J2SAssigOp.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.lhs.generate(conf), this.op, "=", this.rhs.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SPrefix ...                                         */
/*---------------------------------------------------------------------*/
J2SPrefix.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.op, this.rhs.lhs.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SPostfix ...                                        */
/*---------------------------------------------------------------------*/
J2SPostfix.prototype.generate = function(conf) {
   return new Fragment(conf, this, this.rhs.lhs.generate(conf), this.op);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SBindExit ...                                       */
/*---------------------------------------------------------------------*/
J2SBindExit.prototype.generate = function(conf) {
   if (this.blb) {
      throw "BINDEXIT: lbl not supported";
   } else {
      return new Fragment(conf, this, "((() => ", this.stmt.generate(conf), ")())");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SUnary ...                                          */
/*---------------------------------------------------------------------*/
J2SUnary.prototype.generate = function(conf) {
   if (this.op === "?.") {
      return new Fragment(conf, this, this.expr.generate(conf), "?");
   } else if (this.op === "typeof" || this.op === "delete") {
      return new Fragment(conf, this, this.op, " ", this.expr.generate(conf));
   } else {
      return new Fragment(conf, this, this.op, this.expr.generate(conf));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SBinary ...                                         */
/*---------------------------------------------------------------------*/
J2SBinary.prototype.generate = function(conf) {
   
   function j2sop(op) {
      switch (op) {
	 case "OR": return "||";
	 case "BIT_OR": return "|";
	 case "++": return "+";
	 case "--": return "-";
	 default: return op;
      }
   }

   if (this.op === "as") {
      return new Fragment(conf, this, this.lhs.generate(conf), " ", j2sop(this.op), " ", generateType(this.type,conf));
   } else {
      return new Fragment(conf, this, this.lhs.generate(conf), " ", j2sop(this.op), " ", this.rhs.generate(conf));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2STemplate ...                                       */
/*---------------------------------------------------------------------*/
J2STemplate.prototype.generate = function(conf) {
   const nodes = list2array(this.exprs).map(n => {
      if (n.$class === "J2SString") {
	 return n.val;
      } else {
	 return new Fragment(conf, n, "${", n.generate(conf), "}");
      }
   });
   return new Fragment(conf, this, "`", new FragmentList(conf, this, nodes, ""), "`");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDeclClass ...                                      */
/*---------------------------------------------------------------------*/
J2SDeclClass.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "let ", this.id, "=",
      this.val.generate(conf),
      ";", "\n");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SClass ...                                          */
/*---------------------------------------------------------------------*/
J2SClass.prototype.generate = function(conf) {
   return new Fragment(conf, 
      this, "class ",
      this.name ? this.name : "",
		       !this.super instanceof J2SUndefined ? new Fragment(conf, this.super, " extends ", this.super.generate(conf)) : "",
      " {", "\n",
		       new FragmentList(conf, this, list2array(this.elements).map(d => d.generate(conf)), ""),
      "}");
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SClassElement ...                                   */
/*---------------------------------------------------------------------*/
J2SClassElement.prototype.generate = function(conf) {

   function generateName(name) {
      if (name instanceof J2SString) {
	 return name.val;
      } else if (name instanceof J2SLiteralCnst) {
	 return generateName(name.val);
      } else if (name instanceof LiteralValue) {
	 return name.val;
      } else {
	 return name.generate(conf);
      }
   }
   
   function generateProp(prop) {
      if (prop instanceof J2SMethodPropertyInit) {
	 return new Fragment(conf, prop, generateName(prop.name), generateFun.call(prop.val, conf, false, ""), ";");
      } else if (prop instanceof J2SDataPropertyInit) {
	 return new Fragment(conf, prop, generateName(prop.name), "=", prop.val.generate(conf), ";");
      } else if (prop instanceof J2SAccessorPropertyInit) {
	 return newFragmentList(
	    prop,
	    [ new Fragment(conf, prop, "get ", generateName(prop.name), prop.get.generate(conf)),
	      prop.set ? new Fragment(conf, prop, "set ", generateName(prop.name), prop.set.generate(conf)) : "" ]);
      } else {
	 return new Fragment(conf, prop, generateName(prop.name), ";");
      }
   }
   
   return new Fragment(conf, this, this.static ? "static " : "", generateProp(this.prop));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SSpread ...                                         */
/*---------------------------------------------------------------------*/
J2SSpread.prototype.generate = function(conf) {
   return new Fragment(conf, this, "...", this.expr.generate(conf));
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDProducer ...                                      */
/*---------------------------------------------------------------------*/
J2SDProducer.prototype.generate = function(conf) {
   return this.expr.generate(conf);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDConsumer ...                                      */
/*---------------------------------------------------------------------*/
J2SDConsumer.prototype.generate = function(conf) {
   return this.expr.generate(conf);
}

/*---------------------------------------------------------------------*/
/*    generate ::J2SDollar ...                                         */
/*---------------------------------------------------------------------*/
J2SDollar.prototype.generate = function(conf) {
   const nconf = conf.parent;
   if (!nconf) {
      return new Fragment(conf, this, this.node.generate(conf));
   } else {
      if (conf.ctx === "template") {
	 return new Fragment(conf, this, "${", this.node.generate(nconf), "}");
      } else {
	 return new Fragment(nconf, this, "DOLLAR(", this.node.generate(nconf), ",", generateLoc(this.loc), ")");
      }
   }
}

J2SDollar.prototype.generateTBR_11jul24 = function(conf) {
   if (conf.context === "tilde-expression" || conf.context === "script-expression") {
      return new Fragment(conf, this, "${DOLLAR(", this.node.generate(conf), ",", generateLoc(this.loc), ")}");
   } else {
      return new Fragment(conf, this, this.node.generate(conf));
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::J2STilde ...                                          */
/*---------------------------------------------------------------------*/
J2STilde.prototype.generate = function(conf) {
   const nconf = new Conf("client", conf, conf.typescript);
   return new Fragment(conf, this, "TILDE(undefined, ", this.stmt.generate(nconf), ")");
}

/*---------------------------------------------------------------------*/
/*    generate ::TsInterface ...                                       */
/*---------------------------------------------------------------------*/
TsInterface.prototype.generate = function(conf) {
   if (!this.decl) {
      return new Fragment(conf, this, "{", new FragmentList(conf, this, list2array(this.properties).map(n => n.generate(conf)), ""), "}");
   } else {
      return new Fragment(conf, this, this.decl, " ", this.id, "{", new FragmentList(conf, this, list2array(this.properties).map(n => n.generate(conf)), ""), "}", "\n");
   }
}

/*---------------------------------------------------------------------*/
/*    generate ::TsInterfaceProperty ...                               */
/*---------------------------------------------------------------------*/
TsInterfaceProperty.prototype.generate = function(conf) {
   if (this.name instanceof J2SString) {
      const val = this.name.val;
      const m = val.match(/^[a-zA-Z_][a-zA-Z0-9_$]*$/);
      const name = m ? val : "\"" + val + "\"";

      return new Fragment(conf, this, name, this.optional ? "?:" : ":",
			  generateType(this.type, conf), ";");
   } else if (this.name instanceof TsInterfacePropertyName) {
      const val = this.name.fakename.val;
      const m = val.match(/^[a-zA-Z_][a-zA-Z0-9_$]*$/);
      const name = m ? val : "\"" + val + "\"";
      
      return new Fragment(conf, this, "[", name, ":", generateType(this.name.type, conf), "]",
			  this.optional ? "?:" : ":",
			  generateType(this.type, conf), ";");
   } else {
      return new Fragment(conf, this, "[", this.name.generate(conf), "]",
			  this.optional ? "?:" : ":",
			  generateType(this.type, conf), ";");
   }
}

/*---------------------------------------------------------------------*/
/*    TyTypeArray ...                                                  */
/*---------------------------------------------------------------------*/
TsTypeArray.prototype.generate = function(conf) {
   const tof = generateType(this.of, conf);
   return new Fragment(conf, this, tof, "[]");
}

/*---------------------------------------------------------------------*/
/*    TyTypeFunction ...                                               */
/*---------------------------------------------------------------------*/
TsTypeFunction.prototype.generate = function(conf) {
   const tdom = new FragmentList(conf, this, list2array(this.domain).map(t => generateType(t, conf)));
   const trange = generateType(this.range, conf);
   return new Fragment(conf, this, "(", tdom, ") => ", trange);
}

/*---------------------------------------------------------------------*/
/*    TyTypeBinary ...                                                 */
/*---------------------------------------------------------------------*/
TsTypeBinary.prototype.generate = function(conf) {
   const op = this.op === "BIT_OR" ? "|" : "&";
   return new Fragment(conf, this, generateType(this.lhs, conf),
		       op,
		       generateType(this.rhs, conf));
}

/*---------------------------------------------------------------------*/
/*    generateType ...                                                 */
/*---------------------------------------------------------------------*/
function generateType(ty, conf) {
   if (typeof ty === "string") {
      return ty;
   } else if (typeof ty === "symbol") {
      const name = ty.toString().match(/\(([^)]+)\)/)[1];
      if (name === "array") {
	 return "any[]";
      } else {
	 return name;
      }
   } else if (ty instanceof TsType) {
      return ty.generate(conf);
   } else if (ty instanceof J2SString) {
      return '"' + ty.generate(conf) + '"';
   } else if (ty instanceof J2SNumber) {
      return ty.generate(conf);
   } else if (ty instanceof TsInterface) {
      return ty.generate(conf);
   } else if (ty instanceof J2SNode) {
      return "any";
   } else {
      return "any";
   }
}
