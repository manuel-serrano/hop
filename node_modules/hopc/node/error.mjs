/*=====================================================================*/
/*    .../prgm/project/hop/hop/node_modules/hopc/node/error.mjs        */
/*    -------------------------------------------------------------    */
/*    Author      :  manuel serrano                                    */
/*    Creation    :  Sat Sep 16 14:11:38 2023                          */
/*    Last change :  Tue Feb 20 08:41:40 2024 (serrano)                */
/*    Copyright   :  2023-24 manuel serrano                            */
/*    -------------------------------------------------------------    */
/*    Exceptions                                                       */
/*                                                                     */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import { existsSync, readFileSync, writeSync } from "node:fs";
export { locToLnumCol, $ioParseError, compileErrorPoint, compileErrorLineCol };

/*---------------------------------------------------------------------*/
/*    makeString ...                                                   */
/*---------------------------------------------------------------------*/
function makeString(len, line) {
   let s = "";

   for (let i = 0; i < len; i++) {
      if (line.charCodeAt(i) === 9) {
	 s += "\t";
      } else {
	 s += " ";
      }
   }
   return s;
}

/*---------------------------------------------------------------------*/
/*    locToLnumCol ...                                                 */
/*---------------------------------------------------------------------*/
function locToLnumCol(fname, location) {
   
   function lnumCol(buf, location) {
      if (location < buf.length) {
	 // find the beginning of line
	 let beg = location;
	 let end = location;

	 while (beg >= 0 && buf.charCodeAt(beg) !== 10) {
	    beg--;
	 }
	 beg++;

	 // find the end of line
	 while (end < buf.length && buf.charCodeAt(end) !== 10) {
	    end++;
	 }

	 // extract the line
	 const line = buf.substring(beg, end);
	 const col = location - beg;
	 let lnum = 1, i = 0;

	 for (; i < beg && i >= 0; i = buf.indexOf("\n", i + 1)) {
	    lnum++;
	 }

	 return { beg, end, lnum, col, line };
      } else {
	 let lnum = 1, i = 0;
	 const beg = location;
	 const end = location;

	 for (; i < location - 1 && i >= 0; i = buf.indexOf("\n", i + 1)) {
	    lnum++;
	 }
	 return { beg, end, lnum, col: 0, line: "" };
      }
   }

   if (existsSync(fname)) {
      return lnumCol(readFileSync(fname).toString(), location);
   } else if (fname.match(/^string:\/\//)) {
      return findLoc(fname.substring(9, location));
   } else {
      return { beg: -1, end: -1, lnum: 0, col: 0, line: "" };
   }
}

/*---------------------------------------------------------------------*/
/*    lineColToLnumCol ...                                             */
/*---------------------------------------------------------------------*/
function lineColToLnumCol(fname, lnum, col) {
   
   function lnumCol(buf, lnum) {
      const len = buf.length;
      let beg = 0;

      for (let l = 0; (beg < len) && (l < lnum); l++) {
	 beg = buf.indexOf("\n", beg + 1);
      }

      if (beg >= len) {
	 return { beg: -1, end: -1, lnum: 0, col: 0, line: "" };
      } else {
	 const end = buf.indexOf("\n", beg + 1);
	 const line = buf.substring(beg + 1, end);
	 return { beg, end, lnum, col, line };
      }
   }

   if (existsSync(fname)) {
      return lnumCol(readFileSync(fname).toString(), lnum);
   } else if (fname.match(/^string:\/\//)) {
      return findLoc(fname.substring(9, lnum));
   } else {
      return { beg: -1, end: -1, lnum: 0, col: 0, line: "" };
   }
}

/*---------------------------------------------------------------------*/
/*    compileErrorReport ...                                           */
/*---------------------------------------------------------------------*/
function compileErrorReport(filename, position, tag, message, proc) {
   
   function err(str) {
      // for some resons, when ioParseError is invoked from a nodejs loader
      // stderr is not correctly flushed and process.stderr not property
      // initialized
      writeSync(2, str + "\n");
   }

   const { beg, end, lnum, col, line } = position;
   
   if (beg >= 0) {
      // display the error message
      err(`${filename}:${lnum}`);
      err(line);
      err(makeString(col, line) + "^\n");
   }
   
   err(`${tag}: ${message}`);
   if (proc) {
      err(`   at ${proc} (${filename}:${lnum}:${col})`);
   }
}

/*---------------------------------------------------------------------*/
/*    compileErrorPoint ...                                            */
/*---------------------------------------------------------------------*/
function compileErrorPoint(filename, point, message, tag = "Error", proc = undefined) {
   const position = locToLnumCol(filename, point);
   compileErrorReport(filename, position, tag, message, proc);
}

/*---------------------------------------------------------------------*/
/*    compileErrorLineCol ...                                          */
/*---------------------------------------------------------------------*/
function compileErrorLineCol(filename, lnum, col, message, tag = "Error", proc = undefined) {
   const position = lineColToLnumCol(filename, lnum, col);
   compileErrorReport(filename, position, tag, message, proc);
}

/*---------------------------------------------------------------------*/
/*    $ioParseError ...                                                */
/*---------------------------------------------------------------------*/
function $ioParseError(props) {
   if (new.target) {
      // used as a constructor (see parser.mjs)
      Object.assign(this, props);
   } else {
      if ("fname" in props && "location" in props && props.location >= 0) {
	 compileErrorPoint(props.fname, props.location,
			   props.message ?? "",
			   props.tag ?? props?.msg ?? "Error");
      }
      if (props?.forceexit) {
	 setTimeout(() => process.exit(1));
      }
   }
}

$ioParseError.prototype = SyntaxError.prototype;
