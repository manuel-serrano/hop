!/*=====================================================================*/
/*    .../prgm/project/hop/3.0.x/node_modules/hopdoc/lib/hopdoc.js     */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Thu Jun 26 08:21:30 2014                          */
/*    Last commit :  2015-12-18 [27d3246] (Manuel Serrano)             */
/*    Copyright   :  2014-25 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    HOPDOC, toolkit for generating the hop.js documentation          */
/*=====================================================================*/
"use hopscript"

import * as md from "@hop/markdown";
import * as fontifier from "@hop/fontifier";
import { include } from "./_hopdoc.hop";
import * as fs from "node:fs";
import * as path from "path";

/*---------------------------------------------------------------------*/
/*    sourceDir ...                                                    */
/*---------------------------------------------------------------------*/
let sourceDir = ".";

/*---------------------------------------------------------------------*/
/*    xmlIgnore                                                        */
/*---------------------------------------------------------------------*/
const xmlIgnore = [
   "METADATA",
   "RDF:RDF",
   "CC:WORK",
   "DC:FORMAT",
   "DC:TYPE",
   "INKSCAPE:PERSPECTIVE",
   "INKSCAPE:GRID",
   "SODIPODI:NAMEDVIEW",
   "CLIPPATH",
   "STOP",
   "DC:TITLE" ];

/*---------------------------------------------------------------------*/
/*    toc ...                                                          */
/*---------------------------------------------------------------------*/
function toc(doc, clazz = "toc") {
   
   function getTags(el) {
      if (el instanceof Array) {
	 return Array.prototype.concat.apply([], el.map(getTags));
      }
      
      if (typeof(el) == "pair") {
	 return Array.prototype.concat.apply([], el.map(getTags).toArray());
      }

      if (typeof(el) == "xml-element" || typeof(el) == "xml-html") {
	 return el.getElementsByClassName(clazz);
      }
      
      return [];
   }

   return getTags("XML" in doc ? doc.XML : doc);
}

/*---------------------------------------------------------------------*/
/*    toType ...                                                       */
/*---------------------------------------------------------------------*/
function toType(clazz) {
   const i = clazz.lastIndexOf(" ");

   if (i > 0) {
      return clazz.substring(i + 1);
   } else {
      return clazz;
   }
}

/*---------------------------------------------------------------------*/
/*    DIR ...                                                          */
/*---------------------------------------------------------------------*/
const DIR = path.dirname(module.filename);

/*---------------------------------------------------------------------*/
/*    P ...                                                            */
/*---------------------------------------------------------------------*/
function P(file) {
   return path.normalize(path.join(DIR, file));
}

/*---------------------------------------------------------------------*/
/*    bind dummy xml construct                                         */
/*---------------------------------------------------------------------*/
(function(tags) {
   function ignore(attr, ... _) { return undefined; };

   tags.forEach(function(tag, idx = undefined, arr = undefined) {
      GLOBAL[tag] = ignore;
   });
})(xmlIgnore);

/*---------------------------------------------------------------------*/
/*    index ...                                                        */
/*---------------------------------------------------------------------*/
function index(doc, tags, classes=["module", "parameter", "function", "tag", "constructor", "scheme", "syntax", "ext-function", "ext-variable", "procedure", "class", "index"]) {
   let res = [];

   for (let i = 0; i < classes.length; i++) {
      res = res.concat(toc(doc, classes[i]));
   }

   return res
      .filter(function(el, idx = undefined, arr = undefined) {
	 return tags.indexOf(el.tagName) >= 0; })
      .map(function(el, idx = undefined, arr = undefined) {
	 let proto = 
	    (el.childNodes && 
	     el.childNodes.length > 0 && 
	     typeof(el.childNodes[0] === "xml-element"))
	    ? el.childNodes[0].innerHTML.trim()
	    : el.innerHTML.trim();
	 let key;
	 
	 if (el.className.indexOf("index") >= 0) {
	    return { key: el.id,
		     proto: el.id,
		     id: el.id,
		     type: toType(el.class) };
	 } else if (el.className.indexOf("syntax") >= 0) {
	    let i = proto.indexOf(" ");
	    key = i >= 0 ? proto.substring(0, i) : proto;
	 } else if (el.className.indexOf("bigloo") < 0) {
	    const i =  proto.indexOf(".");
	    key = i >= 0 ? proto.substring(i + 1) : proto;
	    
	    if (key.indexOf("prototype.") === 0) {
	       key = key.substring("prototype.".length);
	    }
	    
	    key = key.replace(/&[lg]t;/g, "");
	    key = key.replace(/^new /, "");
	 } else {
   	    if (proto.indexOf(":") > 0) {
	       proto = proto.substring(0, proto.indexOf(":"));
	    }
	    key = proto;
	 }
	
	 if (proto === "") {
	    proto = "...";
	    key = "...";
	 }
	 
	 const m = key.match(/([^ [(]+)/);
         if (m) key = m[1];
	     
	 return { key: key,
		  proto: proto,
		  id: el.id,
		  type: toType(el.class) };
      });
}

/*---------------------------------------------------------------------*/
/*    htmlToIdx ...                                                    */
/*    -------------------------------------------------------------    */
/*    Generates a JSON index from a collection of HTML files.          */
/*---------------------------------------------------------------------*/
function htmlToIdx(base, files, target, tags=["h1", "h2", "h3"]) {
   let table = [];
   const dir = target ? path.dirname(target) : ".";
   
   for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const xml = require(file, "html");
      const chapter = path.basename(file, ".html").replace(/^[0-9]+-/, "");

      const idx = index({ XML: xml }, tags)
	  .map(function(e, idx = undefined, arr = undefined) {
	     e.chapter = chapter;
	     e.url = target
		? path.relative(dir, file) + "#" + e.id
		: path.basename(file) + "#" + e.id;
	     return e;
	  });

      table = table.concat(idx);
   }

   fs.writeFileSync(
      target || process.stdout,
      JSON.stringify(
	 table.sort(function(l, r) {
	    return l.key.toUpperCase().localeCompare(r.key.toUpperCase()); })),
      { flush: true });
}

/*---------------------------------------------------------------------*/
/*    exports                                                          */
/*---------------------------------------------------------------------*/
exports.include = function(file, beg = undefined, end = undefined) {
   const src = path.isAbsolute(file) ? file : path.join(sourceDir, file);
   return include(src, beg, end);
}

exports.includeCode = function(file, lang = false, beg = undefined, end = undefined) {
   const src = path.isAbsolute(file) ? file : path.join(sourceDir, file);
   let body = include(src, beg, end);

   if (lang) {
      if (fontifier[lang]) {
	 body = fontifier[lang](body);
      }
   }

   const preClass = `markdown fontifier-prog ${lang ? lang : ""}`;
   const codeClass = `markdown ${lang ? "language-" + lang : ""}`;
   return <pre class=${preClass}><code class=${codeClass}>${body}</code></pre>;
}

exports.BUILDDIR = P("../../../..");
exports.EXAMPLES_DIR = path.join(exports.BUILDDIR, "examples");

exports.toc = toc;
exports.index = index;

exports.load = function(file, ft = fontifier) {
   return md.load(file, hop.locale, ft)
};

exports.eval = function(obj, ft = fontifier) {
   return md.eval(obj, hop.locale, ft)
};

exports.setSource = function(file) {
   // this is used to adjust the sourceDir variable which is the directory
   // from which code is included (see include and includeCode).
   sourceDir = path.dirname(file);
}

// public compilers
exports.htmlToIdx = htmlToIdx;
