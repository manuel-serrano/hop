;*=====================================================================*/
;*    .../hop/3.0.x/node_modules/fontifier/lib/_fontifier.hop          */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano, Florian Loitsch                   */
;*    Creation    :  Thu Sep  7 17:29:41 2006                          */
;*    Last change :  Fri Dec 11 20:10:33 2015 (serrano)                */
;*    Copyright   :  2006-15 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    fontifiers                                                       */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _fontifier
   
   (library hopscript hop hopwidget nodejs)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)
	   
           (xml-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (hop-fontifier::pair-nil ::input-port
	      #!key line-begin line-end keyword-fontifier)
	   (hiphop-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (hss-fontifier::pair-nil ::input-port
	      #!key line-begin line-end keyword-fontifier)
	   (ebnf-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (plain-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (sh-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (c-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (js-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (hopscript-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   (tex-fontifier::pair-nil ::input-port
	      #!key line-begin line-end)
	   
	   (line-number ::obj ::int ::obj)))

;*---------------------------------------------------------------------*/
;*    ->line ...                                                       */
;*---------------------------------------------------------------------*/
(define (->line val %this)
   (unless (eq? val (js-undefined))
      (let ((v (js-tointeger val %this)))
	 (cond
	    ((flonum? v) (flonum->fixnum v))
	    ((fixnum? v) v)
	    (else #f)))))
	     
;*---------------------------------------------------------------------*/
;*    fontifier-bind-fun! ...                                          */
;*---------------------------------------------------------------------*/
(define-macro (fontifier-bind-fun! %this obj lang)
   (let ((jsfun lang)
	 (scmfun (symbol-append lang '-fontifier)))
      `(js-bind! ,%this ,obj ',jsfun
	  :value (js-make-function ,%this
		    (lambda (this buffer lbeg lend)
		       (let ((ip (cond
				    ((input-port? buffer)
				     buffer)
				    ((isa? buffer JsFastBuffer)
				     (with-access::JsFastBuffer buffer (%data byteoffset length)
					(let ((len (uint32->fixnum length))
					      (beg (uint32->fixnum byteoffset)))
					   (open-input-string %data
					      beg (+fx beg len)))))
				    ((isa? buffer JsSlowBuffer)
				     (with-access::JsSlowBuffer buffer (data)
					(let ((len (js-get buffer 'length %this)))
					   (open-input-string data 0 len))))
				    (else
				     (open-input-string (js-tostring buffer %this))))))
			  (,scmfun ip
			     :line-begin (->line lbeg %this)
			     :line-end (->line lend %this))))
		    3 ',jsfun)
	  :writable #f
	  :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    fontifier-bind-funs! ...                                         */
;*---------------------------------------------------------------------*/
(define-macro (fontifier-bind-funs! %this obj . funs)
   `(begin
       ,@(map (lambda (fun)
		 `(fontifier-bind-fun! ,%this ,obj ,fun))
	    funs)))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (let ((exports (js-get module 'exports %this)))
      (fontifier-bind-funs! %this exports
	 xml hop hss ebnf plain c js hopscript tex)
      (js-bind! %this exports 'lineNumber
	 :value (js-make-function %this
		   (lambda (this prog lnum id)
		      (line-number prog (or (->line lnum %this) 1) id))
		   3 'lineNumber)
	 :writable #f
	 :enumerable #f)
      exports))

;*---------------------------------------------------------------------*/
;*    fontifier-error-line ...                                         */
;*---------------------------------------------------------------------*/
(define (fontifier-error-line c port)
   (let ((line (read-line port)))
      (if (string? line)
	  (string-append "{" (string c) "}" line)
	  c)))

;*---------------------------------------------------------------------*/
;*    fontifier-parse-ident ...                                        */
;*---------------------------------------------------------------------*/
(define (fontifier-parse-ident str)
   (let ((i (string-index str #\@)))
      (cond
	 ((not i)
	  (values str #f))
	 ((=fx i 0)
	  (values #f (substring str 1 (string-length str))))
	 (else
	  (values (substring str 0 i)
		  (substring str (+fx i 1) (string-length str)))))))

;*---------------------------------------------------------------------*/
;*    *xml-grammar* ...                                                */
;*---------------------------------------------------------------------*/
(define *xml-grammar*
   (regular-grammar (keyword-fontifier line-begin line-end incollect
		     res column)
      (define (add! s)
       (when incollect
	  (set! res (cons s res))))

      ((: "<!--"
	  (* (or (out #\-) (: "-" (out #\-)) (: "--" (out #\>))))
	  "-->")
       ;; comments
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" str))
	  (ignore)))
      ((+ #\Space)
       ;; separators
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> str))
	  (ignore)))
      (#\Tab
       ;; replace the tab character with a series an n whitespaces
       (add! (vector-ref whitespaces (-fx 8 (modulofx column 8))))
       (set! column 0)
       (ignore))
      
      (#\Newline
       ;; newline
       (set! column 0)
       (when (integer? line-end)
	  (set! line-end (-fx line-end 1))
	  (if (<=fx line-end 0) (set! incollect #f)))
       (add! (the-string))
       (when (integer? line-begin)
	  (set! line-begin (-fx line-begin 1))
	  (if (<=fx line-begin 1) (set! incollect #t)))
       (ignore))

      ((: "#" (+ (in #\_ #\@ ("azAZ09"))) #\#)
       ;; anchor
       (multiple-value-bind (id class)
	  (fontifier-parse-ident (the-substring 1 -1))
	  (let ((cur res))
	     (set! res '())
	     (let ((anchor (ignore)))
		(set! res cur)
		(add! (<SPAN> :id id :class class anchor))
		(ignore)))))
      ((: "#/" (+ (out #\#)) #\#)
       ;; end anchor
       (reverse! res))
       ;; anchor
      ((: #\<
	  (: (? #\/) alpha (* (out #\# #\> #\space #\tab #\Newline)))
	  (? #\>))
       ;; tag
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-tag" str))
	  (ignore)))
      (#\>
       (add! (<SPAN> :class "fontifier-prog-tag" "&gt;"))
       (ignore))
      ((: "<?" (: (? (in "/?")) alpha (* (out #\> #\space #\tab #\Newline))))
       ;; special
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-special" str))
	  (ignore)))
      ("?>"
       ;; special
       (add! (<SPAN> :class "fontifier-prog-special" "?&gt;"))
       (ignore))
      (#\<
       (add! "&lt;")
       (ignore))
      ((+ (out #\< #\> #\Space #\Tab #\= #\" #\' #\# #\Newline))
       ;; regular text
       (let ((string (xml-string-encode (the-string))))
	  (add! string)
	  (ignore)))
      ((or (: "\"" (* (or (out #a000 #\\ #\") (: #\\ all))) "\"")
	   (: "\'" (* (or (out #a000 #\\ #\') (: #\\ all))) "\'"))
       ;; strings
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-string" str))
	  (ignore)))
      ((in "\"=#'")
       (let ((str (the-string)))
	  (add! str)
	  (ignore)))
      (else
       (let ((c (the-failure)))
	  (if (eof-object? c)
	      (reverse! res)
	      (error "xml-fontifier"
		     "Unexpected character"
		     (fontifier-error-line c (the-port))))))))

;*---------------------------------------------------------------------*/
;*    *lisp-grammar* ...                                               */
;*---------------------------------------------------------------------*/
(define *lisp-grammar*
   (regular-grammar (keyword-fontifier line-begin line-end incollect
		     res column)
      
      (define (add! s)
       (when incollect
	  (set! res (cons s res))))

      ((: ";;" (* all))
       ;; italic comments
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" str))
	  (ignore)))
      ((: ";*" (* all))
       ;; bold comments
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> :class "fontifier-prog-comment" str))
	  (ignore)))
      ((: ";" (out #\; #\* #\Newline) (* all))
       ;; plain comments
       (let ((str (xml-string-encode (the-string))))
	  (add! (<SPAN> str))
	  (ignore)))
      ((: #\\ (* (in #\space #\tab)) ";" (out #\; #\*) (* all))
       ;; plain comments
       (let ((str (the-substring 1 (the-length))))
	  (add! (<SPAN> str))
	  (ignore)))
      
      ((+ #\Space)
       ;; separators
       (let ((str (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> str))
	  (ignore)))

      (#\Tab
       ;; replace the tab character with a series an n whitespaces
       (add! (vector-ref whitespaces (-fx 8 (modulofx column 8))))
       (set! column 0)
       (ignore))
      
      (#\Newline
       ;; newline
       (set! column 0)
       (when (integer? line-end)
	  (set! line-end (-fx line-end 1))
	  (if (<=fx line-end 0) (set! incollect #f)))
       (add! (the-string))
       (when (integer? line-begin)
	  (set! line-begin (-fx line-begin 1))
	  (if (<=fx line-begin 1) (set! incollect #t)))
       (ignore))

      ((+ #\#)
       ;; sharp signs
       (let ((str (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> str))
	  (ignore)))
      ((: "#" (out #\/ #\space #\tab) (* (out #\# #\space)) #\#)
       ;; anchor
       (multiple-value-bind (id class)
	  (fontifier-parse-ident (the-substring 1 -1))
	  (let ((cur res))
	     (set! res '())
	     (let ((anchor (ignore)))
		(set! res cur)
		(add! (<SPAN> :id id :class class anchor))
		(ignore)))))
      ((: "#/" (+ (out #\#)) #\#)
       ;; end anchor
       (reverse! res))
      ((or "(" (+ (in ")[]")))
       ;; open parenthesis
       (let ((str (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> str))
	  (ignore)))
      ("~"
       ;; client
       (let ((str (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-client" str))
	  (ignore)))
      ("$"
       ;; special
       (let ((str (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-server" str))
	  (ignore)))
      ((: #\( (+ (or (: ":" (out ":")) (out "; $\t()[]:\"\n#"))))
       ;; keywords
       (let* ((string (the-substring 1 (the-length)))
	      (obj (keyword-fontifier string #t)))
	  (set! column (+fx column (+fx 1 (the-length))))
	  (add! (<SPAN> "("))
	  (add! obj)
	  (ignore)))
      ((: ":" (+ (out "; \t()[]:\"\n~$#")))
       ;; keywords
       (let ((string (the-string)))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-keyword" string))
	  (ignore)))
      ((: (+ (out "; \t()[]:\"\n~$#")) ":" (in "; \t()[]\"\n~$#"))
       ;; keywords
       (let* ((string (the-string)))
	  (unread-char! (string-ref string (-fx (the-length) 1)) (the-port))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-keyword"
		   (substring string 0 (-fx (string-length string) 1))))
	  (ignore)))
      ((+ (or (out "; \t()[]:\"\n~$#") (: ":" (out "; :\t()[]\"\n~$#"))))
       ;; identifiers
       (let* ((string (the-string))
	      (obj (keyword-fontifier string #f)))
	  (set! column (+fx column (the-length)))
	  (add! obj)
	  (ignore)))
      ((or (: "\"" (* (or (out #a000 #\\ #\") (: #\\ all))) "\"")
	   (: "#\"" (* (or (out #a000 #\\ #\") (: #\\ all))) "\""))
       ;; strings
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-string" str))
	  (ignore)))
      ((: "::" (+ (out ";\n \t()[]:\"")))
       ;; types
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> :class "fontifier-prog-type" str))
	  (ignore)))
      ((+ (or #\: #\; #\"))
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> str))
	  (ignore)))
      ((: #\# #\\ (+ (out " \n\t")))
       ;; characters
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx column (the-length)))
	  (add! (<SPAN> str))
	  (ignore)))
      (else
       (let ((c (the-failure)))
	  (if (eof-object? c)
	      (reverse! res)
	      (error "lisp-fontifier" "Unexpected character" c))))))

;*---------------------------------------------------------------------*/
;*    xml-fontifier ...                                                */
;*---------------------------------------------------------------------*/
(define (xml-fontifier ip #!key line-begin line-end)
   (read/rp *xml-grammar* ip
      (lambda (k) k)
      line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1))
      '() 0))

;*---------------------------------------------------------------------*/
;*    *hop-keywords* ...                                               */
;*---------------------------------------------------------------------*/
(define *hop-keywords*
   (let ((t (make-hashtable)))
      (for-each (lambda (k)
		   (hashtable-put! t k "define"))
	 '("define" "module" "define-macro" "define-generic"
	   "define-method" "define-service" "define-expander" "define-tag"))
      (for-each (lambda (k)
		   (hashtable-put! t k "reserved"))
	 '("lambda" "service" "let" "let*" "letrec" "if" "when" "unless"
	   "begin" "cond" "case" "instantiate" "set!" "else" "with-access"
	   "multiple-value-bind" "values" "match-case" "node-style-set!"))
      (for-each (lambda (k)
		   (hashtable-put! t k "important"))
	 '("try" "with-handler" "unwind-protect"
	   "with-hop" "with-url" "error" "bind-exit" "call/cc"))
      (for-each (lambda (k)
		   (hashtable-put! t k "thread"))
	 '("thread-start!" "thread-start-joinable!" "make-thread"
	   "thread-join!"
	   "make-mutex" "with-lock" "mutex-lock!" "mutex-unlock!"
	   "make-condition-variable" "condition-variable-signal!"
	   "condition-variable-wait!"))
      (for-each (lambda (k)
		   (hashtable-put! t k "server"))
	 '("hop-event-signal!" "hop-event-broadcast!"))
      (for-each (lambda (k)
		   (hashtable-put! t k "class"))
	 '("generic" "class" "final-class" "wide-class" "abstract-class"))
      t))

;*---------------------------------------------------------------------*/
;*    hop-fontifier ...                                                */
;*---------------------------------------------------------------------*/
(define (hop-fontifier ip #!key line-begin line-end keyword-fontifier)
   
   (define (hop-keyword-fontifier x op)
      (let ((s (xml-string-encode x))
	    (l (string-length x)))
	 (cond
	    ((and (procedure? keyword-fontifier) (keyword-fontifier s))
	     => 
	     (lambda (k) k))
	    ((and (char=? (string-ref x 0) #\<)
		  (char=? (string-ref x (-fx l 1)) #\>))
	     (<SPAN> :class "fontifier-prog-tag" s))
	    ((hashtable-get *hop-keywords* s)
	     =>
	     (lambda (k)
		(<SPAN> :class (string-append "fontifier-prog-" k) s)))
	    (else
	     (<SPAN> s)))))
   
   (read/rp *lisp-grammar* ip hop-keyword-fontifier
      line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1))
      '() 0))

;*---------------------------------------------------------------------*/
;*    hiphop-fontifier ...                                             */
;*---------------------------------------------------------------------*/
(define (hiphop-fontifier ip #!key line-begin line-end)
   (hop-fontifier ip :line-begin line-begin :line-end line-end
      :keyword-fontifier
      (lambda (x)
	 (cond
	    ((string-suffix? "&amp;" x)
	     (<SPAN> :class "fontifier-prog-special fontifier-prog-hiphop" x))
	    ((or (string=? x "make-hiphop-machine")
		 (string=? x "hiphop-input!")
		 (string=? x "hiphop-input-and-react!")
		 (string=? x "hiphop-react!"))
	     (<SPAN> :class "fontifier-prog-reserved" x))
	    (else
	     #f)))))

;*---------------------------------------------------------------------*/
;*    *hss-keywords* ...                                               */
;*---------------------------------------------------------------------*/
(define *hss-keywords*
   (let ((t (make-hashtable)))
      (for-each (lambda (k)
		   (hashtable-put! t k "define"))
		'("define-hss-property" "define-hss-type" "define-hss-function"))
      t))

;*---------------------------------------------------------------------*/
;*    hss-fontifier ...                                                */
;*---------------------------------------------------------------------*/
(define (hss-fontifier ip #!key line-begin line-end keyword-fontifier)

   (define (hss-keyword-fontifier x op)
      (let ((s (xml-string-encode x))
	    (l (string-length x)))
	 (cond
	    ((and (procedure? keyword-fontifier) (keyword-fontifier s))
	     => 
	     (lambda (k) k))
	    ((and (char=? (string-ref x 0) #\<)
		  (char=? (string-ref x (-fx l 1)) #\>))
	     (<SPAN> :class "fontifier-prog-tag" s))
	    ((or (hashtable-get *hop-keywords* s)
		 (hashtable-get *hss-keywords* s))
	     =>
	     (lambda (k)
		(<SPAN> :class (string-append "fontifier-prog-" k) s)))
	    ((char=? (string-ref x 0) #\@)
	     (<SPAN> :class "fontifier-prog-special" s))
	    (else
	     s))))

   (read/rp *lisp-grammar* ip hss-keyword-fontifier
      line-begin line-end (not line-begin) '() 0))

;*---------------------------------------------------------------------*/
;*    tex-fontifier ...                                                */
;*---------------------------------------------------------------------*/
(define (tex-fontifier ip #!key line-begin line-end)
   
   (define *tex-grammar*
      (regular-grammar (line-begin line-end incollect res column)
	 
	 (define (add! s)
	  (when incollect
	     (set! res (cons s res))))

	 ((: #\\ (+ (out " \t\n\\{}")))
	  (let ((el (<SPAN> :class "fontifier-prog-tag"
		       (xml-string-encode (the-string)))))
	     (add! el)
	     (ignore)))
	 ((+ (in "{}"))
	  (let ((el (<SPAN> :class "fontifier-prog-string"
		       (the-string))))
	     (add! el)
	     (ignore)))
	 ((+ (out "{}\\n\t"))
	  (let ((s (xml-string-encode (the-string))))
	     (add! s)
	     (ignore)))
	 (#\Tab
	  ;; replace the tab character with a series an n whitespaces
	  (add! (vector-ref whitespaces (-fx 8 (modulofx column 8))))
	  (set! column 0)
	  (ignore))
      
	 (#\Newline
	  ;; newline
	  (set! column 0)
	  (when (integer? line-end)
	     (set! line-end (-fx line-end 1))
	     (if (<=fx line-end 0) (set! incollect #f)))
	  (add! (the-string))
	  (when (integer? line-begin)
	     (set! line-begin (-fx line-begin 1))
	     (if (<=fx line-begin 1) (set! incollect #t)))
	  (ignore))

	 (else
	  (let ((c (the-failure)))
	     (if (eof-object? c)
		 (reverse! res)
		 (error "tex-fontifier" "Unexpected character" c))))))
   
   (read/rp *tex-grammar* ip
      line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1))
      '() 0))

;*---------------------------------------------------------------------*/
;*    ebnf-fontifier ...                                               */
;*---------------------------------------------------------------------*/
(define (ebnf-fontifier ip #!key line-begin line-end)
   
   (define *ebnf-grammar*
      (regular-grammar (line-begin line-end incollect res column)
	 
	 (define (add! s)
	  (when incollect
	     (set! res (cons s res))))
	 
	 ("-->"
	  (add! (<SPAN> :class "ebnf-arrow" (<SYM> '-->)))
	  (ignore))
	 ("|"
	  (add! (<SPAN> :class "ebnf-pipe" "|"))
	  (ignore))
	 ((in "+*")
	  (let ((el (<SPAN> :class "ebnf-meta" (<SUP> (the-string)))))
	     (add! el)
	     (ignore)))
	 ((in "[]")
	  (let ((el (<SPAN> :class "ebnf-meta" (the-string))))
	     (add! el)
	     (ignore)))
	 ((bol (: #\< (+ (out " \t\n>")) #\>))
	  (let ((el (<SPAN> :class "fontifier-prog-define ebnf-tag"
		       (xml-string-encode (the-string)))))
	     (add! el)
	     (ignore)))
	 ((: #\< (+ (out " \t\n>")) #\>)
	  (let ((el (<SPAN> :class "ebnf-tag"
		       (xml-string-encode (the-string)))))
	     (add! el)
	     (ignore)))
	 ((or (+ " ") (+ (in "<>")))
	  (let ((el (xml-string-encode (the-string))))
	     (add! el)
	     (ignore)))
	 ((context strike "--")
	  '())
	 ("--"
	  (rgc-context 'strike)
	  (let ((rest (ignore)))
	     (add! (<STRIKE> rest))
	     (ignore)))
	 ((context add "##")
	  '())
	 ("##"
	  (rgc-context 'add)
	  (let ((rest (ignore)))
	     (add! (<SPAN> :class "ebnf-add" rest))
	     (ignore)))
	 ((+ (or (out "<> \t\n-#") (: #\- (out "-\t\n")) (: #\# (out #\#))))
	  (let ((el (<SPAN> :class "ebnf-keyword" (the-string))))
	     (add! el)
	     (ignore)))
	 (#\Tab
	  ;; replace the tab character with a series an n whitespaces
	  (add! (vector-ref whitespaces (-fx 8 (modulofx column 8))))
	  (set! column 0)
	  (ignore))
      
	 (#\Newline
	  ;; newline
	  (set! column 0)
	  (when (integer? line-end)
	     (set! line-end (-fx line-end 1))
	     (if (<=fx line-end 0) (set! incollect #f)))
	  (add! (the-string))
	  (when (integer? line-begin)
	     (set! line-begin (-fx line-begin 1))
	     (if (<=fx line-begin 1) (set! incollect #t)))
	  (ignore))

	 (else
	  (let ((c (the-failure)))
	     (if (eof-object? c)
		 (reverse! res)
		 (error 'ebnf-fontifier "Unexpected character" c))))))
   
   (read/rp *ebnf-grammar* ip
      line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1))
      '() 0))

;*---------------------------------------------------------------------*/
;*    plain-fontifier ...                                              */
;*---------------------------------------------------------------------*/
(define (plain-fontifier ip #!key line-begin line-end)
   (list (xml-string-encode (pregexp-replace* "#[^#]*#" (read-string ip) ""))))

;*---------------------------------------------------------------------*/
;*    sh-fontifier ...                                                 */
;*---------------------------------------------------------------------*/
(define (sh-fontifier ip #!key line-begin line-end)
   (list (xml-string-encode (pregexp-replace* "#[^#]*#" (read-string ip) ""))))

;*---------------------------------------------------------------------*/
;*    *js-keyword-list* ...                                            */
;*---------------------------------------------------------------------*/
(define *js-keyword-list*
   '("as"
     "break"
     "case"
     "catch"
     "class"
     "const"
     "continue"
     "default"
     "delete"
     "do"
     "else"
     "extends"
     "false"
     "finally"
     "for"
     "function"
     "if"
     "import"
     "in"
     "instanceof"
     "is"
     "namespace"
     "new"
     "null"
     "package"
     "private"
     "public"
     "return"
     "super"
     "switch"
     "this"
     "throw"
     "true"
     "try"
     "typeof"
     "use"
     "var"
     "void"
     "while"
     "with"))

;*---------------------------------------------------------------------*/
;*    *c-keyword-list* ...                                             */
;*---------------------------------------------------------------------*/
(define *c-keyword-list*
   '("break"
     "case"
     "class"
     "const"
     "continue"
     "default"
     "do"
     "else"
     "for"
     "if"
     "private"
     "public"
     "return"
     "switch"
     "while"
     "extern"
     "static"
     "main"))

;*---------------------------------------------------------------------*/
;*    *js-future-reserver-list* ...                                    */
;*---------------------------------------------------------------------*/
(define *js-future-reserved-list*
   '("abstract"
     "debugger"
     "enum"
     "export"
     "goto"
     "implements"
     "interface"
     "native"
     "protected"
     "synchronized"
     "throws"
     "transient"
     "volatile"))

;*---------------------------------------------------------------------*/
;*    *js-init-lexer* ...                                              */
;*---------------------------------------------------------------------*/
(define *js-init-lexer* #f)
(define *c-init-lexer* #f)

;*---------------------------------------------------------------------*/
;*    *js-care-future-reserved* ...                                    */
;*---------------------------------------------------------------------*/
(define *js-care-future-reserved* #f)

;*---------------------------------------------------------------------*/
;*    js-lexer-init! ...                                               */
;*---------------------------------------------------------------------*/
(define (js-lexer-init!)
   (unless *js-init-lexer*
      (begin
	 (set! *js-init-lexer* #t)
	 (for-each (lambda (word)
		      (putprop! (string->symbol word) 'javascript #t))
	           *js-keyword-list*)
	 (if *js-care-future-reserved*
	     (for-each (lambda (word)
	                  (putprop! (string->symbol word) 'javascript #t))
		       *js-future-reserved-list*)))))

;*---------------------------------------------------------------------*/
;*    c-lexer-init! ...                                                */
;*---------------------------------------------------------------------*/
(define (c-lexer-init!)
   (unless *c-init-lexer*
      (begin
	 (set! *c-init-lexer* #t)
	 (for-each (lambda (word)
		      (putprop! (string->symbol word) 'c #t))
	           *c-keyword-list*))))

;*---------------------------------------------------------------------*/
;*    whitespaces ...                                                  */
;*---------------------------------------------------------------------*/
(define whitespaces
   '#("" " " "  " "   " "    " "     " "      " "       " "        "))

;*---------------------------------------------------------------------*/
;*    *js-lexer*                                                       */
;*---------------------------------------------------------------------*/
(define *js-lexer*
   (regular-grammar ((blank (in #\Space #a012 #a013))
		     (blank_no_lt (in #\Space #\Tab #a012))
		     (nonzero-digit (in ("19")))
		     (id_start (or alpha #\$ #\_))
		     (id_part (or alnum #\$ #\_ #\.))
		     lang line-begin line-end incollect res
		     column)
      
      (define (add! s)
       (when incollect
	  (set! res (cons s res))))
      
      ((+ blank)
       (set! column (+fx column (the-length)))
       (add! (xml-string-encode (the-string)))
       (ignore))

      (#\Tab
       ;; replace the tab character with a series an n whitespaces
       (add! (vector-ref whitespaces (-fx 8 (modulofx column 8))))
       (set! column 0)
       (ignore))
      
      (#\Newline
       (set! column 0)
       (when (integer? line-end)
	  (set! line-end (-fx line-end 1))
	  (when (<=fx line-end 0) (set! incollect #f)))
       (add! (the-string))
       (when (integer? line-begin)
	  (set! line-begin (-fx line-begin 1))
	  (if (=fx line-begin 1) (set! incollect #t)))
       (ignore))
      
      ;; anchor
      ((: "#" (out #\/ #\space #\tab) (* (out #\# #\space)) #\#)
       (multiple-value-bind (id class)
	  (fontifier-parse-ident (the-substring 1 -1))
	  (let ((cur res))
	     (set! res '())
	     (let ((anchor (<SPAN> :id id :class class (ignore))))
		(set! res cur)
		(add! anchor)
		(ignore)))))
      ((: "#/" (+ (out #\#)) #\#)
       (reverse! res))
      
      ;; cpp
      ((when (eq? lang 'c) (bol (: "#" (* (in " \t")) (+ id_part))))
       (let ((cpp (the-string)))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class (string-append "fontifier-prog-tag " cpp) cpp))
	  (ignore)))
      
      ;; LineComment
      ((bol (: "// " (+ (out " \t\n")) (* all) #\Newline))
       (let* ((str (the-substring 0 -1))
	      (h (string-index str " \t\n" 3))
	      (m (substring str 3 (or h (string-length str)))))
	  (set! column (+fx (the-length) column))
	  (when (integer? line-end)
	     (set! line-end (-fx line-end 1))
	     (if (<=fx line-end 0) (set! incollect #f)))
	  (when (equal? m line-end)
	     (set! incollect #f))
	  (add!
	     (<SPAN> :class "fontifier-prog-line-comment"
		(xml-string-encode str)))
	  (add! "\n")
	  (when (integer? line-begin)
	     (set! line-begin (-fx line-begin 1))
	     (if (<=fx line-begin 1) (set! incollect #t)))
	  (when (equal? m line-begin)
	     (set! incollect #t))
	  (ignore)))
      ((:"//" (* all))
       (let ((cmt (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" cmt))
	  (ignore)))
      
      ;; multi-line comment on one line
      ((: "/*" (* (or (out #\*) (: (+ #\*) (out #\/ #\*)))) (+ #\*) "/")
       (let ((cmt (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" cmt))
	  (ignore)))
      
      ((: "/*"
	  (* (or #\Newline
		 (out #\*)
		 (: (+ #\*) (out #\/ #\*))))
	  (+ #\*) "/")
       (let ((cmt (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" cmt))
	  (ignore)))
      
      ;; multi-line comment on one line
      ((: "/*" (* (or (out #\*) (: (+ #\*) (out #\/ #\*)))) (+ #\*) "/")
       (let ((cmt (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" cmt))
	  (ignore)))
      
      ((: "/*"
	  (* (or #\Newline
		 (out #\*)
		 (: (+ #\*) (out #\/ #\*))))
	  (+ #\*) "/")
       (let ((cmt (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-line-comment" cmt))
	  (ignore)))
      
      ;; TODO: verify if this is really the correct syntax
      ((or
	;; integer constant
	#\0
	(: nonzero-digit (* digit))
	(: (uncase "0x") (+ xdigit))
	;; floating-point constant
	(: (+ digit)
	   (: (in #\e #\E) (? (in #\- #\+)) (+ digit)))
	(: (or (: (+ digit) #\. (* digit)) (: #\. (+ digit)))
	   (? (: (in #\e #\E) (? (in #\- #\+)) (+ digit)))))
       (let ((num (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-number" num))
	  (ignore)))
      
      ((or #\( #\) #\[ #\] #\. #\; #\, #\| "||" "|="
	   #\< #\> "<=" ">=" "==" "!=" "===" "!==" #\+ #\- #\* #\% "++" "--"
	   "<<" ">>" ">>>" #\& #\^ #\! #\^ "&&" #\: #\= "+=" "-="  
	   "*=" "%=" "<<=" ">>=" ">>>=" "&=" "^=" "/=" #\/ #\?)
       (let ((tmp (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-operator" tmp))
	  (ignore)))

      ;; tags
      ((: #\< (? #\/) (+ (or (in ("09azAZ")) (in ":$_."))) (? #\/) #\>)
       (let* ((str (the-string))
	      (tmp (xml-string-encode str)))
	  (set! column (+fx (the-length) column))
	  (if (eq? lang 'hopscript)
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-tag "
			  (substring str 1 (-fx (string-length str) 1)))
		       tmp))
	      (add! tmp))
	  (ignore)))
      
      ((or (: #\< (? #\/) (+ (or (in ("09azAZ")) (in ":$_."))) #\space) "/>")
       (let* ((str (the-string))
	      (tmp (xml-string-encode str)))
	  (set! column (+fx (the-length) column))
	  (if (eq? lang 'hopscript)
	      (add! (<SPAN> :class
		       (if (>fx (the-length) 2)
			   (string-append "fontifier-prog-tag "
			      (substring str 1 (-fx (the-length) 1)))
			   "fontifier-prog-tag")
		       tmp))
	      (add! tmp))
	  (ignore)))
      ((: #\< (? #\/) (+ (or (in ("09azAZ")) (in ":$_."))) #\Newline)
       (let* ((str (the-substring 0 -1))
	      (tmp (xml-string-encode str)))
	  (set! column (+fx (the-length) column))
	  (if (eq? lang 'hopscript)
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-tag "
			  (substring str 1 (-fx (the-length) 1)))
		       tmp))
	      (add! tmp))
	  (unread-char! #\Newline (the-port))
	  (ignore)))
      
      ((when (eq? lang 'hopscript) "~{")
       (set! column (+fx 2 column))
       (add! (<SPAN> :class "fontifier-prog-client" "~"))
       (add! "{")
       (ignore))
      
      ((when (eq? lang 'hopscript) "${")
       (set! column (+fx 2 column))
       (add! (<SPAN> :class "fontifier-prog-server" "$"))
       (add! "{")
       (ignore))
      
      ;; TODO: probably not spec-conform
      ((: #\" (* (or (out #\" #\\ #\Newline) (: #\\ all))) #\")
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-string" str))
	  (ignore)))
      ((: #\' (* (or (out #\' #\\ #\Newline) (: #\\ all))) #\')
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-string" str))
	  (ignore)))
      
      ((when (memq lang '(hopscript javascript))
	  (: #\/ (* (or (out #\/ #\Newline) (: #\\ #\/) (: #\[ #\/ #\]))) #\/))
       (let ((str (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class "fontifier-prog-string" str))
	  (ignore)))
      
      ;; Identifiers and Keywords
      ((: id_start (* id_part))
       (let* ((symbol (the-symbol))
	      (symbol-str (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (cond
	     ((and (eq? lang 'hopscript) (eq? symbol 'post))
	      (add! (<SPAN> :class "fontifier-prog-server post" symbol-str))
	      (ignore))
	     ((and (eq? lang 'hopscript) (memq symbol '(signal broadcast)))
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-client " symbol-str)
		       symbol-str))
	      (ignore))
	     ((and (eq? lang 'hopscript) (memq symbol '(service tag)))
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-define " symbol-str)
		       symbol-str))
	      (ignore))
	     ((and (eq? symbol 'function) (memq lang '(hopscript javascript)))
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-define symbol-str")
		       symbol-str))
	      (ignore))
	     ((and (getprop symbol 'javascript) (memq lang '(hopscript javascript)))
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-reserved " symbol-str)
		       symbol-str))
	      (ignore))
	     ((and (getprop symbol 'c) (eq? lang 'c))
	      (add! (<SPAN> :class
		       (string-append "fontifier-prog-reserved " symbol-str)
		       symbol-str))
	      (ignore))
	     (else
	      (add! symbol-str)
	      (ignore)))))
      
      ;; Identifiers and Keywords
      ((when (eq? lang 'hopscript) (: id_start (* (or #\- id_part)) #\:))
       (let ((kwd (xml-string-encode (the-string))))
	  (set! column (+fx (the-length) column))
	  (add! (<SPAN> :class (string-append "fontifier-prog-keyword " kwd)
		   kwd))
	  (ignore)))
      
      ;; TODO: add regular expressions
      (all
       (set! column (+fx (the-length) column))
       (add! (xml-string-encode (the-string)))
       (ignore))
      
      ;; error
      (else
       (let ((c (the-failure)))
	  (if (eof-object? c)
	      (reverse! res)
	      (raise
		 (instantiate::&io-parse-error
		    (proc "js-fontifier")
		    (msg "Javascript syntax: 'Unexpected char'")
		    (obj c))))))))

;*---------------------------------------------------------------------*/
;*    js-fontifier ...                                                 */
;*---------------------------------------------------------------------*/
(define (js-fontifier ip #!key line-begin line-end)
   (js-lexer-init!)
   (read/rp *js-lexer* ip 'javascript line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1)) '() 0))

;*---------------------------------------------------------------------*/
;*    hopscript-fontifier ...                                          */
;*---------------------------------------------------------------------*/
(define (hopscript-fontifier ip #!key line-begin line-end)
   (js-lexer-init!)
   (read/rp *js-lexer* ip 'hopscript line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1)) '() 0))

;*---------------------------------------------------------------------*/
;*    c-fontifier ...                                                  */
;*---------------------------------------------------------------------*/
(define (c-fontifier ip #!key line-begin line-end)
   (c-lexer-init!)
   (read/rp *js-lexer* ip 'c line-begin line-end
      (or (not (integer? line-begin)) (=fx line-begin 1)) '() 0))

;*---------------------------------------------------------------------*/
;*    line-number ...                                                  */
;*---------------------------------------------------------------------*/
(define (line-number prog lnum id)
   
   (define (digit n)
      (cond
	 ((< n 10) 1)
	 ((< n 100) 2)
	 ((< n 1000) 3)
	 ((< n 10000) 4)
	 (else 5)))

   (define (flatten lst)
      (let flatten ((lst lst)
		    (res '()))
	 (cond
	    ((null? lst)
	     (reverse! res))
	    ((pair? (car lst))
	     (flatten (append (car lst) (cdr lst)) res))
	    (else
	     (flatten (cdr lst) (cons (car lst) res))))))

   (define (next-line num prog)
      (let loop ((n '())
		 (prog prog)
		 (num num))
	 (cond
	    ((null? prog)
	     ;; done with the whole program
	     (values num (reverse n) prog))
	    ((string? (car prog))
	     ;; a token
	     (let ((i (string-index "\n" (car prog))))
		(if i
		    (let ((s0 (substring (car prog) 0 (+fx i 1)))
			  (s1 (substring (car prog) (+fx i 1))))
		       (values num (reverse (cons s0 n)) (cons s1 (cdr prog))))
		    (loop (cons (car prog) n) (cdr prog) num))))
	    ((isa? (car prog) JsStringLiteral)
	     (loop n (cons (js-jsstring->string (car prog)) (cdr prog)) num))
	    ((vector? (car prog))
	     ;; a line number
	     (loop n (cdr prog) (vector-ref (car prog) 0)))
	    (else
	     ;; a tag
	     (loop (cons (car prog) n) (cdr prog) num)))))

   (define (empty-line? line)
      (cond
	 ((null? line) #t)
	 ((equal? (car line) "") (empty-line? (cdr line)))
	 (else #f)))
   
   (define (split-lines prog num)
      (multiple-value-bind (num line next)
	 (next-line num prog)
	 (if (null? next)
	     (if (empty-line? line)
		 '()
		 (list (cons num line)))
	     (cons (cons num line) (split-lines next (+ num 1))))))

   (if (integer? lnum)
       (let ((lines (split-lines (flatten prog) lnum)))
	  (when (pair? lines)
	     (let* ((num (caar (last-pair lines)))
		    (fmt (format "~~~ad" (digit num))))
		(map (lambda (nl)
			(let* ((i (car nl))
			       (l (cdr nl)))
			   (if id
			       (let ((name (format "~a-~a" id i)))
				  (list (<A> :name name)
				     (<SPAN> :class "fontifier-prog-line-number"
					:id name
					(format fmt i)) l))
			       (list
				  (<SPAN> :class "fontifier-prog-line-number"
				     (format fmt i)) l))))
		   lines))))
       prog))

;*---------------------------------------------------------------------*/
;*    The return value for dynamic-load                                */
;*---------------------------------------------------------------------*/
hopscript
