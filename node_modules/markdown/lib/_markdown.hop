;*=====================================================================*/
;*    .../hop/3.2.x/node_modules/markdown/lib/_markdown.hop            */
;*    -------------------------------------------------------------    */
;*    Author      :  Manuel Serrano                                    */
;*    Creation    :  Sun Jul  6 06:15:53 2014                          */
;*    Last change :  Thu Oct 26 00:23:10 2017 (serrano)                */
;*    Copyright   :  2014-17 Manuel Serrano                            */
;*    -------------------------------------------------------------    */
;*    MARKDOWN hop parser                                              */
;*=====================================================================*/

;*---------------------------------------------------------------------*/
;*    The module                                                       */
;*---------------------------------------------------------------------*/
(module _markdown

   (include "token.sch")
   
   (library hopscript hop hopwidget nodejs)
   
   (static  (class MDState
	       tag::symbol
	       ctor::procedure
	       (elements::pair-nil (default '()))
	       (attributes::pair-nil (default '()))
	       (value::obj (default #f))
	       (wrapper::obj (default #f))
	       (parent (default #f)))

	    (class MDBlock::MDState
	       (bob::bool (default #t)))
	    
	    (class MDSpan::MDState))

   (export (class MarkdownInclude
	      (val read-only)))
   
   (import markdown_md)
   
   (export (hopscript ::JsGlobalObject ::JsObject ::JsObject ::JsObject)
	   
	   <MARKDOWN:PARSE-ERROR>
	   <MARKDOWN:H1>
	   <MARKDOWN:H2>
	   <MARKDOWN:H3>
	   <MARKDOWN:H4>
	   <MARKDOWN:H5>
	   <MARKDOWN:CODE>
	   <MARKDOWN:PRE>
	   <MARKDOWN:BLOCKQUOTE>
	   <MARKDOWN:LI>
	   <MARKDOWN:UL>
	   <MARKDOWN:OL>
	   <MARKDOWN:HR>
	   <MARKDOWN:EM>
	   <MARKDOWN:STRONG>
	   <MARKDOWN:P>
	   <MARKDOWN:A>
	   <MARKDOWN:IMG>
	   
;* 	   (markdown-parse ::input-port charset this scope fontifier)  */
;* 	   (xml->markdown ::obj ::pair-nil)                            */
	   ))

;*---------------------------------------------------------------------*/
;*    js-bind-tag! ...                                                 */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tag! %this obj tag)
   `(begin
       (js-bind! ,%this ,obj ',tag
	  :value (js-make-function ,%this
		    (lambda (this attrs . nodes)
		       (if (isa? attrs JsObject)
			   (if (null? nodes)
			       (apply ,(symbol-append '< tag '>)
				  (js-jsobject->keyword-plist attrs ,%this))
			       (apply ,(symbol-append '< tag '>)
				  (append
				     (js-jsobject->keyword-plist attrs ,%this)
				     nodes)))
			   (apply ,(symbol-append '< tag '>)
			      nodes)))
		    2 ',tag)
	  :writable #f
	  :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    js-bind-tags! ...                                                */
;*---------------------------------------------------------------------*/
(define-macro (js-bind-tags! %this obj . tags)
   `(begin
       ,@(map (lambda (tag)
		 `(js-bind-tag! ,%this ,obj ,tag))
	    tags)))
   
;*---------------------------------------------------------------------*/
;*    hopscript ...                                                    */
;*---------------------------------------------------------------------*/
(define (hopscript %this this scope module)
   (with-access::JsGlobalObject %this (__proto__)
      
      (define js-markdown-prototype
	 (instantiate-JsObject
	    (__proto__ __proto__)))
      
      (define exports (js-get module 'exports %this))

      ;; bind the module in the markdown scope
      (js-put! scope 'module module #f %this)

      ;; include objects
      (js-bind! %this exports 'include
	 :value (js-make-function %this
		   (lambda (this val)
		      (instantiate::MarkdownInclude (val val)))
		   1 'include)
	 :writable #f
	 :enumerable #f)
      
      ;; XML tags
      (js-bind-tags! %this exports
	 MARKDOWN:H1 MARKDOWN:H2 MARKDOWN:H3 MARKDOWN:H4 MARKDOWN:H5
	 MARKDOWN:PRE MARKDOWN:CODE MARKDOWN:BLOCKQUOTE MARKDOWN:LI
	 MARKDOWN:UL MARKDOWN:OL MARKDOWN:HR MARKDOWN:EM MARKDOWN:STRONG
	 MARKDOWN:P MARKDOWN:A MARKDOWN:IMG)
      
      ;; load
      (js-bind! %this exports 'load
	 :value (js-make-function %this
		   (lambda (this file charset fontifier)
		      (let* ((scope (nodejs-new-scope-object %this))
			     (worker (js-current-worker))
			     (path (js-tostring file %this))
			     (module (nodejs-module path path worker %this))
			     (charset (if (eq? charset (js-undefined))
					  (hop-locale)
					  (js-tostring charset %this))))
			 ;; bind global properties in the document scope
			 (js-put! scope 'module module #f %this)
			 (js-put! module 'filename file #f %this)
			 ;; parse the markdown file
			 (let* ((xml (markdown-parse-file
					path charset
					%this scope
					fontifier))
				(res (instantiate-JsObject
					(__proto__ js-markdown-prototype))))
			    (js-put! res 'filename file #f %this)
			    (js-put! res 'charset charset #f %this)
			    (js-put! res 'XML xml #f %this)
			    res)))
		   3 'load)
	 :writable #f
	 :enumerable #f)
      
      ;; eval
      (js-bind! %this exports 'eval
	 :value (js-make-function %this
		   (lambda (this obj charset fontifier)
		      (let ((scope (nodejs-new-scope-object %this)))
			 ;; bind global properties in the document scope
			 (js-put! scope 'module module #f %this)
			 ;; parse the markdown file
			 (let* ((xml (markdown-parse-obj obj
					(if (eq? charset (js-undefined))
					    (hop-locale)
					    (js-tostring charset %this))
					%this scope
					fontifier))
				(res (instantiate-JsObject
					(__proto__ js-markdown-prototype))))
			    (js-put! res 'obj obj #f %this)
			    (js-put! res 'charset charset #f %this)
			    (js-put! res 'XML xml #f %this)
			    res)))
		   3 'eval)
	 :writable #f
	 :enumerable #f)
      
      ;; toMarkdown
      (js-bind! %this js-markdown-prototype 'toMarkdown
	 :value (js-make-function %this
		   (lambda (this)
		      (xml->markdown (js-get this 'XML %this) '()))
		   0 'toMarkdown)
	 :writable #f
	 :enumerable #f)))

;*---------------------------------------------------------------------*/
;*    eval-markdown ...                                                */
;*---------------------------------------------------------------------*/
(define (eval-markdown exp ctx)
   (if (pair? ctx)
       (eval `(let (,ctx) ,exp))
       (eval exp)))

;*---------------------------------------------------------------------*/
;*    flatten ...                                                      */
;*---------------------------------------------------------------------*/
(define (flatten l ctx)
   (cond
      ((null? l) l)
      ((pair? l) (append (flatten (car l) ctx) (flatten (cdr l) ctx)))
      ((isa? l JsArray) (jsarray->list l ctx))
      (else (list l))))

;*---------------------------------------------------------------------*/
;*    MDState-tag ...                                                  */
;*---------------------------------------------------------------------*/
(define (MDState-tag s)
   (with-access::MDState s (tag)
      tag))

;*---------------------------------------------------------------------*/
;*    markdown-debug ...                                               */
;*---------------------------------------------------------------------*/
(define markdown-debug
   (let ((env (getenv "NODE_DEBUG")))
      (and (string? env) (string-contains env "markdown"))))

;*---------------------------------------------------------------------*/
;*    <MARKDOWN:PARSE-ERROR> ...                                       */
;*---------------------------------------------------------------------*/
(define (<MARKDOWN:PARSE-ERROR> str)
   (<SPAN> :hssclass "hop-parse-error"
      str))

;*---------------------------------------------------------------------*/
;*    markdown-name ...                                                */
;*---------------------------------------------------------------------*/
(define (markdown-name expr)
   (let* ((s (with-output-to-string
		(lambda ()
		   (let loop ((e expr))
		      (cond
			 ((pair? e)
			  (for-each loop e))
			 ((isa? e xml-markup)
			  (with-access::xml-markup e (body)
			     (loop body)))
			 ((null? e)
			  #unspecified)
			 (else
			  (display e)))))))
	  (s2 (pregexp-replace* "  |\n" s " ")))
      (pregexp-replace* "^ +| +$" s2 "")))

;*---------------------------------------------------------------------*/
;*    markdown-read-error ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-read-error msg obj port)
   (raise
      (instantiate::&io-read-error
	 (fname (input-port-name port))
	 (location (input-port-position port))
	 (proc "markdown-parser")
	 (msg msg)
	 (obj obj))))

;*---------------------------------------------------------------------*/
;*    markdown-parse-error ...                                         */
;*---------------------------------------------------------------------*/
(define (markdown-parse-error msg obj ctx)
   (match-case ctx
      ((at ?fname ?loc)
       (raise
	  (instantiate::&io-parse-error
	     (fname fname)
	     (location loc)
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))
      ((? input-port?)
       (raise
	  (instantiate::&io-parse-error
	     (fname (input-port-name ctx))
	     (location (input-port-position ctx))
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))
      (else
       (raise
	  (instantiate::&io-parse-error
	     (proc "markdown-parser")
	     (msg msg)
	     (obj obj))))))

;*---------------------------------------------------------------------*/
;*    Markdown tags                                                    */
;*---------------------------------------------------------------------*/
(define-macro (define-markdown-tag id . clazz)
   (let ((cla (if (pair? clazz)
		  (string-append (car clazz) " markdown ")
		  "markdown ")))
      `(define-tag ,(symbol-append '|<MARKDOWN:| id '>)
	  ((class #f)
	   (attrs)
	   body)
	  (apply ,(symbol-append '< id '>)
	     :class (cond
		       ((string? class)
			(string-append ,cla class))
		       ((isa? class JsStringLiteral)
			(string-append ,cla (js-jsstring->string class)))
		       (else
			,cla))
	     attrs body))))

(define-markdown-tag H1 "toc")
(define-markdown-tag H2 "toc")
(define-markdown-tag H3 "toc")
(define-markdown-tag H4 "toc")
(define-markdown-tag H5 "toc")
(define-markdown-tag CODE)
(define-markdown-tag PRE)
(define-markdown-tag BLOCKQUOTE)
(define-markdown-tag LI)
(define-markdown-tag UL)
(define-markdown-tag OL)
(define-markdown-tag HR)
(define-markdown-tag EM)
(define-markdown-tag STRONG)
(define-markdown-tag P)
(define-markdown-tag A)
(define-markdown-tag IMG)

;*---------------------------------------------------------------------*/
;*    normalize-string ...                                             */
;*---------------------------------------------------------------------*/
(define (normalize-string str)
   (let ((b (string-skip str " \t"))
	 (e (string-skip-right str " \t")))
      (cond
	 ((not b)
	  "")
	 ((=fx b 0)
	  (if (=fx e (-fx (string-length str) 1))
	      str
	      (string-shrink! str (+fx 1 e))))
	 ((=fx e (-fx (string-length str) 1))
	  (substring str b))
	 (else
	  (substring str b (+fx 1 e))))))

;*---------------------------------------------------------------------*/
;*    remove-surrounding-spaces ...                                    */
;*---------------------------------------------------------------------*/
(define (remove-surrounding-spaces l)
   (let loop ((l l)
	      (mode 'all))
      (cond
	 ((string? l)
	  (case mode
	     ((all)
	      (normalize-string l))
	     ((head)
	      (let ((b (string-skip l " \t")))
		 (if b
		     (substring l b)
		     l)))
	     ((tail)
	      (let ((b (string-skip-right l " \t")))
		 (if b
		     (string-shrink! l (+fx b 1))
		     "")))
	     (else
	      l)))
	 ((pair? l)
	  (if (null? (cdr l))
	      (list (loop (car l) mode))
	      (cons (loop (car l) 'head)
		    (let liip ((l (cdr l)))
		       (if (null? (cdr l))
			   (list (loop (car l) 'tail))
			   (cons (car l) (liip (cdr l))))))))
	 (else
	  l))))


;*---------------------------------------------------------------------*/
;*    section-tag ...                                                  */
;*---------------------------------------------------------------------*/
(define (section-tag depth)
   (case depth
      ((5) <MARKDOWN:H5>)
      ((4) <MARKDOWN:H4>)
      ((3) <MARKDOWN:H3>)
      ((2) <MARKDOWN:H2>)
      ((1) <MARKDOWN:H1>)
      (else #f)))
   
;*---------------------------------------------------------------------*/
;*    *comment-grammar* ...                                            */
;*---------------------------------------------------------------------*/
(define *comment-grammar*
   (regular-grammar ()
      ((: (* (out "-\n\r")))
       (ignore))
      ((: (* (out "-\n\r")) #\Newline)
       #f)
      ("-"
       (ignore))
      ((: "-*-" (* all) #\Newline)
       (let ((s (the-string)))
	  (let ((i (string-contains s "-*-" 3)))
	     (when (fixnum? i)
		(let ((j (string-contains-ci s "coding:" 3)))
		   (when (and (fixnum? j) (<fx j i))
		      (let ((n (string-skip s " \t"
				  (+fx j (string-length "coding:")))))
			 (when (fixnum? n)
			    (let ((m (string-index s " " n)))
			       (when (fixnum? m)
				  (string->symbol
				     (substring s n m))))))))))))))

;*---------------------------------------------------------------------*/
;*    *tab-code-block-grammar* ...                                     */
;*---------------------------------------------------------------------*/
(define *tab-code-block-grammar*
   (regular-grammar ((line (or (* (out "\r\n,$"))
			       (: (* (out "\r\n,$")) ",")
			       (: (* (out "\r\n,$")) "$")
			       (+ (: (* (out "\r\n,$")) (? (: "," (out "(")))))
			       (+ (: (* (out "\r\n,$")) (? (: "$" (out "{")))))))
		     (crlf (or "\n" "\r\n"))
		     indent lines conv this scope)
      
      (define (the-html-substring start end)
       (if (> end start)
	   (html-string-encode (conv (the-substring start end)))
	   ""))

      ;; newline
      ((: (+ crlf) (: (or "\t" "    ") line crlf))
       (let* ((s (the-string))
	      (i (string-skip s "\r\n")))
	  (set! lines
	     (cons* (substring s (+fx i indent) (the-length))
		(substring s 0 i)
		lines)))
       (rgc-context)
       (ignore))
      ;; plain line of code
      ((bol (: (or "\t" "    ") line crlf))
       (set! lines (cons (the-html-substring indent (the-length)) lines))
       (rgc-context)
       (ignore))
      ((context hop (: line crlf))
       (set! lines (cons (the-html-substring 0 (the-length)) lines))
       (rgc-context)
       (ignore))
      ;; embedded hop
      ((bol (: (or "\t" "    ") line ",(" ))
       (let* ((s (the-string))
	      (i (string-skip s "\r\n")))
	  (set! lines
	     (cons* (substring s (+fx i indent) (-fx (the-length) 2))
		(substring s 0 i)
		lines)))
       (rgc-buffer-unget-char (the-port) (char->integer #\())
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (set! lines
		(cons (<MARKDOWN:PARSE-ERROR> (string (the-failure))) lines)))
	  (let ((expr (hop-read (the-port))))
	     (with-handler
		(lambda (e)
		   (exception-notify e)
		   (set! lines
		      (cons
			 (<SPAN> :hssclass "hop-eval-error"
			    (with-output-to-string
			       (lambda ()
				  (write expr))))
			 lines)))
		(set! lines (cons (eval-markdown expr this) lines)))))
       (rgc-context 'hop)
       (ignore))
      ;; embedded hopjs
      ((bol (: (or "\t" "    ") line "${"))
       (let* ((s (the-string))
	      (i (string-skip s "\r\n")))
	  (set! lines
	     (cons* (substring s (+fx i indent) (-fx (the-length) 2))
		(substring s 0 i)
		lines)))
       (rgc-buffer-unget-char (the-port) (char->integer #\{))
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (set! lines (cons (<SPAN> :hssclass "hop-eval-error" e) lines)))
	  (set! lines
	     (cons (%js-eval (the-port) 'repl this (js-undefined) scope)
		lines)))
       (rgc-context 'hop)
       (ignore))
      (else
       (unless (eof-object? (the-failure))
	  (rgc-buffer-unget-char (the-port) (char->integer (the-failure))))
       (reverse! lines))))

;*---------------------------------------------------------------------*/
;*    fontify-code ...                                                 */
;*---------------------------------------------------------------------*/
(define (fontify-code lines lang this scope fontifier id)
   
   (define (fontify lines lang)
      (let ((f (when (isa? fontifier JsObject)
		  (js-get fontifier lang this))))
	 (if (isa? f JsFunction)
	     (js-call1 this f (js-undefined) (js-stringlist->jsstring lines))
	     lines)))
   
   (let ((i (string-index lang #\:)))
      (if i
	  (let ((lang (string->symbol (substring lang 0 i)))
		(lnum (string->number (substring lang (+fx i 1))))
		(f (js-get fontifier 'lineNumber this)))
	     (if (integer? lnum)
		 (js-call3 this f (js-undefined) (fontify lines lang) lnum id)
		 (fontify lines lang)))
	  (fontify lines lang))))

;*---------------------------------------------------------------------*/
;*    *quote-code-block-grammar* ...                                   */
;*---------------------------------------------------------------------*/
(define *quote-code-block-grammar*
   (regular-grammar ((line (+ (out "`\n,$")))
		     (crlf (or "\n" "\r\n"))
		     lines conv this scope eof)

      (define (include-string str::bstring lines)
         ;;; include a new sequence of characters
	 (call-with-input-string str
	    (lambda (ip)
	       (let loop ((lines '()))
		  (let ((line (read-line-newline ip)))
		     (if (eof-object? line)
			 lines
			 (loop (cons line lines))))))))
      
      ;; newline
      ((+ crlf)
       (set! lines (cons (the-string) lines))
       (ignore))
      ;; punctuation
      ((** 1 2 (in "*_`"))
       (set! lines (cons (the-string) lines))
       (ignore))
      ((or #\$ #\, (** 1 2 #\`))
       (set! lines (cons (the-string) lines))
       (ignore))
      ;; plain line of code
      ((: line)
       (set! lines (cons (conv (the-substring 0 (the-length))) lines))
       (ignore))
      ((bol (: "```" (? #\Return) #\Newline))
       ;; skip the last crlf
       (if (pair? lines)
	   (reverse! (cdr lines))
	   '()))
      ((bol "${")
       (rgc-buffer-unget-char (the-port) (char->integer #\{))
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (set! lines (cons (<SPAN> :hssclass "hop-eval-error" e) lines)))
	  (let ((val (%js-eval (the-port) 'repl this (js-undefined) scope)))
	     (cond
		((string? val)
		 (set! lines (include-string val lines)))
		((isa? val JsStringLiteral)
		 (set! lines (include-string (js-tostring val this) lines)))
		(else
		 (cons val lines)))
	     (ignore))))
      (else
       (if (eof-object? (the-failure))
	   (if eof
	       lines
	       (markdown-read-error "unexpected eof" (the-failure) (the-port)))
	   (markdown-read-error "Illegal character" (string (the-failure)) (the-port))))))

;*---------------------------------------------------------------------*/
;*    state-add! ...                                                   */
;*---------------------------------------------------------------------*/
(define (state-add! state::MDState e)
   (unless (eq? e (js-undefined))
      (with-access::MDState state (elements)
	 (set! elements (cons e elements)))))

;*---------------------------------------------------------------------*/
;*    *markdown-grammar* ...                                           */
;*---------------------------------------------------------------------*/
(define *markdown-grammar*
   (regular-grammar ((punct (in "+=/-$~#%!'\""))
		     (punct+ (or punct #\newline #\return))
		     (blank (in "<>^|:~;,{} ."))
		     (letter (out "<>+^|*=/_-$#%:~;,\"`'[](){}! \\\n\t0123456789"))
		     (letter+ (or letter digit))
		     (ident (: #\: (+ letter) (in " \t\n\r")))
		     (crlf (or "\n" "\r\n"))
		     this scope)

      ;; utf-8 bom
      ((bof (: #a239 #a187 #a191))
       (token 'CHARSET 'UTF-8 3))
      
      ;; utf-16 big endian
      ((bof (: #a254 #a255))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (token 'CHARSET 'UCS-2 2))
      
      ;; utf-16 little endian
      ((bof (: #a255 #a254))
       ;; MS 23nov2011: CARE I don't know if ucs-2 is big or little endian
       (token 'CHARSET 'UCS-2 2))
      
      ;; comments
      ((bol (or ";*" ";;"))
       (let ((cset (read/rp *comment-grammar* (the-port))))
	  (token 'CHARSET cset (the-length))))
      ;; HTML comments
      ((: "<!--" (+ (or (out #\-) (: #\- (out #\-)) (: "--" (out #\>)))) "-->")
       (ignore))
      
      ;; continuation lines
      ((: #\\ (? #\Return) #\Newline)
       (ignore))

      ;; ident/class
      ((: "[:" (+ (out "]@")) "]")
       (token 'IDCLA (cons (the-substring 2 -1) #f) (the-length)))
      ;; class
      ((: "[:@" (+ (out "]@")) "]")
       (token 'IDCLA (cons #f (the-substring 3 -1)) (the-length)))
      ((: "[:" (+ (out "]@\n")) "@" (+ (out "]\n@")) "]")
       (let* ((str (the-substring 2 -1))
	      (i (string-index str #\@))
	      (ident (substring str 0 i))
	      (clazz (substring str (+fx i 1) (string-length str))))
	  (token 'IDCLA (cons ident clazz) (the-length))))
      
      ;; url
      ((: "<" (+ (out "> \t\n")) "://" (+ (out "> \t\n")) ">")
       (token 'URL (the-substring 1 -1) (the-length)))
      
      ;; blank lines, paragraph
      ((: (? #\Return) #\Newline)
       (token 'NEWLINE (the-string) (the-length)))
      ;; blank lines, paragraph
      ((>= 2 (: (* (or (in " \t\n") "\r\n")) (? "\r") "\n"))
       (token 'STOP (the-string) (the-length)))
      
      ;; horizontal rules
      ((bol (: (>= 3 (: (in "*-") (* #\space))) crlf))
       (token 'HR (the-string) (the-length)))

      ;; sections
      ((bol (: (+ #\#) (* (in " \t")) (: (out #\#) (* all)) #\Newline))
       (let* ((str (the-string))
	      (len (the-length))
	      (depth (string-skip str "#"))
	      (end (string-skip-right str "\r\n#"))
	      (j (string-skip str " \t" depth))
	      (title (substring str j (if end (+fx end 1) len))))
	  (token 'SECTION (cons depth title) (the-length))))

      ;; second form of sections
      ((bol (: (+ (out #\# #\Newline)) #\Newline (+ #\=) #\Newline))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\Newline))
		 (title (substring str 0 i)))
	     (token 'SECTION (cons 1 title) (the-length)))))
      ((bol (: (+ (out #\# #\Newline)) #\Newline (+ #\-) #\Newline))
       (let ((str (the-string)))
	  (let* ((i (string-index str #\Newline))
		 (title (substring str 0 i)))
	     (token 'SECTION (cons 2 title) (the-length)))))

      ;; code block mode
      ((bol (: (or "    " "\t") (* (in " \t")) (out "*- \t\n")))
       (let ((str (the-string)))
	  (token 'PRE str (the-length))))

      ;; program
      ((bol (: "```" (* (out "\n")) #\Newline))
       (let* ((prog (the-substring 3 -1))
	      (i (string-skip-right prog " \t")))
	  (token 'PROG (if i (substring prog 0 (+fx i 1)) prog)
	     (-fx (the-length) 3))))
      
      ;; itemize
      ((bol (: (* " ") (in "*+-") (** 1 3 " ")))
       (let ((str (the-string)))
	  (token 'UL (cons (string-skip str " ") str) (the-length))))
      ;; enumerate
      ((bol (: (* " ") (+ digit) #\. (** 1 3 " ")))
       (let ((str (the-string)))
	  (token 'OL (cons (string-skip str " ") str) (the-length))))

      ;; blockquote
      ((bol (+ (: (* (in " \t")) ">" (in " \t"))))
       (token 'BLOCKQUOTE (the-string) (the-length)))

      ;; code
      ("`"
       (token 'CODE "`" 1))
      ("``"
       (token 'CODE2 "``" 2))

      ;; emphasize/strong
      ((: "_" (out " _*\r\n\t:.;,?!"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O_ "_" 1)))
      ((: "__" (out " _*\r\n\t:.;,?!"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O__ "__" 2)))
      ((: "*" (out " *_\r\n\t:.;,?!"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O* "*" 1)))
      ((: "**" (out " *_\r\n\t:.;,?!"))
       (let ((str (the-string)))
	  (rgc-buffer-unget-char (the-port)
	     (char->integer (string-ref str (-fx (the-length) 1))))
	  (token 'O** "**" 2)))
      
      ("_" 
       (token 'O_ (the-string) 1))
      ("__" 
       (token 'O__ (the-string) 2))
      ("*" 
       (token 'O* (the-string) 1))
      ("**" 
       (token 'O** (the-string) 2))

      ;; links
      (#\[
       (token 'OBRA (the-string) 1))
      (#\]
       (token 'CBRA (the-string) 1))
      (#\(
       (token 'OPAR (the-string) 1))
      (#\)
       (token 'CPAR (the-string) 1))

      ;; image
      ("!["
       (token 'IMAGE (the-string) 2))
       
      ;; embedded hop
      (",("
       (rgc-buffer-unget-char (the-port) (char->integer #\())
       (with-handler
	  (lambda (e)
	     (exception-notify e)
	     (token 'ERROR e 0))
	  (let ((expr (hop-read (the-port))))
	     (with-handler
		(lambda (e)
		   (exception-notify e)
		   (token 'ERROR e 0))
		(token 'HOP (eval-markdown expr this) 0)))))

       ;; embedded hopjs
       ("${"
	(rgc-buffer-unget-char (the-port) (char->integer #\{))
	(with-handler
	   (lambda (e)
	      (exception-notify e)
	      (token 'ERROR e 0))
	   (let ((val (%js-eval (the-port) 'repl this (js-undefined) scope)))
	      (cond
		 ((isa? val JsStringLiteral)
		  (let ((s (js-jsstring->string val)))
		     (rgc-buffer-insert-substring! (the-port) s 0
			(string-length s))
		     (ignore)))
		 ((string? val)
		  (rgc-buffer-insert-substring! (the-port) val 0
		     (string-length val))
		  (ignore))
		 (else
		  (token 'HOP val 0))))))

      ;; escaped characters
      ((: "\\" (in ".`*_{}[]()#+-!>,~$"))
       (token 'TEXT (the-substring 1 2) (the-length)))
      
      ;; single escape characters
      ((or punct blank #\space #\\)
       (token 'TEXT (the-string) (the-length)))

      ;; simple text
      ((: (? (** 1 3 (in " \t"))) letter (+ (or letter+ (: punct+ letter+) (: #\space letter+))))
       (token 'TEXT (the-string) (the-length)))
      ((+ (or digit letter))
       (token 'TEXT (the-string) (the-length)))
      
      (else
       (let ((c (the-failure)))
	  (cond
	     ((eof-object? c)
	      (token 'EOF c 0))
	     (else
	      (markdown-read-error "Unexpected character" (the-failure)
		 (the-port))))))))

;*---------------------------------------------------------------------*/
;*    markdown-parse ...                                               */
;*---------------------------------------------------------------------*/
(define (markdown-parse ip cset this scope fontifier)

   (define unresolved-refs
      '())

   (define definitions
      (make-hashtable))

   (define (resolve-references! dom)
      (for-each (lambda (unresolved)
		   (let* ((id (car unresolved))
			  (node (cadr unresolved))
			  (def (hashtable-get definitions id)))
		      (if def
			  (begin
			     (dom-set-attribute! node "href" (car def))
			     (when (cdr def)
				(dom-set-attribute! node "title" (cdr def))))
			  (parse-token-error "Unbound reference"
			     (caddr unresolved)))))
	 unresolved-refs))

   (define charset
      (cond
	 ((string? cset)
	  (string->symbol cset))
	 ((isa? cset JsStringLiteral)
	  (string->symbol (js-jsstring->string cset)))
	 (else
	  cset)))
   
   (define (parse-token-error msg token::pair)
      (let ((msg (if (eq? (token-tag token) 'BAD)
		     (cadr token)
		     (format msg (token-tag token))))
	    (obj (if (eq? (token-tag token) 'BAD)
		     (cddr token)
		     (token-value token))))
	 (match-case (token-loc token)
	    ((at ?fname ?loc)
	     (raise
		(instantiate::&io-parse-error
		   (proc "markdown")
		   (msg msg)
		   (obj obj)
		   (fname fname)
		   (location loc))))
	    (else
	     (raise
		(instantiate::&io-parse-error
		   (proc "markdown")
		   (msg msg)
		   (obj obj)))))))
   
   (define (parse-error msg obj)
      (let ((fname (input-port-name ip))
	    (loc (input-port-position ip)))
	 (raise
	    (instantiate::&io-parse-error
	       (proc "markdown")
	       (msg msg)
	       (obj (read-line ip))
	       (fname fname)
	       (location loc)))))
   
   (define *peeked-tokens* '())
   (define *previous-token-type* #unspecified)
   
   (define (peek-token)
      (if (null? *peeked-tokens*)
	  (begin
	     (set! *peeked-tokens*
		(list (read/rp *markdown-grammar* ip this scope)))
	     (car *peeked-tokens*))
	  (car *peeked-tokens*)))
   
   (define (token-push-back! token)
      (set! *peeked-tokens* (cons token *peeked-tokens*)))
   
   (define (peek-token-type)
      (car (peek-token)))
   
   (define (peek-token-value)
      (cdr (peek-token)))
   
   (define (consume-token! type)
      (let ((token (consume-any!)))
	 (if (eq? (token-tag token) type)
	     token
	     (parse-token-error 
		(format "expected \"~a\" got \"~a\"" type
		   (token-tag token))
		token))))
   
   (define (consume! type)
      (cdr (consume-token! type)))
   
   (define (consume-any!)
      (let ((res (peek-token)))
	 (set! *previous-token-type* (car res))
	 (set! *peeked-tokens* (cdr *peeked-tokens*))
	 res))
   
   (define conv
      (if (procedure? charset)
	  charset
	  (charset-converter! charset (hop-charset))))

   (define (parse-span-elements state::MDState tag end)
      (cond
	 ((eq? (peek-token-type) end)
	  (consume-any!)
	  (values 'span
	     (apply tag state.attributes (reverse! state.elements))))
	 ((span state)
	  (parse-span-elements state tag end))
	 (else
	  (case (peek-token-type)
	     ((NEWLINE SOP)
	      (values 'unwind state))
	     (else
	      (values 'unwind state))))))

   (define (parse-span state::MDState tag end cleanup #!optional wrapper)
      (let ((sstate::MDState (instantiate::MDState
				(tag 'span)
				(ctor list)
				(wrapper wrapper))))
	 (multiple-value-bind (retcode val)
	    (parse-span-elements sstate tag end)
	    (case retcode
	       ((span)
		(state-add! state val))
	       ((unwind)
		(set! state.attributes
		   (append sstate.attributes state.attributes))
		(state-add! state cleanup)
		(for-each (lambda (e)
			     (state-add! state e))
		   sstate.elements))
	       (else
		(tprint "UNKNOWN RETCODE " retcode))))))

   (define (end-subblock state::MDState)
      (let ((el (state.ctor state.attributes (reverse! state.elements))))
	 (state-add! state.parent el)
	 state.parent))
      
   (define (end-blocks state::MDState)
      (let ((el (state.ctor state.attributes (reverse! state.elements))))
	 (if (not state.parent)
	     el
	     (begin
		(state-add! state.parent el)
		(end-blocks state.parent)))))
      
   (define (hr state::MDState)
      (let ((hr (case (peek-token-type)
		   ((IDCLA)
		    (let ((v (token-value (consume-any!))))
		       (<MARKDOWN:HR> :id (car v) :class (cdr v))))
		   (else
		    (<MARKDOWN:HR>)))))
	 (if (pair? state.elements)
	     (values 'blocks (list hr (end-blocks state)))
	     (values 'block hr))))

   (define (section state::MDState)
      (let* ((tok (consume-any!))
	     (sec (token-value tok)) 
	     (tag (section-tag (car sec)))
	     (title (cdr sec))
	     (id #f))
	 (if tag
	     (let* ((s (case (peek-token-type)
			  ((IDCLA)
			   (let ((v (token-value (consume-any!))))
			      (set! id (or (car v) (symbol->string (gensym))))
			      (tag :id id :class (cdr v)
				 (html-string-encode (conv title)))))
			  (else
			   (set! id (symbol->string (gensym)))
			   (tag :id id (html-string-encode (conv title)))))))
		(if (pair? state.elements)
		    (values 'blocks (list s (end-blocks state)))
		    (values 'blocks (list s))))
	     (begin
		(state-add! state (html-string-encode (conv title)))
		(block state #t)))))

   (define (li state::MDState token)
      (let ((li (instantiate::MDState
		   (tag 'LI)
		   (ctor (lambda l
			    (if (eq? state.wrapper 'P)
				(<MARKDOWN:LI> (apply <MARKDOWN:P> l))
				(apply <MARKDOWN:LI> l))))
		   (value (car (token-value token)))
		   (parent state))))
	 (block li #t)))
      
   (define (start-itemize state::MDState token)
      (let ((ul (instantiate::MDState
		   (tag (car token))
		   (ctor (if (eq? (car token) 'UL) <MARKDOWN:UL> <MARKDOWN:OL>))
		   (value (car (token-value token)))
		   (parent state))))
	 (li ul token)))

   (define (itemize state::MDState token bob::bool)
      (let loop ((state::MDState state))
	 (cond
	    ((eq? state.tag 'LI)
	     (let ((parent::MDState state.parent))
		(cond
		   ((>fx (car (token-value token)) state.value)
		    (start-itemize state token))
		   ((<fx (car (token-value token)) state.value)
		    (loop (end-subblock (end-subblock state))))
		   ((not (eq? (car token) parent.tag))
		    (loop (end-subblock (end-subblock state))))
		   ((=fx (car (token-value token)) state.value)
		    (li (end-subblock state) token))
		   (else
		    (loop (end-subblock (end-subblock state)))))))
	    ((or (memq state.tag '(hr section))
		 (and bob (eq? state.tag 'P)))
	     (start-itemize state token))
	    (else
	     (state-add! state
		(html-string-encode (cdr (token-value token))))
	     (block state #f)))))      

   (define (parse-prog-lang lang-id)
      (if (not (string-index lang-id "["))
	  (values lang-id #f #f)
	  (cond
	     ((pregexp-match "([^[]+)[ \t]*[[]:([^]]*)[]]" lang-id)
	      =>
	      (lambda (m)
		 (let* ((lang (cadr m))
			(id-class (caddr m))
			(i (string-index id-class #\@)))
		    (if (not i)
			(values lang id-class #f)
			(values lang
			   (substring id-class 0 i)
			   (substring id-class (+fx i 1)))))))
	     (else
	      (values lang-id #f #f)))))
	 
   (define (prog state::MDState lang-id)
      (multiple-value-bind (lang id class)
	 (parse-prog-lang lang-id)
	 (let* ((lines (read/rp *quote-code-block-grammar* ip
			  '() conv this scope #f))
		(body (cond
			 ((string-null? lang)
			  lines)
			 ((null? lines)
			  lines)
			 ((not (pair? lines))
			  '())
			 (else
			  (fontify-code lines lang this scope fontifier
			     (cond
				((memq :id state.attributes) => cadr)
				(else #f)))))))
	    (values 'block
	       (<MARKDOWN:PRE> :id id
		  :class (if (string? class)
			     (string-append "fontifier-prog " class)
			     "fontifier-prog")
		  (apply <MARKDOWN:CODE> body))))))

   (define (pre state::MDState token indent)
      (let ((start (token-value token)))
	 (rgc-buffer-insert-substring! ip start 0 (string-length start)))
      (let ((lines (read/rp *tab-code-block-grammar* ip
		      indent '() conv this scope)))
	 (values 'block (<MARKDOWN:PRE> (apply <MARKDOWN:CODE> lines)))))

   (define (href)
      (let (url (title #f))
	 (case (peek-token-type)
	    ((TEXT)
	     (let loop ((str (list (conv (token-value (consume-any!))))))
		(if (eq? (peek-token-type) 'TEXT)
		    (loop (cons (conv (token-value (consume-any!))) str))
		    (let* ((str (apply string-append (reverse! str)))
			   (i (string-index str #\space)))
		       (if i
			   (begin
			      (set! url (substring str 0 i))
			      (set! title (substring str
					     (+fx i 2)
					     (-fx (string-length str) 1))))
			   (set! url str))))))
	    ((HOP)
	     (set! url (token-value (consume-any!)))
	     (cond
		((memq (peek-token-type) '(HOP TEXT))
		 (set! title (token-value (consume-any!))))
		((eq? (peek-token-type) 'CPAR)
		 #f)
		(else
		 (parse-token-error "Illegal href token \"~a\"" (consume-any!))))))
	 (values url title)))

   (define (lref)
      (case (peek-token-type)
	 ((TEXT)
	  (token-value (consume-any!)))
	 ((HOP)
	  (token-value (consume-any!)))
	 (else
	  (parse-token-error "Illegal lref token \"~a\"" (consume-any!)))))

   (define (skip-spaces)
      (let loop ((res #f))
	 (if (and (eq? (peek-token-type) 'TEXT)
		  (string=? (token-value (peek-token)) " "))
	     (begin
		(consume-any!)
		(loop #t))
	     res)))

   (define (read-string bound)
      (let loop ((acc '()))
	 (let ((tok (consume-token! 'TEXT)))
	    (if (string=? (token-value tok) bound)
		(apply string-append (reverse! acc))
		(loop (cons (token-value tok) acc))))))
   
   (define (definition-url prefix)
      (let loop ((acc (list prefix)))
	 (case (peek-token-type)
	    ((TEXT O_)
	     (let ((str (token-value (consume-any!))))
		(cond
		   ((string=? str "")
		    (apply string-append (reverse! acc)))
		   ((pregexp-match "[ \r\n\t]+" str)
		    (apply string-append (reverse! acc)))
		   (else
		    (loop (cons str acc))))))
	    ((NEWLINE)
	     (apply string-append (reverse! acc)))
	    (else
	     (parse-token-error "Illegal url \"~a\"" (consume-any!))))))

   (define (definition-title)
      (when (skip-spaces)
	 (when (eq? (peek-token-type) 'TEXT)
	    (when (string-index (token-value (peek-token)) "'\"(")
	       (read-string (token-value (consume-any!)))))))
      
   (define (definition link)
      (let loop ()
	 (case (peek-token-type)
	    ((TEXT)
	     (let ((str (definition-url (token-value (consume-any!)))))
		(cond
		   ((pregexp-match "[ \t]{1,3}" str)
		    =>
		    (lambda (m)
		       (if (=fx (string-length (car m)) (string-length str))
			   (loop)
			   (let* ((url (definition-url
					  (substring str (string-length (car m)))))
				  (title (definition-title)))
			      (hashtable-put! definitions link
				 (cons url title)))))))))
	    ((URL HOP)
	     (let* ((url (token-value (consume-any!)))
		    (title (definition-title)))
		(hashtable-put! definitions link
		   (cons url title))))
	    ((NEWLINE)
	     (consume-any!)
	     (loop))
	    (else
	     (parse-token-error "Illegal definition \"~a\"" (consume-any!))))))
      

   (define (reference state::MDState ctor ctor-body)
      (let ((lstate::MDState (instantiate::MDState
				(tag 'a)
				(parent state)
				(ctor ctor-body))))
	 (if (span lstate)
	     (begin
		(consume-token! 'CBRA)
		(let loop ()
		   (case (peek-token-type)
		      ((OPAR)
		       (consume-any!)
		       (multiple-value-bind (url title)
			  (href)
			  (consume-token! 'CPAR)
			  (state-add! state
			     (ctor url title
				(ctor-body (reverse! lstate.elements))))))
		      ((TEXT)
		       (let ((tok (consume-any!)))
			  (cond
			     ((string=? (token-value tok) " ")
			      (loop))
			     ((string=? (token-value tok) ":")
			      (definition (car lstate.elements)))
			     (else
			      (parse-token-error "Illegal text reference token \"~a\""
				 tok)))))
		      ((OBRA)
		       (let* ((token (consume-any!))
			      (ref (lref))
			      (el (ctor #f #f
				     (ctor-body (reverse! lstate.elements)))))
			  (set! unresolved-refs
			     (cons (list ref el token) unresolved-refs))
			  (consume-token! 'CBRA)
			  (state-add! state el)))
		      (else
		       (parse-token-error "Illegal reference token \"~a\""
			  (consume-any!))))))
	     (parse-token-error "Illegal reference token \"~a\"" (consume-any!)))))
   
   (define (span state::MDState)
      (case (peek-token-type)
	 ((TEXT OPAR CPAR NEWLINE)
	  (state-add! state
	     (html-string-encode (conv (token-value (consume-any!)))))
	  #t)
	 ((URL)
	  (let ((url (conv (token-value (consume-any!)))))
	     (state-add! state
		(<MARKDOWN:A> :url url (html-string-encode url))))
	  #t)
	 ((O_)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'O_ val))
	  #t)
	 ((O*)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:EM> 'O* val))
	  #t)
	 ((O__)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:STRONG> 'O__ val))
	  #t)
	 ((O**)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:STRONG> 'O** val))
	  #t)
	 ((CODE)
	  (let ((val (token-value (consume-any!))))
	     (if (eq? state.wrapper 'CODE2)
		 (state-add! state "`")
		 (parse-span state <MARKDOWN:CODE> 'CODE val)))
	  #t)
	 ((CODE2)
	  (let ((val (token-value (consume-any!))))
	     (parse-span state <MARKDOWN:CODE> 'CODE2 val 'CODE2))
	  #t)
	 ((IDCLA)
	  (let ((v (token-value (consume-any!))))
	     (set! state.attributes
		(cons* :id (car v) :class (cdr v) state.attributes)))
	  #t)
	 ((OBRA)
	  (consume-any!)
	  (reference state
	     (lambda (url title body)
		(<MARKDOWN:A> :href url :title title body))
	     (lambda l l))
	  #t)
	 ((IMAGE)
	  (consume-any!)
	  (reference state
	     (lambda (src title body)
		(<MARKDOWN:IMG> :src src :title title :alt body))
	     (lambda l (caar l)))
	  #t)
	 ((HOP)
	  (state-add! state (token-value (consume-any!)))
	  #t)
	 ((ERROR)
	  (state-add! state
	     (<SPAN> :class "markdown-error"
		(with-error-to-string
		   (lambda ()
		      (exception-notify (token-value (consume-any!))))))))
	 (else
	  #f)))

   (define (blockquote-level tok)
      (let ((str (token-value tok)))
	 (let loop ((i 0)
		    (l 0))
	    (let ((ni (string-index str #\> i)))
	       (if ni
		   (loop (+fx ni 1) (+fx l 1))
		   l)))))


   (define (start-blockquote state::MDState tok level)
      (let ((nstate::MDState (instantiate::MDState
				(tag '>)
				(ctor (lambda l
					 (<MARKDOWN:BLOCKQUOTE>
					    (apply <MARKDOWN:P> l))))
				(value level)
				(parent state))))
	 (block nstate #f)))

   (define (blockquote-string str)
      (let ((i (string-index-right str ">")))
	 (substring str (+fx i 1))))
      
   (define (blockquote state::MDState token bob::bool)
      (let ((level (blockquote-level token)))
	 (let loop ((state::MDState state))
	    (cond
	       ((eq? state.tag '>)
		(let ((parent::MDState state.parent))
		   (cond
		      ((>fx level state.value)
		       (start-blockquote state token level))
		      ((=fx level state.value)
		       (state-add! state
			  (html-string-encode
			     (blockquote-string (token-value token))))
		       (block state #f))
		      ((<fx level state.value)
		       (loop (end-subblock state)))
		      (else
		       (loop (end-subblock state))))))
	       ((or (memq state.tag '(hr section))
		    (and bob (eq? state.tag 'P)))
		(start-blockquote state token level))
	       (else
		(state-add! state
		   (html-string-encode
		      (blockquote-string (token-value token))))
		(block state #f))))))

   (define (block state::MDState bob)
      (cond
	 ((eq? (peek-token-type) 'HOP)
	  (state-add! state (token-value (consume-any!)))
	  (block state #f))
	 ((eq? (peek-token-type) 'STOP)
	  (consume-any!)
	  (cond
	     ((and (eq? state.tag 'LI)
		   (eq? (peek-token-type) 'PRE)
		   (string-prefix? "        " (token-value (peek-token))))
	      (multiple-value-bind (retcode val)
		 (pre state (consume-any!) 8)
		 (state-add! state val)
		 (block state #f)))
	     ((and (eq? state.tag 'LI)
		   (let ((parent::MDState state.parent))
		      (eq? (peek-token-type) parent.tag)))
	      (let ((parent::MDState state.parent))
		 (set! parent.wrapper 'P)
		 (block state #t)))
	     (bob
	      ;; ignore newline at beginning of block
	      (block state #t))
	     (else
	      (values 'block (end-blocks state)))))
	 ((and (eq? (peek-token-type) 'NEWLINE) bob)
	  (consume-any!)
	  (block state #t))
	 ((span state)
	  (block state #f))
	 (else
	  (case (peek-token-type)
	     ((HR)
	      (consume-any!)
	      (hr state))
	     
	     ((EOF)
	      (if (pair? state.elements)
		  (values 'eof (end-blocks state))
		  (values 'eof #f)))
	     ((SECTION)
	      (section state))
	     ((UL OL)
	      (itemize state (consume-any!) bob))
	     ((BLOCKQUOTE)
	      (blockquote state (consume-any!) bob))
	     ((PROG)
	      (if bob
		  (prog state (token-value (consume-any!)))
		  (values 'block (end-blocks state))))
	     ((PRE)
	      (let ((tok (consume-any!)))
		 (cond
		    ((and bob (string-prefix? " " (token-value tok)))
		     (pre state tok  4))
		    (bob
		     (pre state tok 1))
		    ((and (eq? state.tag 'LI)
			  (string-prefix? "        " (token-value tok)))
		     (pre state tok 8))
		    ((and (eq? state.tag 'LI)
			  (string-prefix? "\t\t" (token-value tok)))
		     (pre state tok 2))
		    (else
		     (state-add! state
			(html-string-encode (token-value tok)))
		     (block state #f)))))
	     (else
	      (parse-token-error "Illegal block token \"~a\"" (consume-any!)))))))

   (define (blocks)
      (let loop ((els '()))
	 (multiple-value-bind (retcode val)
	    (let ((state (instantiate::MDState
			    (tag 'P)
			    (ctor <MARKDOWN:P>))))
	       (block state #t))
	    (case retcode
	       ((eof)
		(reverse! (if val (cons val els) els)))
	       ((block)
		(loop (cons val els)))
	       ((blocks)
		(loop (append val els)))))))
   
   (define (file)
      (when (eq? (peek-token-type) 'CHARSET)
	 (let ((cs (token-value (consume-any!))))
	    (set! conv (charset-converter! cs (hop-charset)))))
      (blocks))

   (let ((m (eval-module))
	 (f (the-loading-file)))
      (unwind-protect
	 (begin
	    (loading-file-set! (input-port-name ip))
	    (let* ((dom (file))
		   (nm (eval-module)))
	       (resolve-references! dom)
	       (unless (eq? m nm) (evmodule-check-unbound nm #f))
	       dom))
	 (begin
	    (eval-module-set! m)
	    (loading-file-set! f)))))
  
;* {*---------------------------------------------------------------------*} */
;* {*    markdown-jsobj->hop ...                                          *} */
;* {*---------------------------------------------------------------------*} */
;* (define (markdown-jsobj->hop jsobj #!key (charset (hop-locale)) %this fontifier) */
;*    (let* ((str (cond                                                */
;* 		  ((isa? jsobj JsStringLiteral) (js-jsstring->string jsobj)) */
;* 		  ((isa? jsobj JsFastBuffer) (js-jsfastbuffer->string jsobj)) */
;* 		  ((isa? jsobj JsSlowBuffer) (js-jsslowbuffer->string jsobj)) */
;* 		  (else (js-tostring jsobj %this))))                   */
;* 	  (ip (open-input-string str)))                                */
;*       (unwind-protect                                               */
;* 	 (markdown-parse ip charset %this fontifier)                   */
;* 	 (close-input-port ip))))                                      */
;*                                                                     */
;* {*---------------------------------------------------------------------*} */
;* {*    markdown-string->hop ...                                         *} */
;* {*---------------------------------------------------------------------*} */
;* (define (markdown-string->hop string #!key (charset (hop-locale)) env fontifier) */
;*    (let ((ip (open-input-string string)))                           */
;*       (unwind-protect                                               */
;* 	 (markdown-parse ip charset env fontifier)                     */
;* 	 (close-input-port ip))))                                      */

;*---------------------------------------------------------------------*/
;*    markdown-parse-file ...                                          */
;*---------------------------------------------------------------------*/
(define (markdown-parse-file file charset this scope fontifier)
   (hop-load-afile (dirname file))
   (call-with-input-file file
      (lambda (ip)
	 (markdown-parse ip charset this scope fontifier))))

;*---------------------------------------------------------------------*/
;*    markdown-parse-obj ...                                           */
;*---------------------------------------------------------------------*/
(define (markdown-parse-obj obj charset this scope fontifier)
   (if (eq? obj (js-undefined))
       ""
       (let ((str (cond
		     ((isa? obj JsStringLiteral)
		      (js-jsstring->string obj))
		     ((isa? obj JsFastBuffer)
		      (js-jsfastbuffer->string obj))
		     ((isa? obj JsSlowBuffer)
		      (js-jsslowbuffer->string obj))
		     (else
		      (js-tostring obj this)))))
	  (call-with-input-string str
	     (lambda (ip)
		(markdown-parse ip charset this scope fontifier))))))

;*---------------------------------------------------------------------*/
;*    markdown-generate ...                                            */
;*---------------------------------------------------------------------*/
(define (markdown-generate dom hss generator op)
   (generator dom hss op))

;*---------------------------------------------------------------------*/
;*    xml->markdown ...                                                */
;*---------------------------------------------------------------------*/
(define (xml->markdown dom hss)
   (call-with-output-string
      (lambda (op)
	 (markdown-generate dom hss xml->md op))))

;*---------------------------------------------------------------------*/
;*    The return value for dynamic-load                                */
;*---------------------------------------------------------------------*/
hopscript

